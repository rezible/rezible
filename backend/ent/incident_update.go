// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/rezible/rezible/ent/incident"
	"github.com/rezible/rezible/ent/incidentdebrief"
	"github.com/rezible/rezible/ent/incidentevent"
	"github.com/rezible/rezible/ent/incidentfieldoption"
	"github.com/rezible/rezible/ent/incidentlink"
	"github.com/rezible/rezible/ent/incidentmilestone"
	"github.com/rezible/rezible/ent/incidentroleassignment"
	"github.com/rezible/rezible/ent/incidentseverity"
	"github.com/rezible/rezible/ent/incidenttag"
	"github.com/rezible/rezible/ent/incidenttype"
	"github.com/rezible/rezible/ent/meetingsession"
	"github.com/rezible/rezible/ent/predicate"
	"github.com/rezible/rezible/ent/retrospective"
	"github.com/rezible/rezible/ent/task"
	"github.com/rezible/rezible/ent/user"
)

// IncidentUpdate is the builder for updating Incident entities.
type IncidentUpdate struct {
	config
	hooks     []Hook
	mutation  *IncidentMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the IncidentUpdate builder.
func (iu *IncidentUpdate) Where(ps ...predicate.Incident) *IncidentUpdate {
	iu.mutation.Where(ps...)
	return iu
}

// SetSlug sets the "slug" field.
func (iu *IncidentUpdate) SetSlug(s string) *IncidentUpdate {
	iu.mutation.SetSlug(s)
	return iu
}

// SetNillableSlug sets the "slug" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableSlug(s *string) *IncidentUpdate {
	if s != nil {
		iu.SetSlug(*s)
	}
	return iu
}

// SetTitle sets the "title" field.
func (iu *IncidentUpdate) SetTitle(s string) *IncidentUpdate {
	iu.mutation.SetTitle(s)
	return iu
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableTitle(s *string) *IncidentUpdate {
	if s != nil {
		iu.SetTitle(*s)
	}
	return iu
}

// SetPrivate sets the "private" field.
func (iu *IncidentUpdate) SetPrivate(b bool) *IncidentUpdate {
	iu.mutation.SetPrivate(b)
	return iu
}

// SetNillablePrivate sets the "private" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillablePrivate(b *bool) *IncidentUpdate {
	if b != nil {
		iu.SetPrivate(*b)
	}
	return iu
}

// SetSummary sets the "summary" field.
func (iu *IncidentUpdate) SetSummary(s string) *IncidentUpdate {
	iu.mutation.SetSummary(s)
	return iu
}

// SetNillableSummary sets the "summary" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableSummary(s *string) *IncidentUpdate {
	if s != nil {
		iu.SetSummary(*s)
	}
	return iu
}

// ClearSummary clears the value of the "summary" field.
func (iu *IncidentUpdate) ClearSummary() *IncidentUpdate {
	iu.mutation.ClearSummary()
	return iu
}

// SetOpenedAt sets the "opened_at" field.
func (iu *IncidentUpdate) SetOpenedAt(t time.Time) *IncidentUpdate {
	iu.mutation.SetOpenedAt(t)
	return iu
}

// SetNillableOpenedAt sets the "opened_at" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableOpenedAt(t *time.Time) *IncidentUpdate {
	if t != nil {
		iu.SetOpenedAt(*t)
	}
	return iu
}

// SetModifiedAt sets the "modified_at" field.
func (iu *IncidentUpdate) SetModifiedAt(t time.Time) *IncidentUpdate {
	iu.mutation.SetModifiedAt(t)
	return iu
}

// SetNillableModifiedAt sets the "modified_at" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableModifiedAt(t *time.Time) *IncidentUpdate {
	if t != nil {
		iu.SetModifiedAt(*t)
	}
	return iu
}

// ClearModifiedAt clears the value of the "modified_at" field.
func (iu *IncidentUpdate) ClearModifiedAt() *IncidentUpdate {
	iu.mutation.ClearModifiedAt()
	return iu
}

// SetClosedAt sets the "closed_at" field.
func (iu *IncidentUpdate) SetClosedAt(t time.Time) *IncidentUpdate {
	iu.mutation.SetClosedAt(t)
	return iu
}

// SetNillableClosedAt sets the "closed_at" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableClosedAt(t *time.Time) *IncidentUpdate {
	if t != nil {
		iu.SetClosedAt(*t)
	}
	return iu
}

// ClearClosedAt clears the value of the "closed_at" field.
func (iu *IncidentUpdate) ClearClosedAt() *IncidentUpdate {
	iu.mutation.ClearClosedAt()
	return iu
}

// SetProviderID sets the "provider_id" field.
func (iu *IncidentUpdate) SetProviderID(s string) *IncidentUpdate {
	iu.mutation.SetProviderID(s)
	return iu
}

// SetNillableProviderID sets the "provider_id" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableProviderID(s *string) *IncidentUpdate {
	if s != nil {
		iu.SetProviderID(*s)
	}
	return iu
}

// ClearProviderID clears the value of the "provider_id" field.
func (iu *IncidentUpdate) ClearProviderID() *IncidentUpdate {
	iu.mutation.ClearProviderID()
	return iu
}

// SetChatChannelID sets the "chat_channel_id" field.
func (iu *IncidentUpdate) SetChatChannelID(s string) *IncidentUpdate {
	iu.mutation.SetChatChannelID(s)
	return iu
}

// SetNillableChatChannelID sets the "chat_channel_id" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableChatChannelID(s *string) *IncidentUpdate {
	if s != nil {
		iu.SetChatChannelID(*s)
	}
	return iu
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (iu *IncidentUpdate) ClearChatChannelID() *IncidentUpdate {
	iu.mutation.ClearChatChannelID()
	return iu
}

// SetSeverityID sets the "severity_id" field.
func (iu *IncidentUpdate) SetSeverityID(u uuid.UUID) *IncidentUpdate {
	iu.mutation.SetSeverityID(u)
	return iu
}

// SetNillableSeverityID sets the "severity_id" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableSeverityID(u *uuid.UUID) *IncidentUpdate {
	if u != nil {
		iu.SetSeverityID(*u)
	}
	return iu
}

// ClearSeverityID clears the value of the "severity_id" field.
func (iu *IncidentUpdate) ClearSeverityID() *IncidentUpdate {
	iu.mutation.ClearSeverityID()
	return iu
}

// SetTypeID sets the "type_id" field.
func (iu *IncidentUpdate) SetTypeID(u uuid.UUID) *IncidentUpdate {
	iu.mutation.SetTypeID(u)
	return iu
}

// SetNillableTypeID sets the "type_id" field if the given value is not nil.
func (iu *IncidentUpdate) SetNillableTypeID(u *uuid.UUID) *IncidentUpdate {
	if u != nil {
		iu.SetTypeID(*u)
	}
	return iu
}

// ClearTypeID clears the value of the "type_id" field.
func (iu *IncidentUpdate) ClearTypeID() *IncidentUpdate {
	iu.mutation.ClearTypeID()
	return iu
}

// SetSeverity sets the "severity" edge to the IncidentSeverity entity.
func (iu *IncidentUpdate) SetSeverity(i *IncidentSeverity) *IncidentUpdate {
	return iu.SetSeverityID(i.ID)
}

// SetType sets the "type" edge to the IncidentType entity.
func (iu *IncidentUpdate) SetType(i *IncidentType) *IncidentUpdate {
	return iu.SetTypeID(i.ID)
}

// AddMilestoneIDs adds the "milestones" edge to the IncidentMilestone entity by IDs.
func (iu *IncidentUpdate) AddMilestoneIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddMilestoneIDs(ids...)
	return iu
}

// AddMilestones adds the "milestones" edges to the IncidentMilestone entity.
func (iu *IncidentUpdate) AddMilestones(i ...*IncidentMilestone) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddMilestoneIDs(ids...)
}

// AddEventIDs adds the "events" edge to the IncidentEvent entity by IDs.
func (iu *IncidentUpdate) AddEventIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddEventIDs(ids...)
	return iu
}

// AddEvents adds the "events" edges to the IncidentEvent entity.
func (iu *IncidentUpdate) AddEvents(i ...*IncidentEvent) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddEventIDs(ids...)
}

// SetRetrospectiveID sets the "retrospective" edge to the Retrospective entity by ID.
func (iu *IncidentUpdate) SetRetrospectiveID(id uuid.UUID) *IncidentUpdate {
	iu.mutation.SetRetrospectiveID(id)
	return iu
}

// SetNillableRetrospectiveID sets the "retrospective" edge to the Retrospective entity by ID if the given value is not nil.
func (iu *IncidentUpdate) SetNillableRetrospectiveID(id *uuid.UUID) *IncidentUpdate {
	if id != nil {
		iu = iu.SetRetrospectiveID(*id)
	}
	return iu
}

// SetRetrospective sets the "retrospective" edge to the Retrospective entity.
func (iu *IncidentUpdate) SetRetrospective(r *Retrospective) *IncidentUpdate {
	return iu.SetRetrospectiveID(r.ID)
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (iu *IncidentUpdate) AddUserIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddUserIDs(ids...)
	return iu
}

// AddUsers adds the "users" edges to the User entity.
func (iu *IncidentUpdate) AddUsers(u ...*User) *IncidentUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return iu.AddUserIDs(ids...)
}

// AddRoleAssignmentIDs adds the "role_assignments" edge to the IncidentRoleAssignment entity by IDs.
func (iu *IncidentUpdate) AddRoleAssignmentIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddRoleAssignmentIDs(ids...)
	return iu
}

// AddRoleAssignments adds the "role_assignments" edges to the IncidentRoleAssignment entity.
func (iu *IncidentUpdate) AddRoleAssignments(i ...*IncidentRoleAssignment) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddRoleAssignmentIDs(ids...)
}

// AddLinkedIncidentIDs adds the "linked_incidents" edge to the Incident entity by IDs.
func (iu *IncidentUpdate) AddLinkedIncidentIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddLinkedIncidentIDs(ids...)
	return iu
}

// AddLinkedIncidents adds the "linked_incidents" edges to the Incident entity.
func (iu *IncidentUpdate) AddLinkedIncidents(i ...*Incident) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddLinkedIncidentIDs(ids...)
}

// AddFieldSelectionIDs adds the "field_selections" edge to the IncidentFieldOption entity by IDs.
func (iu *IncidentUpdate) AddFieldSelectionIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddFieldSelectionIDs(ids...)
	return iu
}

// AddFieldSelections adds the "field_selections" edges to the IncidentFieldOption entity.
func (iu *IncidentUpdate) AddFieldSelections(i ...*IncidentFieldOption) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddFieldSelectionIDs(ids...)
}

// AddTaskIDs adds the "tasks" edge to the Task entity by IDs.
func (iu *IncidentUpdate) AddTaskIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddTaskIDs(ids...)
	return iu
}

// AddTasks adds the "tasks" edges to the Task entity.
func (iu *IncidentUpdate) AddTasks(t ...*Task) *IncidentUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return iu.AddTaskIDs(ids...)
}

// AddTagAssignmentIDs adds the "tag_assignments" edge to the IncidentTag entity by IDs.
func (iu *IncidentUpdate) AddTagAssignmentIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddTagAssignmentIDs(ids...)
	return iu
}

// AddTagAssignments adds the "tag_assignments" edges to the IncidentTag entity.
func (iu *IncidentUpdate) AddTagAssignments(i ...*IncidentTag) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddTagAssignmentIDs(ids...)
}

// AddDebriefIDs adds the "debriefs" edge to the IncidentDebrief entity by IDs.
func (iu *IncidentUpdate) AddDebriefIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddDebriefIDs(ids...)
	return iu
}

// AddDebriefs adds the "debriefs" edges to the IncidentDebrief entity.
func (iu *IncidentUpdate) AddDebriefs(i ...*IncidentDebrief) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddDebriefIDs(ids...)
}

// AddReviewSessionIDs adds the "review_sessions" edge to the MeetingSession entity by IDs.
func (iu *IncidentUpdate) AddReviewSessionIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddReviewSessionIDs(ids...)
	return iu
}

// AddReviewSessions adds the "review_sessions" edges to the MeetingSession entity.
func (iu *IncidentUpdate) AddReviewSessions(m ...*MeetingSession) *IncidentUpdate {
	ids := make([]uuid.UUID, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return iu.AddReviewSessionIDs(ids...)
}

// AddUserRoleIDs adds the "user_roles" edge to the IncidentRoleAssignment entity by IDs.
func (iu *IncidentUpdate) AddUserRoleIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.AddUserRoleIDs(ids...)
	return iu
}

// AddUserRoles adds the "user_roles" edges to the IncidentRoleAssignment entity.
func (iu *IncidentUpdate) AddUserRoles(i ...*IncidentRoleAssignment) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddUserRoleIDs(ids...)
}

// AddIncidentLinkIDs adds the "incident_links" edge to the IncidentLink entity by IDs.
func (iu *IncidentUpdate) AddIncidentLinkIDs(ids ...int) *IncidentUpdate {
	iu.mutation.AddIncidentLinkIDs(ids...)
	return iu
}

// AddIncidentLinks adds the "incident_links" edges to the IncidentLink entity.
func (iu *IncidentUpdate) AddIncidentLinks(i ...*IncidentLink) *IncidentUpdate {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddIncidentLinkIDs(ids...)
}

// Mutation returns the IncidentMutation object of the builder.
func (iu *IncidentUpdate) Mutation() *IncidentMutation {
	return iu.mutation
}

// ClearSeverity clears the "severity" edge to the IncidentSeverity entity.
func (iu *IncidentUpdate) ClearSeverity() *IncidentUpdate {
	iu.mutation.ClearSeverity()
	return iu
}

// ClearType clears the "type" edge to the IncidentType entity.
func (iu *IncidentUpdate) ClearType() *IncidentUpdate {
	iu.mutation.ClearType()
	return iu
}

// ClearMilestones clears all "milestones" edges to the IncidentMilestone entity.
func (iu *IncidentUpdate) ClearMilestones() *IncidentUpdate {
	iu.mutation.ClearMilestones()
	return iu
}

// RemoveMilestoneIDs removes the "milestones" edge to IncidentMilestone entities by IDs.
func (iu *IncidentUpdate) RemoveMilestoneIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveMilestoneIDs(ids...)
	return iu
}

// RemoveMilestones removes "milestones" edges to IncidentMilestone entities.
func (iu *IncidentUpdate) RemoveMilestones(i ...*IncidentMilestone) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveMilestoneIDs(ids...)
}

// ClearEvents clears all "events" edges to the IncidentEvent entity.
func (iu *IncidentUpdate) ClearEvents() *IncidentUpdate {
	iu.mutation.ClearEvents()
	return iu
}

// RemoveEventIDs removes the "events" edge to IncidentEvent entities by IDs.
func (iu *IncidentUpdate) RemoveEventIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveEventIDs(ids...)
	return iu
}

// RemoveEvents removes "events" edges to IncidentEvent entities.
func (iu *IncidentUpdate) RemoveEvents(i ...*IncidentEvent) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveEventIDs(ids...)
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (iu *IncidentUpdate) ClearRetrospective() *IncidentUpdate {
	iu.mutation.ClearRetrospective()
	return iu
}

// ClearUsers clears all "users" edges to the User entity.
func (iu *IncidentUpdate) ClearUsers() *IncidentUpdate {
	iu.mutation.ClearUsers()
	return iu
}

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (iu *IncidentUpdate) RemoveUserIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveUserIDs(ids...)
	return iu
}

// RemoveUsers removes "users" edges to User entities.
func (iu *IncidentUpdate) RemoveUsers(u ...*User) *IncidentUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return iu.RemoveUserIDs(ids...)
}

// ClearRoleAssignments clears all "role_assignments" edges to the IncidentRoleAssignment entity.
func (iu *IncidentUpdate) ClearRoleAssignments() *IncidentUpdate {
	iu.mutation.ClearRoleAssignments()
	return iu
}

// RemoveRoleAssignmentIDs removes the "role_assignments" edge to IncidentRoleAssignment entities by IDs.
func (iu *IncidentUpdate) RemoveRoleAssignmentIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveRoleAssignmentIDs(ids...)
	return iu
}

// RemoveRoleAssignments removes "role_assignments" edges to IncidentRoleAssignment entities.
func (iu *IncidentUpdate) RemoveRoleAssignments(i ...*IncidentRoleAssignment) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveRoleAssignmentIDs(ids...)
}

// ClearLinkedIncidents clears all "linked_incidents" edges to the Incident entity.
func (iu *IncidentUpdate) ClearLinkedIncidents() *IncidentUpdate {
	iu.mutation.ClearLinkedIncidents()
	return iu
}

// RemoveLinkedIncidentIDs removes the "linked_incidents" edge to Incident entities by IDs.
func (iu *IncidentUpdate) RemoveLinkedIncidentIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveLinkedIncidentIDs(ids...)
	return iu
}

// RemoveLinkedIncidents removes "linked_incidents" edges to Incident entities.
func (iu *IncidentUpdate) RemoveLinkedIncidents(i ...*Incident) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveLinkedIncidentIDs(ids...)
}

// ClearFieldSelections clears all "field_selections" edges to the IncidentFieldOption entity.
func (iu *IncidentUpdate) ClearFieldSelections() *IncidentUpdate {
	iu.mutation.ClearFieldSelections()
	return iu
}

// RemoveFieldSelectionIDs removes the "field_selections" edge to IncidentFieldOption entities by IDs.
func (iu *IncidentUpdate) RemoveFieldSelectionIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveFieldSelectionIDs(ids...)
	return iu
}

// RemoveFieldSelections removes "field_selections" edges to IncidentFieldOption entities.
func (iu *IncidentUpdate) RemoveFieldSelections(i ...*IncidentFieldOption) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveFieldSelectionIDs(ids...)
}

// ClearTasks clears all "tasks" edges to the Task entity.
func (iu *IncidentUpdate) ClearTasks() *IncidentUpdate {
	iu.mutation.ClearTasks()
	return iu
}

// RemoveTaskIDs removes the "tasks" edge to Task entities by IDs.
func (iu *IncidentUpdate) RemoveTaskIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveTaskIDs(ids...)
	return iu
}

// RemoveTasks removes "tasks" edges to Task entities.
func (iu *IncidentUpdate) RemoveTasks(t ...*Task) *IncidentUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return iu.RemoveTaskIDs(ids...)
}

// ClearTagAssignments clears all "tag_assignments" edges to the IncidentTag entity.
func (iu *IncidentUpdate) ClearTagAssignments() *IncidentUpdate {
	iu.mutation.ClearTagAssignments()
	return iu
}

// RemoveTagAssignmentIDs removes the "tag_assignments" edge to IncidentTag entities by IDs.
func (iu *IncidentUpdate) RemoveTagAssignmentIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveTagAssignmentIDs(ids...)
	return iu
}

// RemoveTagAssignments removes "tag_assignments" edges to IncidentTag entities.
func (iu *IncidentUpdate) RemoveTagAssignments(i ...*IncidentTag) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveTagAssignmentIDs(ids...)
}

// ClearDebriefs clears all "debriefs" edges to the IncidentDebrief entity.
func (iu *IncidentUpdate) ClearDebriefs() *IncidentUpdate {
	iu.mutation.ClearDebriefs()
	return iu
}

// RemoveDebriefIDs removes the "debriefs" edge to IncidentDebrief entities by IDs.
func (iu *IncidentUpdate) RemoveDebriefIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveDebriefIDs(ids...)
	return iu
}

// RemoveDebriefs removes "debriefs" edges to IncidentDebrief entities.
func (iu *IncidentUpdate) RemoveDebriefs(i ...*IncidentDebrief) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveDebriefIDs(ids...)
}

// ClearReviewSessions clears all "review_sessions" edges to the MeetingSession entity.
func (iu *IncidentUpdate) ClearReviewSessions() *IncidentUpdate {
	iu.mutation.ClearReviewSessions()
	return iu
}

// RemoveReviewSessionIDs removes the "review_sessions" edge to MeetingSession entities by IDs.
func (iu *IncidentUpdate) RemoveReviewSessionIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveReviewSessionIDs(ids...)
	return iu
}

// RemoveReviewSessions removes "review_sessions" edges to MeetingSession entities.
func (iu *IncidentUpdate) RemoveReviewSessions(m ...*MeetingSession) *IncidentUpdate {
	ids := make([]uuid.UUID, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return iu.RemoveReviewSessionIDs(ids...)
}

// ClearUserRoles clears all "user_roles" edges to the IncidentRoleAssignment entity.
func (iu *IncidentUpdate) ClearUserRoles() *IncidentUpdate {
	iu.mutation.ClearUserRoles()
	return iu
}

// RemoveUserRoleIDs removes the "user_roles" edge to IncidentRoleAssignment entities by IDs.
func (iu *IncidentUpdate) RemoveUserRoleIDs(ids ...uuid.UUID) *IncidentUpdate {
	iu.mutation.RemoveUserRoleIDs(ids...)
	return iu
}

// RemoveUserRoles removes "user_roles" edges to IncidentRoleAssignment entities.
func (iu *IncidentUpdate) RemoveUserRoles(i ...*IncidentRoleAssignment) *IncidentUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveUserRoleIDs(ids...)
}

// ClearIncidentLinks clears all "incident_links" edges to the IncidentLink entity.
func (iu *IncidentUpdate) ClearIncidentLinks() *IncidentUpdate {
	iu.mutation.ClearIncidentLinks()
	return iu
}

// RemoveIncidentLinkIDs removes the "incident_links" edge to IncidentLink entities by IDs.
func (iu *IncidentUpdate) RemoveIncidentLinkIDs(ids ...int) *IncidentUpdate {
	iu.mutation.RemoveIncidentLinkIDs(ids...)
	return iu
}

// RemoveIncidentLinks removes "incident_links" edges to IncidentLink entities.
func (iu *IncidentUpdate) RemoveIncidentLinks(i ...*IncidentLink) *IncidentUpdate {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveIncidentLinkIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (iu *IncidentUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, iu.sqlSave, iu.mutation, iu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (iu *IncidentUpdate) SaveX(ctx context.Context) int {
	affected, err := iu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (iu *IncidentUpdate) Exec(ctx context.Context) error {
	_, err := iu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iu *IncidentUpdate) ExecX(ctx context.Context) {
	if err := iu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (iu *IncidentUpdate) check() error {
	if iu.mutation.TenantCleared() && len(iu.mutation.TenantIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Incident.tenant"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (iu *IncidentUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *IncidentUpdate {
	iu.modifiers = append(iu.modifiers, modifiers...)
	return iu
}

func (iu *IncidentUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := iu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(incident.Table, incident.Columns, sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID))
	if ps := iu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := iu.mutation.Slug(); ok {
		_spec.SetField(incident.FieldSlug, field.TypeString, value)
	}
	if value, ok := iu.mutation.Title(); ok {
		_spec.SetField(incident.FieldTitle, field.TypeString, value)
	}
	if value, ok := iu.mutation.Private(); ok {
		_spec.SetField(incident.FieldPrivate, field.TypeBool, value)
	}
	if value, ok := iu.mutation.Summary(); ok {
		_spec.SetField(incident.FieldSummary, field.TypeString, value)
	}
	if iu.mutation.SummaryCleared() {
		_spec.ClearField(incident.FieldSummary, field.TypeString)
	}
	if value, ok := iu.mutation.OpenedAt(); ok {
		_spec.SetField(incident.FieldOpenedAt, field.TypeTime, value)
	}
	if value, ok := iu.mutation.ModifiedAt(); ok {
		_spec.SetField(incident.FieldModifiedAt, field.TypeTime, value)
	}
	if iu.mutation.ModifiedAtCleared() {
		_spec.ClearField(incident.FieldModifiedAt, field.TypeTime)
	}
	if value, ok := iu.mutation.ClosedAt(); ok {
		_spec.SetField(incident.FieldClosedAt, field.TypeTime, value)
	}
	if iu.mutation.ClosedAtCleared() {
		_spec.ClearField(incident.FieldClosedAt, field.TypeTime)
	}
	if value, ok := iu.mutation.ProviderID(); ok {
		_spec.SetField(incident.FieldProviderID, field.TypeString, value)
	}
	if iu.mutation.ProviderIDCleared() {
		_spec.ClearField(incident.FieldProviderID, field.TypeString)
	}
	if value, ok := iu.mutation.ChatChannelID(); ok {
		_spec.SetField(incident.FieldChatChannelID, field.TypeString, value)
	}
	if iu.mutation.ChatChannelIDCleared() {
		_spec.ClearField(incident.FieldChatChannelID, field.TypeString)
	}
	if iu.mutation.SeverityCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.SeverityTable,
			Columns: []string{incident.SeverityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentseverity.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.SeverityIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.SeverityTable,
			Columns: []string{incident.SeverityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentseverity.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.TypeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.TypeTable,
			Columns: []string{incident.TypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttype.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.TypeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.TypeTable,
			Columns: []string{incident.TypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttype.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.MilestonesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.MilestonesTable,
			Columns: []string{incident.MilestonesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentmilestone.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedMilestonesIDs(); len(nodes) > 0 && !iu.mutation.MilestonesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.MilestonesTable,
			Columns: []string{incident.MilestonesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentmilestone.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.MilestonesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.MilestonesTable,
			Columns: []string{incident.MilestonesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentmilestone.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.EventsTable,
			Columns: []string{incident.EventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentevent.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedEventsIDs(); len(nodes) > 0 && !iu.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.EventsTable,
			Columns: []string{incident.EventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentevent.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.EventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.EventsTable,
			Columns: []string{incident.EventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentevent.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.RetrospectiveCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   incident.RetrospectiveTable,
			Columns: []string{incident.RetrospectiveColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(retrospective.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RetrospectiveIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   incident.RetrospectiveTable,
			Columns: []string{incident.RetrospectiveColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(retrospective.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   incident.UsersTable,
			Columns: incident.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		createE := &IncidentRoleAssignmentCreate{config: iu.config, mutation: newIncidentRoleAssignmentMutation(iu.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		if specE.ID.Value != nil {
			edge.Target.Fields = append(edge.Target.Fields, specE.ID)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedUsersIDs(); len(nodes) > 0 && !iu.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   incident.UsersTable,
			Columns: incident.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &IncidentRoleAssignmentCreate{config: iu.config, mutation: newIncidentRoleAssignmentMutation(iu.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		if specE.ID.Value != nil {
			edge.Target.Fields = append(edge.Target.Fields, specE.ID)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   incident.UsersTable,
			Columns: incident.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &IncidentRoleAssignmentCreate{config: iu.config, mutation: newIncidentRoleAssignmentMutation(iu.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		if specE.ID.Value != nil {
			edge.Target.Fields = append(edge.Target.Fields, specE.ID)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.RoleAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.RoleAssignmentsTable,
			Columns: []string{incident.RoleAssignmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedRoleAssignmentsIDs(); len(nodes) > 0 && !iu.mutation.RoleAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.RoleAssignmentsTable,
			Columns: []string{incident.RoleAssignmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RoleAssignmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.RoleAssignmentsTable,
			Columns: []string{incident.RoleAssignmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.LinkedIncidentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.LinkedIncidentsTable,
			Columns: incident.LinkedIncidentsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedLinkedIncidentsIDs(); len(nodes) > 0 && !iu.mutation.LinkedIncidentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.LinkedIncidentsTable,
			Columns: incident.LinkedIncidentsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.LinkedIncidentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.LinkedIncidentsTable,
			Columns: incident.LinkedIncidentsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.FieldSelectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.FieldSelectionsTable,
			Columns: incident.FieldSelectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentfieldoption.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedFieldSelectionsIDs(); len(nodes) > 0 && !iu.mutation.FieldSelectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.FieldSelectionsTable,
			Columns: incident.FieldSelectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentfieldoption.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.FieldSelectionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.FieldSelectionsTable,
			Columns: incident.FieldSelectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentfieldoption.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.TasksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.TasksTable,
			Columns: []string{incident.TasksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedTasksIDs(); len(nodes) > 0 && !iu.mutation.TasksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.TasksTable,
			Columns: []string{incident.TasksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.TasksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.TasksTable,
			Columns: []string{incident.TasksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.TagAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.TagAssignmentsTable,
			Columns: incident.TagAssignmentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttag.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedTagAssignmentsIDs(); len(nodes) > 0 && !iu.mutation.TagAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.TagAssignmentsTable,
			Columns: incident.TagAssignmentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttag.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.TagAssignmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.TagAssignmentsTable,
			Columns: incident.TagAssignmentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttag.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.DebriefsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.DebriefsTable,
			Columns: []string{incident.DebriefsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentdebrief.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedDebriefsIDs(); len(nodes) > 0 && !iu.mutation.DebriefsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.DebriefsTable,
			Columns: []string{incident.DebriefsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentdebrief.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.DebriefsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.DebriefsTable,
			Columns: []string{incident.DebriefsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentdebrief.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.ReviewSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.ReviewSessionsTable,
			Columns: incident.ReviewSessionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(meetingsession.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedReviewSessionsIDs(); len(nodes) > 0 && !iu.mutation.ReviewSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.ReviewSessionsTable,
			Columns: incident.ReviewSessionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(meetingsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.ReviewSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.ReviewSessionsTable,
			Columns: incident.ReviewSessionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(meetingsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.UserRolesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.UserRolesTable,
			Columns: []string{incident.UserRolesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedUserRolesIDs(); len(nodes) > 0 && !iu.mutation.UserRolesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.UserRolesTable,
			Columns: []string{incident.UserRolesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.UserRolesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.UserRolesTable,
			Columns: []string{incident.UserRolesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.IncidentLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.IncidentLinksTable,
			Columns: []string{incident.IncidentLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentlink.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedIncidentLinksIDs(); len(nodes) > 0 && !iu.mutation.IncidentLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.IncidentLinksTable,
			Columns: []string{incident.IncidentLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentlink.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.IncidentLinksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.IncidentLinksTable,
			Columns: []string{incident.IncidentLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentlink.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.AddModifiers(iu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, iu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{incident.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	iu.mutation.done = true
	return n, nil
}

// IncidentUpdateOne is the builder for updating a single Incident entity.
type IncidentUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *IncidentMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetSlug sets the "slug" field.
func (iuo *IncidentUpdateOne) SetSlug(s string) *IncidentUpdateOne {
	iuo.mutation.SetSlug(s)
	return iuo
}

// SetNillableSlug sets the "slug" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableSlug(s *string) *IncidentUpdateOne {
	if s != nil {
		iuo.SetSlug(*s)
	}
	return iuo
}

// SetTitle sets the "title" field.
func (iuo *IncidentUpdateOne) SetTitle(s string) *IncidentUpdateOne {
	iuo.mutation.SetTitle(s)
	return iuo
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableTitle(s *string) *IncidentUpdateOne {
	if s != nil {
		iuo.SetTitle(*s)
	}
	return iuo
}

// SetPrivate sets the "private" field.
func (iuo *IncidentUpdateOne) SetPrivate(b bool) *IncidentUpdateOne {
	iuo.mutation.SetPrivate(b)
	return iuo
}

// SetNillablePrivate sets the "private" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillablePrivate(b *bool) *IncidentUpdateOne {
	if b != nil {
		iuo.SetPrivate(*b)
	}
	return iuo
}

// SetSummary sets the "summary" field.
func (iuo *IncidentUpdateOne) SetSummary(s string) *IncidentUpdateOne {
	iuo.mutation.SetSummary(s)
	return iuo
}

// SetNillableSummary sets the "summary" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableSummary(s *string) *IncidentUpdateOne {
	if s != nil {
		iuo.SetSummary(*s)
	}
	return iuo
}

// ClearSummary clears the value of the "summary" field.
func (iuo *IncidentUpdateOne) ClearSummary() *IncidentUpdateOne {
	iuo.mutation.ClearSummary()
	return iuo
}

// SetOpenedAt sets the "opened_at" field.
func (iuo *IncidentUpdateOne) SetOpenedAt(t time.Time) *IncidentUpdateOne {
	iuo.mutation.SetOpenedAt(t)
	return iuo
}

// SetNillableOpenedAt sets the "opened_at" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableOpenedAt(t *time.Time) *IncidentUpdateOne {
	if t != nil {
		iuo.SetOpenedAt(*t)
	}
	return iuo
}

// SetModifiedAt sets the "modified_at" field.
func (iuo *IncidentUpdateOne) SetModifiedAt(t time.Time) *IncidentUpdateOne {
	iuo.mutation.SetModifiedAt(t)
	return iuo
}

// SetNillableModifiedAt sets the "modified_at" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableModifiedAt(t *time.Time) *IncidentUpdateOne {
	if t != nil {
		iuo.SetModifiedAt(*t)
	}
	return iuo
}

// ClearModifiedAt clears the value of the "modified_at" field.
func (iuo *IncidentUpdateOne) ClearModifiedAt() *IncidentUpdateOne {
	iuo.mutation.ClearModifiedAt()
	return iuo
}

// SetClosedAt sets the "closed_at" field.
func (iuo *IncidentUpdateOne) SetClosedAt(t time.Time) *IncidentUpdateOne {
	iuo.mutation.SetClosedAt(t)
	return iuo
}

// SetNillableClosedAt sets the "closed_at" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableClosedAt(t *time.Time) *IncidentUpdateOne {
	if t != nil {
		iuo.SetClosedAt(*t)
	}
	return iuo
}

// ClearClosedAt clears the value of the "closed_at" field.
func (iuo *IncidentUpdateOne) ClearClosedAt() *IncidentUpdateOne {
	iuo.mutation.ClearClosedAt()
	return iuo
}

// SetProviderID sets the "provider_id" field.
func (iuo *IncidentUpdateOne) SetProviderID(s string) *IncidentUpdateOne {
	iuo.mutation.SetProviderID(s)
	return iuo
}

// SetNillableProviderID sets the "provider_id" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableProviderID(s *string) *IncidentUpdateOne {
	if s != nil {
		iuo.SetProviderID(*s)
	}
	return iuo
}

// ClearProviderID clears the value of the "provider_id" field.
func (iuo *IncidentUpdateOne) ClearProviderID() *IncidentUpdateOne {
	iuo.mutation.ClearProviderID()
	return iuo
}

// SetChatChannelID sets the "chat_channel_id" field.
func (iuo *IncidentUpdateOne) SetChatChannelID(s string) *IncidentUpdateOne {
	iuo.mutation.SetChatChannelID(s)
	return iuo
}

// SetNillableChatChannelID sets the "chat_channel_id" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableChatChannelID(s *string) *IncidentUpdateOne {
	if s != nil {
		iuo.SetChatChannelID(*s)
	}
	return iuo
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (iuo *IncidentUpdateOne) ClearChatChannelID() *IncidentUpdateOne {
	iuo.mutation.ClearChatChannelID()
	return iuo
}

// SetSeverityID sets the "severity_id" field.
func (iuo *IncidentUpdateOne) SetSeverityID(u uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.SetSeverityID(u)
	return iuo
}

// SetNillableSeverityID sets the "severity_id" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableSeverityID(u *uuid.UUID) *IncidentUpdateOne {
	if u != nil {
		iuo.SetSeverityID(*u)
	}
	return iuo
}

// ClearSeverityID clears the value of the "severity_id" field.
func (iuo *IncidentUpdateOne) ClearSeverityID() *IncidentUpdateOne {
	iuo.mutation.ClearSeverityID()
	return iuo
}

// SetTypeID sets the "type_id" field.
func (iuo *IncidentUpdateOne) SetTypeID(u uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.SetTypeID(u)
	return iuo
}

// SetNillableTypeID sets the "type_id" field if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableTypeID(u *uuid.UUID) *IncidentUpdateOne {
	if u != nil {
		iuo.SetTypeID(*u)
	}
	return iuo
}

// ClearTypeID clears the value of the "type_id" field.
func (iuo *IncidentUpdateOne) ClearTypeID() *IncidentUpdateOne {
	iuo.mutation.ClearTypeID()
	return iuo
}

// SetSeverity sets the "severity" edge to the IncidentSeverity entity.
func (iuo *IncidentUpdateOne) SetSeverity(i *IncidentSeverity) *IncidentUpdateOne {
	return iuo.SetSeverityID(i.ID)
}

// SetType sets the "type" edge to the IncidentType entity.
func (iuo *IncidentUpdateOne) SetType(i *IncidentType) *IncidentUpdateOne {
	return iuo.SetTypeID(i.ID)
}

// AddMilestoneIDs adds the "milestones" edge to the IncidentMilestone entity by IDs.
func (iuo *IncidentUpdateOne) AddMilestoneIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddMilestoneIDs(ids...)
	return iuo
}

// AddMilestones adds the "milestones" edges to the IncidentMilestone entity.
func (iuo *IncidentUpdateOne) AddMilestones(i ...*IncidentMilestone) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddMilestoneIDs(ids...)
}

// AddEventIDs adds the "events" edge to the IncidentEvent entity by IDs.
func (iuo *IncidentUpdateOne) AddEventIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddEventIDs(ids...)
	return iuo
}

// AddEvents adds the "events" edges to the IncidentEvent entity.
func (iuo *IncidentUpdateOne) AddEvents(i ...*IncidentEvent) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddEventIDs(ids...)
}

// SetRetrospectiveID sets the "retrospective" edge to the Retrospective entity by ID.
func (iuo *IncidentUpdateOne) SetRetrospectiveID(id uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.SetRetrospectiveID(id)
	return iuo
}

// SetNillableRetrospectiveID sets the "retrospective" edge to the Retrospective entity by ID if the given value is not nil.
func (iuo *IncidentUpdateOne) SetNillableRetrospectiveID(id *uuid.UUID) *IncidentUpdateOne {
	if id != nil {
		iuo = iuo.SetRetrospectiveID(*id)
	}
	return iuo
}

// SetRetrospective sets the "retrospective" edge to the Retrospective entity.
func (iuo *IncidentUpdateOne) SetRetrospective(r *Retrospective) *IncidentUpdateOne {
	return iuo.SetRetrospectiveID(r.ID)
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (iuo *IncidentUpdateOne) AddUserIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddUserIDs(ids...)
	return iuo
}

// AddUsers adds the "users" edges to the User entity.
func (iuo *IncidentUpdateOne) AddUsers(u ...*User) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return iuo.AddUserIDs(ids...)
}

// AddRoleAssignmentIDs adds the "role_assignments" edge to the IncidentRoleAssignment entity by IDs.
func (iuo *IncidentUpdateOne) AddRoleAssignmentIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddRoleAssignmentIDs(ids...)
	return iuo
}

// AddRoleAssignments adds the "role_assignments" edges to the IncidentRoleAssignment entity.
func (iuo *IncidentUpdateOne) AddRoleAssignments(i ...*IncidentRoleAssignment) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddRoleAssignmentIDs(ids...)
}

// AddLinkedIncidentIDs adds the "linked_incidents" edge to the Incident entity by IDs.
func (iuo *IncidentUpdateOne) AddLinkedIncidentIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddLinkedIncidentIDs(ids...)
	return iuo
}

// AddLinkedIncidents adds the "linked_incidents" edges to the Incident entity.
func (iuo *IncidentUpdateOne) AddLinkedIncidents(i ...*Incident) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddLinkedIncidentIDs(ids...)
}

// AddFieldSelectionIDs adds the "field_selections" edge to the IncidentFieldOption entity by IDs.
func (iuo *IncidentUpdateOne) AddFieldSelectionIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddFieldSelectionIDs(ids...)
	return iuo
}

// AddFieldSelections adds the "field_selections" edges to the IncidentFieldOption entity.
func (iuo *IncidentUpdateOne) AddFieldSelections(i ...*IncidentFieldOption) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddFieldSelectionIDs(ids...)
}

// AddTaskIDs adds the "tasks" edge to the Task entity by IDs.
func (iuo *IncidentUpdateOne) AddTaskIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddTaskIDs(ids...)
	return iuo
}

// AddTasks adds the "tasks" edges to the Task entity.
func (iuo *IncidentUpdateOne) AddTasks(t ...*Task) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return iuo.AddTaskIDs(ids...)
}

// AddTagAssignmentIDs adds the "tag_assignments" edge to the IncidentTag entity by IDs.
func (iuo *IncidentUpdateOne) AddTagAssignmentIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddTagAssignmentIDs(ids...)
	return iuo
}

// AddTagAssignments adds the "tag_assignments" edges to the IncidentTag entity.
func (iuo *IncidentUpdateOne) AddTagAssignments(i ...*IncidentTag) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddTagAssignmentIDs(ids...)
}

// AddDebriefIDs adds the "debriefs" edge to the IncidentDebrief entity by IDs.
func (iuo *IncidentUpdateOne) AddDebriefIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddDebriefIDs(ids...)
	return iuo
}

// AddDebriefs adds the "debriefs" edges to the IncidentDebrief entity.
func (iuo *IncidentUpdateOne) AddDebriefs(i ...*IncidentDebrief) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddDebriefIDs(ids...)
}

// AddReviewSessionIDs adds the "review_sessions" edge to the MeetingSession entity by IDs.
func (iuo *IncidentUpdateOne) AddReviewSessionIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddReviewSessionIDs(ids...)
	return iuo
}

// AddReviewSessions adds the "review_sessions" edges to the MeetingSession entity.
func (iuo *IncidentUpdateOne) AddReviewSessions(m ...*MeetingSession) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return iuo.AddReviewSessionIDs(ids...)
}

// AddUserRoleIDs adds the "user_roles" edge to the IncidentRoleAssignment entity by IDs.
func (iuo *IncidentUpdateOne) AddUserRoleIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.AddUserRoleIDs(ids...)
	return iuo
}

// AddUserRoles adds the "user_roles" edges to the IncidentRoleAssignment entity.
func (iuo *IncidentUpdateOne) AddUserRoles(i ...*IncidentRoleAssignment) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddUserRoleIDs(ids...)
}

// AddIncidentLinkIDs adds the "incident_links" edge to the IncidentLink entity by IDs.
func (iuo *IncidentUpdateOne) AddIncidentLinkIDs(ids ...int) *IncidentUpdateOne {
	iuo.mutation.AddIncidentLinkIDs(ids...)
	return iuo
}

// AddIncidentLinks adds the "incident_links" edges to the IncidentLink entity.
func (iuo *IncidentUpdateOne) AddIncidentLinks(i ...*IncidentLink) *IncidentUpdateOne {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddIncidentLinkIDs(ids...)
}

// Mutation returns the IncidentMutation object of the builder.
func (iuo *IncidentUpdateOne) Mutation() *IncidentMutation {
	return iuo.mutation
}

// ClearSeverity clears the "severity" edge to the IncidentSeverity entity.
func (iuo *IncidentUpdateOne) ClearSeverity() *IncidentUpdateOne {
	iuo.mutation.ClearSeverity()
	return iuo
}

// ClearType clears the "type" edge to the IncidentType entity.
func (iuo *IncidentUpdateOne) ClearType() *IncidentUpdateOne {
	iuo.mutation.ClearType()
	return iuo
}

// ClearMilestones clears all "milestones" edges to the IncidentMilestone entity.
func (iuo *IncidentUpdateOne) ClearMilestones() *IncidentUpdateOne {
	iuo.mutation.ClearMilestones()
	return iuo
}

// RemoveMilestoneIDs removes the "milestones" edge to IncidentMilestone entities by IDs.
func (iuo *IncidentUpdateOne) RemoveMilestoneIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveMilestoneIDs(ids...)
	return iuo
}

// RemoveMilestones removes "milestones" edges to IncidentMilestone entities.
func (iuo *IncidentUpdateOne) RemoveMilestones(i ...*IncidentMilestone) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveMilestoneIDs(ids...)
}

// ClearEvents clears all "events" edges to the IncidentEvent entity.
func (iuo *IncidentUpdateOne) ClearEvents() *IncidentUpdateOne {
	iuo.mutation.ClearEvents()
	return iuo
}

// RemoveEventIDs removes the "events" edge to IncidentEvent entities by IDs.
func (iuo *IncidentUpdateOne) RemoveEventIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveEventIDs(ids...)
	return iuo
}

// RemoveEvents removes "events" edges to IncidentEvent entities.
func (iuo *IncidentUpdateOne) RemoveEvents(i ...*IncidentEvent) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveEventIDs(ids...)
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (iuo *IncidentUpdateOne) ClearRetrospective() *IncidentUpdateOne {
	iuo.mutation.ClearRetrospective()
	return iuo
}

// ClearUsers clears all "users" edges to the User entity.
func (iuo *IncidentUpdateOne) ClearUsers() *IncidentUpdateOne {
	iuo.mutation.ClearUsers()
	return iuo
}

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (iuo *IncidentUpdateOne) RemoveUserIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveUserIDs(ids...)
	return iuo
}

// RemoveUsers removes "users" edges to User entities.
func (iuo *IncidentUpdateOne) RemoveUsers(u ...*User) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return iuo.RemoveUserIDs(ids...)
}

// ClearRoleAssignments clears all "role_assignments" edges to the IncidentRoleAssignment entity.
func (iuo *IncidentUpdateOne) ClearRoleAssignments() *IncidentUpdateOne {
	iuo.mutation.ClearRoleAssignments()
	return iuo
}

// RemoveRoleAssignmentIDs removes the "role_assignments" edge to IncidentRoleAssignment entities by IDs.
func (iuo *IncidentUpdateOne) RemoveRoleAssignmentIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveRoleAssignmentIDs(ids...)
	return iuo
}

// RemoveRoleAssignments removes "role_assignments" edges to IncidentRoleAssignment entities.
func (iuo *IncidentUpdateOne) RemoveRoleAssignments(i ...*IncidentRoleAssignment) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveRoleAssignmentIDs(ids...)
}

// ClearLinkedIncidents clears all "linked_incidents" edges to the Incident entity.
func (iuo *IncidentUpdateOne) ClearLinkedIncidents() *IncidentUpdateOne {
	iuo.mutation.ClearLinkedIncidents()
	return iuo
}

// RemoveLinkedIncidentIDs removes the "linked_incidents" edge to Incident entities by IDs.
func (iuo *IncidentUpdateOne) RemoveLinkedIncidentIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveLinkedIncidentIDs(ids...)
	return iuo
}

// RemoveLinkedIncidents removes "linked_incidents" edges to Incident entities.
func (iuo *IncidentUpdateOne) RemoveLinkedIncidents(i ...*Incident) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveLinkedIncidentIDs(ids...)
}

// ClearFieldSelections clears all "field_selections" edges to the IncidentFieldOption entity.
func (iuo *IncidentUpdateOne) ClearFieldSelections() *IncidentUpdateOne {
	iuo.mutation.ClearFieldSelections()
	return iuo
}

// RemoveFieldSelectionIDs removes the "field_selections" edge to IncidentFieldOption entities by IDs.
func (iuo *IncidentUpdateOne) RemoveFieldSelectionIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveFieldSelectionIDs(ids...)
	return iuo
}

// RemoveFieldSelections removes "field_selections" edges to IncidentFieldOption entities.
func (iuo *IncidentUpdateOne) RemoveFieldSelections(i ...*IncidentFieldOption) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveFieldSelectionIDs(ids...)
}

// ClearTasks clears all "tasks" edges to the Task entity.
func (iuo *IncidentUpdateOne) ClearTasks() *IncidentUpdateOne {
	iuo.mutation.ClearTasks()
	return iuo
}

// RemoveTaskIDs removes the "tasks" edge to Task entities by IDs.
func (iuo *IncidentUpdateOne) RemoveTaskIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveTaskIDs(ids...)
	return iuo
}

// RemoveTasks removes "tasks" edges to Task entities.
func (iuo *IncidentUpdateOne) RemoveTasks(t ...*Task) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return iuo.RemoveTaskIDs(ids...)
}

// ClearTagAssignments clears all "tag_assignments" edges to the IncidentTag entity.
func (iuo *IncidentUpdateOne) ClearTagAssignments() *IncidentUpdateOne {
	iuo.mutation.ClearTagAssignments()
	return iuo
}

// RemoveTagAssignmentIDs removes the "tag_assignments" edge to IncidentTag entities by IDs.
func (iuo *IncidentUpdateOne) RemoveTagAssignmentIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveTagAssignmentIDs(ids...)
	return iuo
}

// RemoveTagAssignments removes "tag_assignments" edges to IncidentTag entities.
func (iuo *IncidentUpdateOne) RemoveTagAssignments(i ...*IncidentTag) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveTagAssignmentIDs(ids...)
}

// ClearDebriefs clears all "debriefs" edges to the IncidentDebrief entity.
func (iuo *IncidentUpdateOne) ClearDebriefs() *IncidentUpdateOne {
	iuo.mutation.ClearDebriefs()
	return iuo
}

// RemoveDebriefIDs removes the "debriefs" edge to IncidentDebrief entities by IDs.
func (iuo *IncidentUpdateOne) RemoveDebriefIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveDebriefIDs(ids...)
	return iuo
}

// RemoveDebriefs removes "debriefs" edges to IncidentDebrief entities.
func (iuo *IncidentUpdateOne) RemoveDebriefs(i ...*IncidentDebrief) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveDebriefIDs(ids...)
}

// ClearReviewSessions clears all "review_sessions" edges to the MeetingSession entity.
func (iuo *IncidentUpdateOne) ClearReviewSessions() *IncidentUpdateOne {
	iuo.mutation.ClearReviewSessions()
	return iuo
}

// RemoveReviewSessionIDs removes the "review_sessions" edge to MeetingSession entities by IDs.
func (iuo *IncidentUpdateOne) RemoveReviewSessionIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveReviewSessionIDs(ids...)
	return iuo
}

// RemoveReviewSessions removes "review_sessions" edges to MeetingSession entities.
func (iuo *IncidentUpdateOne) RemoveReviewSessions(m ...*MeetingSession) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return iuo.RemoveReviewSessionIDs(ids...)
}

// ClearUserRoles clears all "user_roles" edges to the IncidentRoleAssignment entity.
func (iuo *IncidentUpdateOne) ClearUserRoles() *IncidentUpdateOne {
	iuo.mutation.ClearUserRoles()
	return iuo
}

// RemoveUserRoleIDs removes the "user_roles" edge to IncidentRoleAssignment entities by IDs.
func (iuo *IncidentUpdateOne) RemoveUserRoleIDs(ids ...uuid.UUID) *IncidentUpdateOne {
	iuo.mutation.RemoveUserRoleIDs(ids...)
	return iuo
}

// RemoveUserRoles removes "user_roles" edges to IncidentRoleAssignment entities.
func (iuo *IncidentUpdateOne) RemoveUserRoles(i ...*IncidentRoleAssignment) *IncidentUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveUserRoleIDs(ids...)
}

// ClearIncidentLinks clears all "incident_links" edges to the IncidentLink entity.
func (iuo *IncidentUpdateOne) ClearIncidentLinks() *IncidentUpdateOne {
	iuo.mutation.ClearIncidentLinks()
	return iuo
}

// RemoveIncidentLinkIDs removes the "incident_links" edge to IncidentLink entities by IDs.
func (iuo *IncidentUpdateOne) RemoveIncidentLinkIDs(ids ...int) *IncidentUpdateOne {
	iuo.mutation.RemoveIncidentLinkIDs(ids...)
	return iuo
}

// RemoveIncidentLinks removes "incident_links" edges to IncidentLink entities.
func (iuo *IncidentUpdateOne) RemoveIncidentLinks(i ...*IncidentLink) *IncidentUpdateOne {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveIncidentLinkIDs(ids...)
}

// Where appends a list predicates to the IncidentUpdate builder.
func (iuo *IncidentUpdateOne) Where(ps ...predicate.Incident) *IncidentUpdateOne {
	iuo.mutation.Where(ps...)
	return iuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (iuo *IncidentUpdateOne) Select(field string, fields ...string) *IncidentUpdateOne {
	iuo.fields = append([]string{field}, fields...)
	return iuo
}

// Save executes the query and returns the updated Incident entity.
func (iuo *IncidentUpdateOne) Save(ctx context.Context) (*Incident, error) {
	return withHooks(ctx, iuo.sqlSave, iuo.mutation, iuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (iuo *IncidentUpdateOne) SaveX(ctx context.Context) *Incident {
	node, err := iuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (iuo *IncidentUpdateOne) Exec(ctx context.Context) error {
	_, err := iuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iuo *IncidentUpdateOne) ExecX(ctx context.Context) {
	if err := iuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (iuo *IncidentUpdateOne) check() error {
	if iuo.mutation.TenantCleared() && len(iuo.mutation.TenantIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Incident.tenant"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (iuo *IncidentUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *IncidentUpdateOne {
	iuo.modifiers = append(iuo.modifiers, modifiers...)
	return iuo
}

func (iuo *IncidentUpdateOne) sqlSave(ctx context.Context) (_node *Incident, err error) {
	if err := iuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(incident.Table, incident.Columns, sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID))
	id, ok := iuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Incident.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := iuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, incident.FieldID)
		for _, f := range fields {
			if !incident.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != incident.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := iuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := iuo.mutation.Slug(); ok {
		_spec.SetField(incident.FieldSlug, field.TypeString, value)
	}
	if value, ok := iuo.mutation.Title(); ok {
		_spec.SetField(incident.FieldTitle, field.TypeString, value)
	}
	if value, ok := iuo.mutation.Private(); ok {
		_spec.SetField(incident.FieldPrivate, field.TypeBool, value)
	}
	if value, ok := iuo.mutation.Summary(); ok {
		_spec.SetField(incident.FieldSummary, field.TypeString, value)
	}
	if iuo.mutation.SummaryCleared() {
		_spec.ClearField(incident.FieldSummary, field.TypeString)
	}
	if value, ok := iuo.mutation.OpenedAt(); ok {
		_spec.SetField(incident.FieldOpenedAt, field.TypeTime, value)
	}
	if value, ok := iuo.mutation.ModifiedAt(); ok {
		_spec.SetField(incident.FieldModifiedAt, field.TypeTime, value)
	}
	if iuo.mutation.ModifiedAtCleared() {
		_spec.ClearField(incident.FieldModifiedAt, field.TypeTime)
	}
	if value, ok := iuo.mutation.ClosedAt(); ok {
		_spec.SetField(incident.FieldClosedAt, field.TypeTime, value)
	}
	if iuo.mutation.ClosedAtCleared() {
		_spec.ClearField(incident.FieldClosedAt, field.TypeTime)
	}
	if value, ok := iuo.mutation.ProviderID(); ok {
		_spec.SetField(incident.FieldProviderID, field.TypeString, value)
	}
	if iuo.mutation.ProviderIDCleared() {
		_spec.ClearField(incident.FieldProviderID, field.TypeString)
	}
	if value, ok := iuo.mutation.ChatChannelID(); ok {
		_spec.SetField(incident.FieldChatChannelID, field.TypeString, value)
	}
	if iuo.mutation.ChatChannelIDCleared() {
		_spec.ClearField(incident.FieldChatChannelID, field.TypeString)
	}
	if iuo.mutation.SeverityCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.SeverityTable,
			Columns: []string{incident.SeverityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentseverity.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.SeverityIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.SeverityTable,
			Columns: []string{incident.SeverityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentseverity.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.TypeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.TypeTable,
			Columns: []string{incident.TypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttype.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.TypeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   incident.TypeTable,
			Columns: []string{incident.TypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttype.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.MilestonesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.MilestonesTable,
			Columns: []string{incident.MilestonesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentmilestone.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedMilestonesIDs(); len(nodes) > 0 && !iuo.mutation.MilestonesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.MilestonesTable,
			Columns: []string{incident.MilestonesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentmilestone.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.MilestonesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.MilestonesTable,
			Columns: []string{incident.MilestonesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentmilestone.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.EventsTable,
			Columns: []string{incident.EventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentevent.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedEventsIDs(); len(nodes) > 0 && !iuo.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.EventsTable,
			Columns: []string{incident.EventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentevent.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.EventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.EventsTable,
			Columns: []string{incident.EventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentevent.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.RetrospectiveCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   incident.RetrospectiveTable,
			Columns: []string{incident.RetrospectiveColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(retrospective.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RetrospectiveIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   incident.RetrospectiveTable,
			Columns: []string{incident.RetrospectiveColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(retrospective.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   incident.UsersTable,
			Columns: incident.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		createE := &IncidentRoleAssignmentCreate{config: iuo.config, mutation: newIncidentRoleAssignmentMutation(iuo.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		if specE.ID.Value != nil {
			edge.Target.Fields = append(edge.Target.Fields, specE.ID)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedUsersIDs(); len(nodes) > 0 && !iuo.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   incident.UsersTable,
			Columns: incident.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &IncidentRoleAssignmentCreate{config: iuo.config, mutation: newIncidentRoleAssignmentMutation(iuo.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		if specE.ID.Value != nil {
			edge.Target.Fields = append(edge.Target.Fields, specE.ID)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   incident.UsersTable,
			Columns: incident.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &IncidentRoleAssignmentCreate{config: iuo.config, mutation: newIncidentRoleAssignmentMutation(iuo.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		if specE.ID.Value != nil {
			edge.Target.Fields = append(edge.Target.Fields, specE.ID)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.RoleAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.RoleAssignmentsTable,
			Columns: []string{incident.RoleAssignmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedRoleAssignmentsIDs(); len(nodes) > 0 && !iuo.mutation.RoleAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.RoleAssignmentsTable,
			Columns: []string{incident.RoleAssignmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RoleAssignmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.RoleAssignmentsTable,
			Columns: []string{incident.RoleAssignmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.LinkedIncidentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.LinkedIncidentsTable,
			Columns: incident.LinkedIncidentsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedLinkedIncidentsIDs(); len(nodes) > 0 && !iuo.mutation.LinkedIncidentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.LinkedIncidentsTable,
			Columns: incident.LinkedIncidentsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.LinkedIncidentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.LinkedIncidentsTable,
			Columns: incident.LinkedIncidentsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incident.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.FieldSelectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.FieldSelectionsTable,
			Columns: incident.FieldSelectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentfieldoption.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedFieldSelectionsIDs(); len(nodes) > 0 && !iuo.mutation.FieldSelectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.FieldSelectionsTable,
			Columns: incident.FieldSelectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentfieldoption.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.FieldSelectionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.FieldSelectionsTable,
			Columns: incident.FieldSelectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentfieldoption.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.TasksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.TasksTable,
			Columns: []string{incident.TasksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedTasksIDs(); len(nodes) > 0 && !iuo.mutation.TasksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.TasksTable,
			Columns: []string{incident.TasksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.TasksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.TasksTable,
			Columns: []string{incident.TasksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.TagAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.TagAssignmentsTable,
			Columns: incident.TagAssignmentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttag.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedTagAssignmentsIDs(); len(nodes) > 0 && !iuo.mutation.TagAssignmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.TagAssignmentsTable,
			Columns: incident.TagAssignmentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttag.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.TagAssignmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.TagAssignmentsTable,
			Columns: incident.TagAssignmentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidenttag.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.DebriefsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.DebriefsTable,
			Columns: []string{incident.DebriefsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentdebrief.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedDebriefsIDs(); len(nodes) > 0 && !iuo.mutation.DebriefsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.DebriefsTable,
			Columns: []string{incident.DebriefsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentdebrief.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.DebriefsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   incident.DebriefsTable,
			Columns: []string{incident.DebriefsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentdebrief.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.ReviewSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.ReviewSessionsTable,
			Columns: incident.ReviewSessionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(meetingsession.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedReviewSessionsIDs(); len(nodes) > 0 && !iuo.mutation.ReviewSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.ReviewSessionsTable,
			Columns: incident.ReviewSessionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(meetingsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.ReviewSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   incident.ReviewSessionsTable,
			Columns: incident.ReviewSessionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(meetingsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.UserRolesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.UserRolesTable,
			Columns: []string{incident.UserRolesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedUserRolesIDs(); len(nodes) > 0 && !iuo.mutation.UserRolesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.UserRolesTable,
			Columns: []string{incident.UserRolesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.UserRolesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.UserRolesTable,
			Columns: []string{incident.UserRolesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentroleassignment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.IncidentLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.IncidentLinksTable,
			Columns: []string{incident.IncidentLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentlink.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedIncidentLinksIDs(); len(nodes) > 0 && !iuo.mutation.IncidentLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.IncidentLinksTable,
			Columns: []string{incident.IncidentLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentlink.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.IncidentLinksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   incident.IncidentLinksTable,
			Columns: []string{incident.IncidentLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(incidentlink.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.AddModifiers(iuo.modifiers...)
	_node = &Incident{config: iuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, iuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{incident.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	iuo.mutation.done = true
	return _node, nil
}
