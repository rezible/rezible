// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/rezible/rezible/ent/alert"
	"github.com/rezible/rezible/ent/alertfeedback"
	"github.com/rezible/rezible/ent/alertinstance"
	"github.com/rezible/rezible/ent/document"
	"github.com/rezible/rezible/ent/event"
	"github.com/rezible/rezible/ent/eventannotation"
	"github.com/rezible/rezible/ent/incident"
	"github.com/rezible/rezible/ent/incidentdebrief"
	"github.com/rezible/rezible/ent/incidentdebriefmessage"
	"github.com/rezible/rezible/ent/incidentdebriefquestion"
	"github.com/rezible/rezible/ent/incidentdebriefsuggestion"
	"github.com/rezible/rezible/ent/incidentevent"
	"github.com/rezible/rezible/ent/incidenteventcontext"
	"github.com/rezible/rezible/ent/incidenteventcontributingfactor"
	"github.com/rezible/rezible/ent/incidenteventevidence"
	"github.com/rezible/rezible/ent/incidenteventsystemcomponent"
	"github.com/rezible/rezible/ent/incidentfield"
	"github.com/rezible/rezible/ent/incidentfieldoption"
	"github.com/rezible/rezible/ent/incidentlink"
	"github.com/rezible/rezible/ent/incidentmilestone"
	"github.com/rezible/rezible/ent/incidentrole"
	"github.com/rezible/rezible/ent/incidentroleassignment"
	"github.com/rezible/rezible/ent/incidentseverity"
	"github.com/rezible/rezible/ent/incidenttag"
	"github.com/rezible/rezible/ent/incidenttype"
	"github.com/rezible/rezible/ent/integration"
	"github.com/rezible/rezible/ent/meetingschedule"
	"github.com/rezible/rezible/ent/meetingsession"
	"github.com/rezible/rezible/ent/oncallhandovertemplate"
	"github.com/rezible/rezible/ent/oncallroster"
	"github.com/rezible/rezible/ent/oncallrostermetrics"
	"github.com/rezible/rezible/ent/oncallschedule"
	"github.com/rezible/rezible/ent/oncallscheduleparticipant"
	"github.com/rezible/rezible/ent/oncallshift"
	"github.com/rezible/rezible/ent/oncallshifthandover"
	"github.com/rezible/rezible/ent/oncallshiftmetrics"
	"github.com/rezible/rezible/ent/organization"
	"github.com/rezible/rezible/ent/playbook"
	"github.com/rezible/rezible/ent/predicate"
	"github.com/rezible/rezible/ent/providersynchistory"
	"github.com/rezible/rezible/ent/retrospective"
	"github.com/rezible/rezible/ent/retrospectivecomment"
	"github.com/rezible/rezible/ent/retrospectivereview"
	"github.com/rezible/rezible/ent/systemanalysis"
	"github.com/rezible/rezible/ent/systemanalysiscomponent"
	"github.com/rezible/rezible/ent/systemanalysisrelationship"
	"github.com/rezible/rezible/ent/systemcomponent"
	"github.com/rezible/rezible/ent/systemcomponentconstraint"
	"github.com/rezible/rezible/ent/systemcomponentcontrol"
	"github.com/rezible/rezible/ent/systemcomponentkind"
	"github.com/rezible/rezible/ent/systemcomponentrelationship"
	"github.com/rezible/rezible/ent/systemcomponentsignal"
	"github.com/rezible/rezible/ent/systemhazard"
	"github.com/rezible/rezible/ent/systemrelationshipcontrolaction"
	"github.com/rezible/rezible/ent/systemrelationshipfeedbacksignal"
	"github.com/rezible/rezible/ent/task"
	"github.com/rezible/rezible/ent/team"
	"github.com/rezible/rezible/ent/ticket"
	"github.com/rezible/rezible/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlert                            = "Alert"
	TypeAlertFeedback                    = "AlertFeedback"
	TypeAlertInstance                    = "AlertInstance"
	TypeAlertMetrics                     = "AlertMetrics"
	TypeDocument                         = "Document"
	TypeEvent                            = "Event"
	TypeEventAnnotation                  = "EventAnnotation"
	TypeIncident                         = "Incident"
	TypeIncidentDebrief                  = "IncidentDebrief"
	TypeIncidentDebriefMessage           = "IncidentDebriefMessage"
	TypeIncidentDebriefQuestion          = "IncidentDebriefQuestion"
	TypeIncidentDebriefSuggestion        = "IncidentDebriefSuggestion"
	TypeIncidentEvent                    = "IncidentEvent"
	TypeIncidentEventContext             = "IncidentEventContext"
	TypeIncidentEventContributingFactor  = "IncidentEventContributingFactor"
	TypeIncidentEventEvidence            = "IncidentEventEvidence"
	TypeIncidentEventSystemComponent     = "IncidentEventSystemComponent"
	TypeIncidentField                    = "IncidentField"
	TypeIncidentFieldOption              = "IncidentFieldOption"
	TypeIncidentLink                     = "IncidentLink"
	TypeIncidentMilestone                = "IncidentMilestone"
	TypeIncidentRole                     = "IncidentRole"
	TypeIncidentRoleAssignment           = "IncidentRoleAssignment"
	TypeIncidentSeverity                 = "IncidentSeverity"
	TypeIncidentTag                      = "IncidentTag"
	TypeIncidentType                     = "IncidentType"
	TypeIntegration                      = "Integration"
	TypeMeetingSchedule                  = "MeetingSchedule"
	TypeMeetingSession                   = "MeetingSession"
	TypeOncallHandoverTemplate           = "OncallHandoverTemplate"
	TypeOncallRoster                     = "OncallRoster"
	TypeOncallRosterMetrics              = "OncallRosterMetrics"
	TypeOncallSchedule                   = "OncallSchedule"
	TypeOncallScheduleParticipant        = "OncallScheduleParticipant"
	TypeOncallShift                      = "OncallShift"
	TypeOncallShiftHandover              = "OncallShiftHandover"
	TypeOncallShiftMetrics               = "OncallShiftMetrics"
	TypeOrganization                     = "Organization"
	TypePlaybook                         = "Playbook"
	TypeProviderSyncHistory              = "ProviderSyncHistory"
	TypeRetrospective                    = "Retrospective"
	TypeRetrospectiveComment             = "RetrospectiveComment"
	TypeRetrospectiveReview              = "RetrospectiveReview"
	TypeSystemAnalysis                   = "SystemAnalysis"
	TypeSystemAnalysisComponent          = "SystemAnalysisComponent"
	TypeSystemAnalysisRelationship       = "SystemAnalysisRelationship"
	TypeSystemComponent                  = "SystemComponent"
	TypeSystemComponentConstraint        = "SystemComponentConstraint"
	TypeSystemComponentControl           = "SystemComponentControl"
	TypeSystemComponentKind              = "SystemComponentKind"
	TypeSystemComponentRelationship      = "SystemComponentRelationship"
	TypeSystemComponentSignal            = "SystemComponentSignal"
	TypeSystemHazard                     = "SystemHazard"
	TypeSystemRelationshipControlAction  = "SystemRelationshipControlAction"
	TypeSystemRelationshipFeedbackSignal = "SystemRelationshipFeedbackSignal"
	TypeTask                             = "Task"
	TypeTeam                             = "Team"
	TypeTenant                           = "Tenant"
	TypeTicket                           = "Ticket"
	TypeUser                             = "User"
)

// AlertMutation represents an operation that mutates the Alert nodes in the graph.
type AlertMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	external_id      *string
	title            *string
	description      *string
	definition       *string
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	playbooks        map[uuid.UUID]struct{}
	removedplaybooks map[uuid.UUID]struct{}
	clearedplaybooks bool
	roster           *uuid.UUID
	clearedroster    bool
	instances        map[uuid.UUID]struct{}
	removedinstances map[uuid.UUID]struct{}
	clearedinstances bool
	done             bool
	oldValue         func(context.Context) (*Alert, error)
	predicates       []predicate.Alert
}

var _ ent.Mutation = (*AlertMutation)(nil)

// alertOption allows management of the mutation configuration using functional options.
type alertOption func(*AlertMutation)

// newAlertMutation creates new mutation for the Alert entity.
func newAlertMutation(c config, op Op, opts ...alertOption) *AlertMutation {
	m := &AlertMutation{
		config:        c,
		op:            op,
		typ:           TypeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertID sets the ID field of the mutation.
func withAlertID(id uuid.UUID) alertOption {
	return func(m *AlertMutation) {
		var (
			err   error
			once  sync.Once
			value *Alert
		)
		m.oldValue = func(ctx context.Context) (*Alert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlert sets the old Alert of the mutation.
func withAlert(node *Alert) alertOption {
	return func(m *AlertMutation) {
		m.oldValue = func(context.Context) (*Alert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Alert entities.
func (m *AlertMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *AlertMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AlertMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AlertMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *AlertMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *AlertMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *AlertMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[alert.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *AlertMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[alert.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *AlertMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, alert.FieldExternalID)
}

// SetTitle sets the "title" field.
func (m *AlertMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlertMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AlertMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *AlertMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlertMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlertMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[alert.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlertMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[alert.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlertMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, alert.FieldDescription)
}

// SetDefinition sets the "definition" field.
func (m *AlertMutation) SetDefinition(s string) {
	m.definition = &s
}

// Definition returns the value of the "definition" field in the mutation.
func (m *AlertMutation) Definition() (r string, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinition returns the old "definition" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldDefinition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinition: %w", err)
	}
	return oldValue.Definition, nil
}

// ClearDefinition clears the value of the "definition" field.
func (m *AlertMutation) ClearDefinition() {
	m.definition = nil
	m.clearedFields[alert.FieldDefinition] = struct{}{}
}

// DefinitionCleared returns if the "definition" field was cleared in this mutation.
func (m *AlertMutation) DefinitionCleared() bool {
	_, ok := m.clearedFields[alert.FieldDefinition]
	return ok
}

// ResetDefinition resets all changes to the "definition" field.
func (m *AlertMutation) ResetDefinition() {
	m.definition = nil
	delete(m.clearedFields, alert.FieldDefinition)
}

// SetRosterID sets the "roster_id" field.
func (m *AlertMutation) SetRosterID(u uuid.UUID) {
	m.roster = &u
}

// RosterID returns the value of the "roster_id" field in the mutation.
func (m *AlertMutation) RosterID() (r uuid.UUID, exists bool) {
	v := m.roster
	if v == nil {
		return
	}
	return *v, true
}

// OldRosterID returns the old "roster_id" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldRosterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosterID: %w", err)
	}
	return oldValue.RosterID, nil
}

// ClearRosterID clears the value of the "roster_id" field.
func (m *AlertMutation) ClearRosterID() {
	m.roster = nil
	m.clearedFields[alert.FieldRosterID] = struct{}{}
}

// RosterIDCleared returns if the "roster_id" field was cleared in this mutation.
func (m *AlertMutation) RosterIDCleared() bool {
	_, ok := m.clearedFields[alert.FieldRosterID]
	return ok
}

// ResetRosterID resets all changes to the "roster_id" field.
func (m *AlertMutation) ResetRosterID() {
	m.roster = nil
	delete(m.clearedFields, alert.FieldRosterID)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AlertMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[alert.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AlertMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AlertMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AlertMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddPlaybookIDs adds the "playbooks" edge to the Playbook entity by ids.
func (m *AlertMutation) AddPlaybookIDs(ids ...uuid.UUID) {
	if m.playbooks == nil {
		m.playbooks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.playbooks[ids[i]] = struct{}{}
	}
}

// ClearPlaybooks clears the "playbooks" edge to the Playbook entity.
func (m *AlertMutation) ClearPlaybooks() {
	m.clearedplaybooks = true
}

// PlaybooksCleared reports if the "playbooks" edge to the Playbook entity was cleared.
func (m *AlertMutation) PlaybooksCleared() bool {
	return m.clearedplaybooks
}

// RemovePlaybookIDs removes the "playbooks" edge to the Playbook entity by IDs.
func (m *AlertMutation) RemovePlaybookIDs(ids ...uuid.UUID) {
	if m.removedplaybooks == nil {
		m.removedplaybooks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.playbooks, ids[i])
		m.removedplaybooks[ids[i]] = struct{}{}
	}
}

// RemovedPlaybooks returns the removed IDs of the "playbooks" edge to the Playbook entity.
func (m *AlertMutation) RemovedPlaybooksIDs() (ids []uuid.UUID) {
	for id := range m.removedplaybooks {
		ids = append(ids, id)
	}
	return
}

// PlaybooksIDs returns the "playbooks" edge IDs in the mutation.
func (m *AlertMutation) PlaybooksIDs() (ids []uuid.UUID) {
	for id := range m.playbooks {
		ids = append(ids, id)
	}
	return
}

// ResetPlaybooks resets all changes to the "playbooks" edge.
func (m *AlertMutation) ResetPlaybooks() {
	m.playbooks = nil
	m.clearedplaybooks = false
	m.removedplaybooks = nil
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *AlertMutation) ClearRoster() {
	m.clearedroster = true
	m.clearedFields[alert.FieldRosterID] = struct{}{}
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *AlertMutation) RosterCleared() bool {
	return m.RosterIDCleared() || m.clearedroster
}

// RosterIDs returns the "roster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RosterID instead. It exists only for internal usage by the builders.
func (m *AlertMutation) RosterIDs() (ids []uuid.UUID) {
	if id := m.roster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *AlertMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
}

// AddInstanceIDs adds the "instances" edge to the AlertInstance entity by ids.
func (m *AlertMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the AlertInstance entity.
func (m *AlertMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the AlertInstance entity was cleared.
func (m *AlertMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the AlertInstance entity by IDs.
func (m *AlertMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the AlertInstance entity.
func (m *AlertMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *AlertMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *AlertMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the AlertMutation builder.
func (m *AlertMutation) Where(ps ...predicate.Alert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alert).
func (m *AlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, alert.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, alert.FieldExternalID)
	}
	if m.title != nil {
		fields = append(fields, alert.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, alert.FieldDescription)
	}
	if m.definition != nil {
		fields = append(fields, alert.FieldDefinition)
	}
	if m.roster != nil {
		fields = append(fields, alert.FieldRosterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldTenantID:
		return m.TenantID()
	case alert.FieldExternalID:
		return m.ExternalID()
	case alert.FieldTitle:
		return m.Title()
	case alert.FieldDescription:
		return m.Description()
	case alert.FieldDefinition:
		return m.Definition()
	case alert.FieldRosterID:
		return m.RosterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alert.FieldTenantID:
		return m.OldTenantID(ctx)
	case alert.FieldExternalID:
		return m.OldExternalID(ctx)
	case alert.FieldTitle:
		return m.OldTitle(ctx)
	case alert.FieldDescription:
		return m.OldDescription(ctx)
	case alert.FieldDefinition:
		return m.OldDefinition(ctx)
	case alert.FieldRosterID:
		return m.OldRosterID(ctx)
	}
	return nil, fmt.Errorf("unknown Alert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alert.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case alert.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case alert.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case alert.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case alert.FieldDefinition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinition(v)
		return nil
	case alert.FieldRosterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosterID(v)
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Alert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alert.FieldExternalID) {
		fields = append(fields, alert.FieldExternalID)
	}
	if m.FieldCleared(alert.FieldDescription) {
		fields = append(fields, alert.FieldDescription)
	}
	if m.FieldCleared(alert.FieldDefinition) {
		fields = append(fields, alert.FieldDefinition)
	}
	if m.FieldCleared(alert.FieldRosterID) {
		fields = append(fields, alert.FieldRosterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertMutation) ClearField(name string) error {
	switch name {
	case alert.FieldExternalID:
		m.ClearExternalID()
		return nil
	case alert.FieldDescription:
		m.ClearDescription()
		return nil
	case alert.FieldDefinition:
		m.ClearDefinition()
		return nil
	case alert.FieldRosterID:
		m.ClearRosterID()
		return nil
	}
	return fmt.Errorf("unknown Alert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertMutation) ResetField(name string) error {
	switch name {
	case alert.FieldTenantID:
		m.ResetTenantID()
		return nil
	case alert.FieldExternalID:
		m.ResetExternalID()
		return nil
	case alert.FieldTitle:
		m.ResetTitle()
		return nil
	case alert.FieldDescription:
		m.ResetDescription()
		return nil
	case alert.FieldDefinition:
		m.ResetDefinition()
		return nil
	case alert.FieldRosterID:
		m.ResetRosterID()
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, alert.EdgeTenant)
	}
	if m.playbooks != nil {
		edges = append(edges, alert.EdgePlaybooks)
	}
	if m.roster != nil {
		edges = append(edges, alert.EdgeRoster)
	}
	if m.instances != nil {
		edges = append(edges, alert.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case alert.EdgePlaybooks:
		ids := make([]ent.Value, 0, len(m.playbooks))
		for id := range m.playbooks {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeRoster:
		if id := m.roster; id != nil {
			return []ent.Value{*id}
		}
	case alert.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedplaybooks != nil {
		edges = append(edges, alert.EdgePlaybooks)
	}
	if m.removedinstances != nil {
		edges = append(edges, alert.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgePlaybooks:
		ids := make([]ent.Value, 0, len(m.removedplaybooks))
		for id := range m.removedplaybooks {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, alert.EdgeTenant)
	}
	if m.clearedplaybooks {
		edges = append(edges, alert.EdgePlaybooks)
	}
	if m.clearedroster {
		edges = append(edges, alert.EdgeRoster)
	}
	if m.clearedinstances {
		edges = append(edges, alert.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertMutation) EdgeCleared(name string) bool {
	switch name {
	case alert.EdgeTenant:
		return m.clearedtenant
	case alert.EdgePlaybooks:
		return m.clearedplaybooks
	case alert.EdgeRoster:
		return m.clearedroster
	case alert.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertMutation) ClearEdge(name string) error {
	switch name {
	case alert.EdgeTenant:
		m.ClearTenant()
		return nil
	case alert.EdgeRoster:
		m.ClearRoster()
		return nil
	}
	return fmt.Errorf("unknown Alert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertMutation) ResetEdge(name string) error {
	switch name {
	case alert.EdgeTenant:
		m.ResetTenant()
		return nil
	case alert.EdgePlaybooks:
		m.ResetPlaybooks()
		return nil
	case alert.EdgeRoster:
		m.ResetRoster()
		return nil
	case alert.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown Alert edge %s", name)
}

// AlertFeedbackMutation represents an operation that mutates the AlertFeedback nodes in the graph.
type AlertFeedbackMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	actionable                 *bool
	accurate                   *alertfeedback.Accurate
	documentation_available    *bool
	documentation_needs_update *bool
	clearedFields              map[string]struct{}
	tenant                     *int
	clearedtenant              bool
	alert_instance             *uuid.UUID
	clearedalert_instance      bool
	done                       bool
	oldValue                   func(context.Context) (*AlertFeedback, error)
	predicates                 []predicate.AlertFeedback
}

var _ ent.Mutation = (*AlertFeedbackMutation)(nil)

// alertfeedbackOption allows management of the mutation configuration using functional options.
type alertfeedbackOption func(*AlertFeedbackMutation)

// newAlertFeedbackMutation creates new mutation for the AlertFeedback entity.
func newAlertFeedbackMutation(c config, op Op, opts ...alertfeedbackOption) *AlertFeedbackMutation {
	m := &AlertFeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertFeedbackID sets the ID field of the mutation.
func withAlertFeedbackID(id uuid.UUID) alertfeedbackOption {
	return func(m *AlertFeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertFeedback
		)
		m.oldValue = func(ctx context.Context) (*AlertFeedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertFeedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertFeedback sets the old AlertFeedback of the mutation.
func withAlertFeedback(node *AlertFeedback) alertfeedbackOption {
	return func(m *AlertFeedbackMutation) {
		m.oldValue = func(context.Context) (*AlertFeedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertFeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertFeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertFeedback entities.
func (m *AlertFeedbackMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertFeedbackMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertFeedbackMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertFeedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *AlertFeedbackMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AlertFeedbackMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AlertFeedback entity.
// If the AlertFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertFeedbackMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AlertFeedbackMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAlertInstanceID sets the "alert_instance_id" field.
func (m *AlertFeedbackMutation) SetAlertInstanceID(u uuid.UUID) {
	m.alert_instance = &u
}

// AlertInstanceID returns the value of the "alert_instance_id" field in the mutation.
func (m *AlertFeedbackMutation) AlertInstanceID() (r uuid.UUID, exists bool) {
	v := m.alert_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertInstanceID returns the old "alert_instance_id" field's value of the AlertFeedback entity.
// If the AlertFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertFeedbackMutation) OldAlertInstanceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertInstanceID: %w", err)
	}
	return oldValue.AlertInstanceID, nil
}

// ResetAlertInstanceID resets all changes to the "alert_instance_id" field.
func (m *AlertFeedbackMutation) ResetAlertInstanceID() {
	m.alert_instance = nil
}

// SetActionable sets the "actionable" field.
func (m *AlertFeedbackMutation) SetActionable(b bool) {
	m.actionable = &b
}

// Actionable returns the value of the "actionable" field in the mutation.
func (m *AlertFeedbackMutation) Actionable() (r bool, exists bool) {
	v := m.actionable
	if v == nil {
		return
	}
	return *v, true
}

// OldActionable returns the old "actionable" field's value of the AlertFeedback entity.
// If the AlertFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertFeedbackMutation) OldActionable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionable: %w", err)
	}
	return oldValue.Actionable, nil
}

// ResetActionable resets all changes to the "actionable" field.
func (m *AlertFeedbackMutation) ResetActionable() {
	m.actionable = nil
}

// SetAccurate sets the "accurate" field.
func (m *AlertFeedbackMutation) SetAccurate(a alertfeedback.Accurate) {
	m.accurate = &a
}

// Accurate returns the value of the "accurate" field in the mutation.
func (m *AlertFeedbackMutation) Accurate() (r alertfeedback.Accurate, exists bool) {
	v := m.accurate
	if v == nil {
		return
	}
	return *v, true
}

// OldAccurate returns the old "accurate" field's value of the AlertFeedback entity.
// If the AlertFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertFeedbackMutation) OldAccurate(ctx context.Context) (v alertfeedback.Accurate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccurate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccurate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccurate: %w", err)
	}
	return oldValue.Accurate, nil
}

// ResetAccurate resets all changes to the "accurate" field.
func (m *AlertFeedbackMutation) ResetAccurate() {
	m.accurate = nil
}

// SetDocumentationAvailable sets the "documentation_available" field.
func (m *AlertFeedbackMutation) SetDocumentationAvailable(b bool) {
	m.documentation_available = &b
}

// DocumentationAvailable returns the value of the "documentation_available" field in the mutation.
func (m *AlertFeedbackMutation) DocumentationAvailable() (r bool, exists bool) {
	v := m.documentation_available
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentationAvailable returns the old "documentation_available" field's value of the AlertFeedback entity.
// If the AlertFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertFeedbackMutation) OldDocumentationAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentationAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentationAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentationAvailable: %w", err)
	}
	return oldValue.DocumentationAvailable, nil
}

// ResetDocumentationAvailable resets all changes to the "documentation_available" field.
func (m *AlertFeedbackMutation) ResetDocumentationAvailable() {
	m.documentation_available = nil
}

// SetDocumentationNeedsUpdate sets the "documentation_needs_update" field.
func (m *AlertFeedbackMutation) SetDocumentationNeedsUpdate(b bool) {
	m.documentation_needs_update = &b
}

// DocumentationNeedsUpdate returns the value of the "documentation_needs_update" field in the mutation.
func (m *AlertFeedbackMutation) DocumentationNeedsUpdate() (r bool, exists bool) {
	v := m.documentation_needs_update
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentationNeedsUpdate returns the old "documentation_needs_update" field's value of the AlertFeedback entity.
// If the AlertFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertFeedbackMutation) OldDocumentationNeedsUpdate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentationNeedsUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentationNeedsUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentationNeedsUpdate: %w", err)
	}
	return oldValue.DocumentationNeedsUpdate, nil
}

// ResetDocumentationNeedsUpdate resets all changes to the "documentation_needs_update" field.
func (m *AlertFeedbackMutation) ResetDocumentationNeedsUpdate() {
	m.documentation_needs_update = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AlertFeedbackMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[alertfeedback.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AlertFeedbackMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AlertFeedbackMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AlertFeedbackMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearAlertInstance clears the "alert_instance" edge to the AlertInstance entity.
func (m *AlertFeedbackMutation) ClearAlertInstance() {
	m.clearedalert_instance = true
	m.clearedFields[alertfeedback.FieldAlertInstanceID] = struct{}{}
}

// AlertInstanceCleared reports if the "alert_instance" edge to the AlertInstance entity was cleared.
func (m *AlertFeedbackMutation) AlertInstanceCleared() bool {
	return m.clearedalert_instance
}

// AlertInstanceIDs returns the "alert_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertInstanceID instead. It exists only for internal usage by the builders.
func (m *AlertFeedbackMutation) AlertInstanceIDs() (ids []uuid.UUID) {
	if id := m.alert_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlertInstance resets all changes to the "alert_instance" edge.
func (m *AlertFeedbackMutation) ResetAlertInstance() {
	m.alert_instance = nil
	m.clearedalert_instance = false
}

// Where appends a list predicates to the AlertFeedbackMutation builder.
func (m *AlertFeedbackMutation) Where(ps ...predicate.AlertFeedback) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertFeedbackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertFeedbackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertFeedback, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertFeedbackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertFeedbackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertFeedback).
func (m *AlertFeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertFeedbackMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, alertfeedback.FieldTenantID)
	}
	if m.alert_instance != nil {
		fields = append(fields, alertfeedback.FieldAlertInstanceID)
	}
	if m.actionable != nil {
		fields = append(fields, alertfeedback.FieldActionable)
	}
	if m.accurate != nil {
		fields = append(fields, alertfeedback.FieldAccurate)
	}
	if m.documentation_available != nil {
		fields = append(fields, alertfeedback.FieldDocumentationAvailable)
	}
	if m.documentation_needs_update != nil {
		fields = append(fields, alertfeedback.FieldDocumentationNeedsUpdate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertFeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertfeedback.FieldTenantID:
		return m.TenantID()
	case alertfeedback.FieldAlertInstanceID:
		return m.AlertInstanceID()
	case alertfeedback.FieldActionable:
		return m.Actionable()
	case alertfeedback.FieldAccurate:
		return m.Accurate()
	case alertfeedback.FieldDocumentationAvailable:
		return m.DocumentationAvailable()
	case alertfeedback.FieldDocumentationNeedsUpdate:
		return m.DocumentationNeedsUpdate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertFeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertfeedback.FieldTenantID:
		return m.OldTenantID(ctx)
	case alertfeedback.FieldAlertInstanceID:
		return m.OldAlertInstanceID(ctx)
	case alertfeedback.FieldActionable:
		return m.OldActionable(ctx)
	case alertfeedback.FieldAccurate:
		return m.OldAccurate(ctx)
	case alertfeedback.FieldDocumentationAvailable:
		return m.OldDocumentationAvailable(ctx)
	case alertfeedback.FieldDocumentationNeedsUpdate:
		return m.OldDocumentationNeedsUpdate(ctx)
	}
	return nil, fmt.Errorf("unknown AlertFeedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertFeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertfeedback.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case alertfeedback.FieldAlertInstanceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertInstanceID(v)
		return nil
	case alertfeedback.FieldActionable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionable(v)
		return nil
	case alertfeedback.FieldAccurate:
		v, ok := value.(alertfeedback.Accurate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccurate(v)
		return nil
	case alertfeedback.FieldDocumentationAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentationAvailable(v)
		return nil
	case alertfeedback.FieldDocumentationNeedsUpdate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentationNeedsUpdate(v)
		return nil
	}
	return fmt.Errorf("unknown AlertFeedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertFeedbackMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertFeedbackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertFeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertFeedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertFeedbackMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertFeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertFeedbackMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AlertFeedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertFeedbackMutation) ResetField(name string) error {
	switch name {
	case alertfeedback.FieldTenantID:
		m.ResetTenantID()
		return nil
	case alertfeedback.FieldAlertInstanceID:
		m.ResetAlertInstanceID()
		return nil
	case alertfeedback.FieldActionable:
		m.ResetActionable()
		return nil
	case alertfeedback.FieldAccurate:
		m.ResetAccurate()
		return nil
	case alertfeedback.FieldDocumentationAvailable:
		m.ResetDocumentationAvailable()
		return nil
	case alertfeedback.FieldDocumentationNeedsUpdate:
		m.ResetDocumentationNeedsUpdate()
		return nil
	}
	return fmt.Errorf("unknown AlertFeedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertFeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, alertfeedback.EdgeTenant)
	}
	if m.alert_instance != nil {
		edges = append(edges, alertfeedback.EdgeAlertInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertFeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertfeedback.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case alertfeedback.EdgeAlertInstance:
		if id := m.alert_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertFeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertFeedbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertFeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, alertfeedback.EdgeTenant)
	}
	if m.clearedalert_instance {
		edges = append(edges, alertfeedback.EdgeAlertInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertFeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case alertfeedback.EdgeTenant:
		return m.clearedtenant
	case alertfeedback.EdgeAlertInstance:
		return m.clearedalert_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertFeedbackMutation) ClearEdge(name string) error {
	switch name {
	case alertfeedback.EdgeTenant:
		m.ClearTenant()
		return nil
	case alertfeedback.EdgeAlertInstance:
		m.ClearAlertInstance()
		return nil
	}
	return fmt.Errorf("unknown AlertFeedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertFeedbackMutation) ResetEdge(name string) error {
	switch name {
	case alertfeedback.EdgeTenant:
		m.ResetTenant()
		return nil
	case alertfeedback.EdgeAlertInstance:
		m.ResetAlertInstance()
		return nil
	}
	return fmt.Errorf("unknown AlertFeedback edge %s", name)
}

// AlertInstanceMutation represents an operation that mutates the AlertInstance nodes in the graph.
type AlertInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	external_id     *string
	acknowledged_at *time.Time
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	alert           *uuid.UUID
	clearedalert    bool
	event           *uuid.UUID
	clearedevent    bool
	feedback        *uuid.UUID
	clearedfeedback bool
	done            bool
	oldValue        func(context.Context) (*AlertInstance, error)
	predicates      []predicate.AlertInstance
}

var _ ent.Mutation = (*AlertInstanceMutation)(nil)

// alertinstanceOption allows management of the mutation configuration using functional options.
type alertinstanceOption func(*AlertInstanceMutation)

// newAlertInstanceMutation creates new mutation for the AlertInstance entity.
func newAlertInstanceMutation(c config, op Op, opts ...alertinstanceOption) *AlertInstanceMutation {
	m := &AlertInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertInstanceID sets the ID field of the mutation.
func withAlertInstanceID(id uuid.UUID) alertinstanceOption {
	return func(m *AlertInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertInstance
		)
		m.oldValue = func(ctx context.Context) (*AlertInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertInstance sets the old AlertInstance of the mutation.
func withAlertInstance(node *AlertInstance) alertinstanceOption {
	return func(m *AlertInstanceMutation) {
		m.oldValue = func(context.Context) (*AlertInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertInstance entities.
func (m *AlertInstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertInstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertInstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *AlertInstanceMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AlertInstanceMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AlertInstance entity.
// If the AlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertInstanceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AlertInstanceMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *AlertInstanceMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *AlertInstanceMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the AlertInstance entity.
// If the AlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertInstanceMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *AlertInstanceMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[alertinstance.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *AlertInstanceMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[alertinstance.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *AlertInstanceMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, alertinstance.FieldExternalID)
}

// SetAlertID sets the "alert_id" field.
func (m *AlertInstanceMutation) SetAlertID(u uuid.UUID) {
	m.alert = &u
}

// AlertID returns the value of the "alert_id" field in the mutation.
func (m *AlertInstanceMutation) AlertID() (r uuid.UUID, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertID returns the old "alert_id" field's value of the AlertInstance entity.
// If the AlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertInstanceMutation) OldAlertID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertID: %w", err)
	}
	return oldValue.AlertID, nil
}

// ResetAlertID resets all changes to the "alert_id" field.
func (m *AlertInstanceMutation) ResetAlertID() {
	m.alert = nil
}

// SetEventID sets the "event_id" field.
func (m *AlertInstanceMutation) SetEventID(u uuid.UUID) {
	m.event = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *AlertInstanceMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the AlertInstance entity.
// If the AlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertInstanceMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *AlertInstanceMutation) ResetEventID() {
	m.event = nil
}

// SetAcknowledgedAt sets the "acknowledged_at" field.
func (m *AlertInstanceMutation) SetAcknowledgedAt(t time.Time) {
	m.acknowledged_at = &t
}

// AcknowledgedAt returns the value of the "acknowledged_at" field in the mutation.
func (m *AlertInstanceMutation) AcknowledgedAt() (r time.Time, exists bool) {
	v := m.acknowledged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedAt returns the old "acknowledged_at" field's value of the AlertInstance entity.
// If the AlertInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertInstanceMutation) OldAcknowledgedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedAt: %w", err)
	}
	return oldValue.AcknowledgedAt, nil
}

// ClearAcknowledgedAt clears the value of the "acknowledged_at" field.
func (m *AlertInstanceMutation) ClearAcknowledgedAt() {
	m.acknowledged_at = nil
	m.clearedFields[alertinstance.FieldAcknowledgedAt] = struct{}{}
}

// AcknowledgedAtCleared returns if the "acknowledged_at" field was cleared in this mutation.
func (m *AlertInstanceMutation) AcknowledgedAtCleared() bool {
	_, ok := m.clearedFields[alertinstance.FieldAcknowledgedAt]
	return ok
}

// ResetAcknowledgedAt resets all changes to the "acknowledged_at" field.
func (m *AlertInstanceMutation) ResetAcknowledgedAt() {
	m.acknowledged_at = nil
	delete(m.clearedFields, alertinstance.FieldAcknowledgedAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AlertInstanceMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[alertinstance.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AlertInstanceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AlertInstanceMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AlertInstanceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearAlert clears the "alert" edge to the Alert entity.
func (m *AlertInstanceMutation) ClearAlert() {
	m.clearedalert = true
	m.clearedFields[alertinstance.FieldAlertID] = struct{}{}
}

// AlertCleared reports if the "alert" edge to the Alert entity was cleared.
func (m *AlertInstanceMutation) AlertCleared() bool {
	return m.clearedalert
}

// AlertIDs returns the "alert" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlertID instead. It exists only for internal usage by the builders.
func (m *AlertInstanceMutation) AlertIDs() (ids []uuid.UUID) {
	if id := m.alert; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlert resets all changes to the "alert" edge.
func (m *AlertInstanceMutation) ResetAlert() {
	m.alert = nil
	m.clearedalert = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *AlertInstanceMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[alertinstance.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *AlertInstanceMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *AlertInstanceMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *AlertInstanceMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetFeedbackID sets the "feedback" edge to the AlertFeedback entity by id.
func (m *AlertInstanceMutation) SetFeedbackID(id uuid.UUID) {
	m.feedback = &id
}

// ClearFeedback clears the "feedback" edge to the AlertFeedback entity.
func (m *AlertInstanceMutation) ClearFeedback() {
	m.clearedfeedback = true
}

// FeedbackCleared reports if the "feedback" edge to the AlertFeedback entity was cleared.
func (m *AlertInstanceMutation) FeedbackCleared() bool {
	return m.clearedfeedback
}

// FeedbackID returns the "feedback" edge ID in the mutation.
func (m *AlertInstanceMutation) FeedbackID() (id uuid.UUID, exists bool) {
	if m.feedback != nil {
		return *m.feedback, true
	}
	return
}

// FeedbackIDs returns the "feedback" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedbackID instead. It exists only for internal usage by the builders.
func (m *AlertInstanceMutation) FeedbackIDs() (ids []uuid.UUID) {
	if id := m.feedback; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedback resets all changes to the "feedback" edge.
func (m *AlertInstanceMutation) ResetFeedback() {
	m.feedback = nil
	m.clearedfeedback = false
}

// Where appends a list predicates to the AlertInstanceMutation builder.
func (m *AlertInstanceMutation) Where(ps ...predicate.AlertInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertInstance).
func (m *AlertInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertInstanceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, alertinstance.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, alertinstance.FieldExternalID)
	}
	if m.alert != nil {
		fields = append(fields, alertinstance.FieldAlertID)
	}
	if m.event != nil {
		fields = append(fields, alertinstance.FieldEventID)
	}
	if m.acknowledged_at != nil {
		fields = append(fields, alertinstance.FieldAcknowledgedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertinstance.FieldTenantID:
		return m.TenantID()
	case alertinstance.FieldExternalID:
		return m.ExternalID()
	case alertinstance.FieldAlertID:
		return m.AlertID()
	case alertinstance.FieldEventID:
		return m.EventID()
	case alertinstance.FieldAcknowledgedAt:
		return m.AcknowledgedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertinstance.FieldTenantID:
		return m.OldTenantID(ctx)
	case alertinstance.FieldExternalID:
		return m.OldExternalID(ctx)
	case alertinstance.FieldAlertID:
		return m.OldAlertID(ctx)
	case alertinstance.FieldEventID:
		return m.OldEventID(ctx)
	case alertinstance.FieldAcknowledgedAt:
		return m.OldAcknowledgedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case alertinstance.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case alertinstance.FieldAlertID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertID(v)
		return nil
	case alertinstance.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case alertinstance.FieldAcknowledgedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertInstanceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlertInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertinstance.FieldExternalID) {
		fields = append(fields, alertinstance.FieldExternalID)
	}
	if m.FieldCleared(alertinstance.FieldAcknowledgedAt) {
		fields = append(fields, alertinstance.FieldAcknowledgedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertInstanceMutation) ClearField(name string) error {
	switch name {
	case alertinstance.FieldExternalID:
		m.ClearExternalID()
		return nil
	case alertinstance.FieldAcknowledgedAt:
		m.ClearAcknowledgedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertInstanceMutation) ResetField(name string) error {
	switch name {
	case alertinstance.FieldTenantID:
		m.ResetTenantID()
		return nil
	case alertinstance.FieldExternalID:
		m.ResetExternalID()
		return nil
	case alertinstance.FieldAlertID:
		m.ResetAlertID()
		return nil
	case alertinstance.FieldEventID:
		m.ResetEventID()
		return nil
	case alertinstance.FieldAcknowledgedAt:
		m.ResetAcknowledgedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, alertinstance.EdgeTenant)
	}
	if m.alert != nil {
		edges = append(edges, alertinstance.EdgeAlert)
	}
	if m.event != nil {
		edges = append(edges, alertinstance.EdgeEvent)
	}
	if m.feedback != nil {
		edges = append(edges, alertinstance.EdgeFeedback)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertinstance.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case alertinstance.EdgeAlert:
		if id := m.alert; id != nil {
			return []ent.Value{*id}
		}
	case alertinstance.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case alertinstance.EdgeFeedback:
		if id := m.feedback; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, alertinstance.EdgeTenant)
	}
	if m.clearedalert {
		edges = append(edges, alertinstance.EdgeAlert)
	}
	if m.clearedevent {
		edges = append(edges, alertinstance.EdgeEvent)
	}
	if m.clearedfeedback {
		edges = append(edges, alertinstance.EdgeFeedback)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case alertinstance.EdgeTenant:
		return m.clearedtenant
	case alertinstance.EdgeAlert:
		return m.clearedalert
	case alertinstance.EdgeEvent:
		return m.clearedevent
	case alertinstance.EdgeFeedback:
		return m.clearedfeedback
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertInstanceMutation) ClearEdge(name string) error {
	switch name {
	case alertinstance.EdgeTenant:
		m.ClearTenant()
		return nil
	case alertinstance.EdgeAlert:
		m.ClearAlert()
		return nil
	case alertinstance.EdgeEvent:
		m.ClearEvent()
		return nil
	case alertinstance.EdgeFeedback:
		m.ClearFeedback()
		return nil
	}
	return fmt.Errorf("unknown AlertInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertInstanceMutation) ResetEdge(name string) error {
	switch name {
	case alertinstance.EdgeTenant:
		m.ResetTenant()
		return nil
	case alertinstance.EdgeAlert:
		m.ResetAlert()
		return nil
	case alertinstance.EdgeEvent:
		m.ResetEvent()
		return nil
	case alertinstance.EdgeFeedback:
		m.ResetFeedback()
		return nil
	}
	return fmt.Errorf("unknown AlertInstance edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	content              *[]byte
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	retrospective        *uuid.UUID
	clearedretrospective bool
	done                 bool
	oldValue             func(context.Context) (*Document, error)
	predicates           []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id uuid.UUID) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Document entities.
func (m *DocumentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DocumentMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DocumentMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DocumentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetContent sets the "content" field.
func (m *DocumentMutation) SetContent(b []byte) {
	m.content = &b
}

// Content returns the value of the "content" field in the mutation.
func (m *DocumentMutation) Content() (r []byte, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldContent(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *DocumentMutation) ResetContent() {
	m.content = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DocumentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[document.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DocumentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DocumentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetRetrospectiveID sets the "retrospective" edge to the Retrospective entity by id.
func (m *DocumentMutation) SetRetrospectiveID(id uuid.UUID) {
	m.retrospective = &id
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *DocumentMutation) ClearRetrospective() {
	m.clearedretrospective = true
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *DocumentMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveID returns the "retrospective" edge ID in the mutation.
func (m *DocumentMutation) RetrospectiveID() (id uuid.UUID, exists bool) {
	if m.retrospective != nil {
		return *m.retrospective, true
	}
	return
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *DocumentMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, document.FieldTenantID)
	}
	if m.content != nil {
		fields = append(fields, document.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldTenantID:
		return m.TenantID()
	case document.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldTenantID:
		return m.OldTenantID(ctx)
	case document.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case document.FieldContent:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldTenantID:
		m.ResetTenantID()
		return nil
	case document.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, document.EdgeTenant)
	}
	if m.retrospective != nil {
		edges = append(edges, document.EdgeRetrospective)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, document.EdgeTenant)
	}
	if m.clearedretrospective {
		edges = append(edges, document.EdgeRetrospective)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeTenant:
		return m.clearedtenant
	case document.EdgeRetrospective:
		return m.clearedretrospective
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeTenant:
		m.ClearTenant()
		return nil
	case document.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeTenant:
		m.ResetTenant()
		return nil
	case document.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	external_id           *string
	timestamp             *time.Time
	kind                  *event.Kind
	title                 *string
	description           *string
	source                *string
	clearedFields         map[string]struct{}
	tenant                *int
	clearedtenant         bool
	alert_instance        map[uuid.UUID]struct{}
	removedalert_instance map[uuid.UUID]struct{}
	clearedalert_instance bool
	incident_event        map[uuid.UUID]struct{}
	removedincident_event map[uuid.UUID]struct{}
	clearedincident_event bool
	annotations           map[uuid.UUID]struct{}
	removedannotations    map[uuid.UUID]struct{}
	clearedannotations    bool
	done                  bool
	oldValue              func(context.Context) (*Event, error)
	predicates            []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uuid.UUID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *EventMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *EventMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *EventMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *EventMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *EventMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *EventMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[event.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *EventMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[event.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *EventMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, event.FieldExternalID)
}

// SetTimestamp sets the "timestamp" field.
func (m *EventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetKind sets the "kind" field.
func (m *EventMutation) SetKind(e event.Kind) {
	m.kind = &e
}

// Kind returns the value of the "kind" field in the mutation.
func (m *EventMutation) Kind() (r event.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldKind(ctx context.Context) (v event.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *EventMutation) ResetKind() {
	m.kind = nil
}

// SetTitle sets the "title" field.
func (m *EventMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EventMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EventMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *EventMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *EventMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *EventMutation) ResetSource() {
	m.source = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *EventMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[event.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *EventMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *EventMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *EventMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddAlertInstanceIDs adds the "alert_instance" edge to the AlertInstance entity by ids.
func (m *EventMutation) AddAlertInstanceIDs(ids ...uuid.UUID) {
	if m.alert_instance == nil {
		m.alert_instance = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.alert_instance[ids[i]] = struct{}{}
	}
}

// ClearAlertInstance clears the "alert_instance" edge to the AlertInstance entity.
func (m *EventMutation) ClearAlertInstance() {
	m.clearedalert_instance = true
}

// AlertInstanceCleared reports if the "alert_instance" edge to the AlertInstance entity was cleared.
func (m *EventMutation) AlertInstanceCleared() bool {
	return m.clearedalert_instance
}

// RemoveAlertInstanceIDs removes the "alert_instance" edge to the AlertInstance entity by IDs.
func (m *EventMutation) RemoveAlertInstanceIDs(ids ...uuid.UUID) {
	if m.removedalert_instance == nil {
		m.removedalert_instance = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.alert_instance, ids[i])
		m.removedalert_instance[ids[i]] = struct{}{}
	}
}

// RemovedAlertInstance returns the removed IDs of the "alert_instance" edge to the AlertInstance entity.
func (m *EventMutation) RemovedAlertInstanceIDs() (ids []uuid.UUID) {
	for id := range m.removedalert_instance {
		ids = append(ids, id)
	}
	return
}

// AlertInstanceIDs returns the "alert_instance" edge IDs in the mutation.
func (m *EventMutation) AlertInstanceIDs() (ids []uuid.UUID) {
	for id := range m.alert_instance {
		ids = append(ids, id)
	}
	return
}

// ResetAlertInstance resets all changes to the "alert_instance" edge.
func (m *EventMutation) ResetAlertInstance() {
	m.alert_instance = nil
	m.clearedalert_instance = false
	m.removedalert_instance = nil
}

// AddIncidentEventIDs adds the "incident_event" edge to the IncidentEvent entity by ids.
func (m *EventMutation) AddIncidentEventIDs(ids ...uuid.UUID) {
	if m.incident_event == nil {
		m.incident_event = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_event[ids[i]] = struct{}{}
	}
}

// ClearIncidentEvent clears the "incident_event" edge to the IncidentEvent entity.
func (m *EventMutation) ClearIncidentEvent() {
	m.clearedincident_event = true
}

// IncidentEventCleared reports if the "incident_event" edge to the IncidentEvent entity was cleared.
func (m *EventMutation) IncidentEventCleared() bool {
	return m.clearedincident_event
}

// RemoveIncidentEventIDs removes the "incident_event" edge to the IncidentEvent entity by IDs.
func (m *EventMutation) RemoveIncidentEventIDs(ids ...uuid.UUID) {
	if m.removedincident_event == nil {
		m.removedincident_event = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_event, ids[i])
		m.removedincident_event[ids[i]] = struct{}{}
	}
}

// RemovedIncidentEvent returns the removed IDs of the "incident_event" edge to the IncidentEvent entity.
func (m *EventMutation) RemovedIncidentEventIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_event {
		ids = append(ids, id)
	}
	return
}

// IncidentEventIDs returns the "incident_event" edge IDs in the mutation.
func (m *EventMutation) IncidentEventIDs() (ids []uuid.UUID) {
	for id := range m.incident_event {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentEvent resets all changes to the "incident_event" edge.
func (m *EventMutation) ResetIncidentEvent() {
	m.incident_event = nil
	m.clearedincident_event = false
	m.removedincident_event = nil
}

// AddAnnotationIDs adds the "annotations" edge to the EventAnnotation entity by ids.
func (m *EventMutation) AddAnnotationIDs(ids ...uuid.UUID) {
	if m.annotations == nil {
		m.annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.annotations[ids[i]] = struct{}{}
	}
}

// ClearAnnotations clears the "annotations" edge to the EventAnnotation entity.
func (m *EventMutation) ClearAnnotations() {
	m.clearedannotations = true
}

// AnnotationsCleared reports if the "annotations" edge to the EventAnnotation entity was cleared.
func (m *EventMutation) AnnotationsCleared() bool {
	return m.clearedannotations
}

// RemoveAnnotationIDs removes the "annotations" edge to the EventAnnotation entity by IDs.
func (m *EventMutation) RemoveAnnotationIDs(ids ...uuid.UUID) {
	if m.removedannotations == nil {
		m.removedannotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.annotations, ids[i])
		m.removedannotations[ids[i]] = struct{}{}
	}
}

// RemovedAnnotations returns the removed IDs of the "annotations" edge to the EventAnnotation entity.
func (m *EventMutation) RemovedAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.removedannotations {
		ids = append(ids, id)
	}
	return
}

// AnnotationsIDs returns the "annotations" edge IDs in the mutation.
func (m *EventMutation) AnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.annotations {
		ids = append(ids, id)
	}
	return
}

// ResetAnnotations resets all changes to the "annotations" edge.
func (m *EventMutation) ResetAnnotations() {
	m.annotations = nil
	m.clearedannotations = false
	m.removedannotations = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, event.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, event.FieldExternalID)
	}
	if m.timestamp != nil {
		fields = append(fields, event.FieldTimestamp)
	}
	if m.kind != nil {
		fields = append(fields, event.FieldKind)
	}
	if m.title != nil {
		fields = append(fields, event.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, event.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldTenantID:
		return m.TenantID()
	case event.FieldExternalID:
		return m.ExternalID()
	case event.FieldTimestamp:
		return m.Timestamp()
	case event.FieldKind:
		return m.Kind()
	case event.FieldTitle:
		return m.Title()
	case event.FieldDescription:
		return m.Description()
	case event.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldTenantID:
		return m.OldTenantID(ctx)
	case event.FieldExternalID:
		return m.OldExternalID(ctx)
	case event.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case event.FieldKind:
		return m.OldKind(ctx)
	case event.FieldTitle:
		return m.OldTitle(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case event.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case event.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case event.FieldKind:
		v, ok := value.(event.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case event.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldExternalID) {
		fields = append(fields, event.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldTenantID:
		m.ResetTenantID()
		return nil
	case event.FieldExternalID:
		m.ResetExternalID()
		return nil
	case event.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case event.FieldKind:
		m.ResetKind()
		return nil
	case event.FieldTitle:
		m.ResetTitle()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, event.EdgeTenant)
	}
	if m.alert_instance != nil {
		edges = append(edges, event.EdgeAlertInstance)
	}
	if m.incident_event != nil {
		edges = append(edges, event.EdgeIncidentEvent)
	}
	if m.annotations != nil {
		edges = append(edges, event.EdgeAnnotations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeAlertInstance:
		ids := make([]ent.Value, 0, len(m.alert_instance))
		for id := range m.alert_instance {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeIncidentEvent:
		ids := make([]ent.Value, 0, len(m.incident_event))
		for id := range m.incident_event {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.annotations))
		for id := range m.annotations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedalert_instance != nil {
		edges = append(edges, event.EdgeAlertInstance)
	}
	if m.removedincident_event != nil {
		edges = append(edges, event.EdgeIncidentEvent)
	}
	if m.removedannotations != nil {
		edges = append(edges, event.EdgeAnnotations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeAlertInstance:
		ids := make([]ent.Value, 0, len(m.removedalert_instance))
		for id := range m.removedalert_instance {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeIncidentEvent:
		ids := make([]ent.Value, 0, len(m.removedincident_event))
		for id := range m.removedincident_event {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.removedannotations))
		for id := range m.removedannotations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, event.EdgeTenant)
	}
	if m.clearedalert_instance {
		edges = append(edges, event.EdgeAlertInstance)
	}
	if m.clearedincident_event {
		edges = append(edges, event.EdgeIncidentEvent)
	}
	if m.clearedannotations {
		edges = append(edges, event.EdgeAnnotations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeTenant:
		return m.clearedtenant
	case event.EdgeAlertInstance:
		return m.clearedalert_instance
	case event.EdgeIncidentEvent:
		return m.clearedincident_event
	case event.EdgeAnnotations:
		return m.clearedannotations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeTenant:
		m.ResetTenant()
		return nil
	case event.EdgeAlertInstance:
		m.ResetAlertInstance()
		return nil
	case event.EdgeIncidentEvent:
		m.ResetIncidentEvent()
		return nil
	case event.EdgeAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventAnnotationMutation represents an operation that mutates the EventAnnotation nodes in the graph.
type EventAnnotationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	minutes_occupied    *int
	addminutes_occupied *int
	notes               *string
	tags                *[]string
	appendtags          []string
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	event               *uuid.UUID
	clearedevent        bool
	creator             *uuid.UUID
	clearedcreator      bool
	handovers           map[uuid.UUID]struct{}
	removedhandovers    map[uuid.UUID]struct{}
	clearedhandovers    bool
	done                bool
	oldValue            func(context.Context) (*EventAnnotation, error)
	predicates          []predicate.EventAnnotation
}

var _ ent.Mutation = (*EventAnnotationMutation)(nil)

// eventannotationOption allows management of the mutation configuration using functional options.
type eventannotationOption func(*EventAnnotationMutation)

// newEventAnnotationMutation creates new mutation for the EventAnnotation entity.
func newEventAnnotationMutation(c config, op Op, opts ...eventannotationOption) *EventAnnotationMutation {
	m := &EventAnnotationMutation{
		config:        c,
		op:            op,
		typ:           TypeEventAnnotation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventAnnotationID sets the ID field of the mutation.
func withEventAnnotationID(id uuid.UUID) eventannotationOption {
	return func(m *EventAnnotationMutation) {
		var (
			err   error
			once  sync.Once
			value *EventAnnotation
		)
		m.oldValue = func(ctx context.Context) (*EventAnnotation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventAnnotation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventAnnotation sets the old EventAnnotation of the mutation.
func withEventAnnotation(node *EventAnnotation) eventannotationOption {
	return func(m *EventAnnotationMutation) {
		m.oldValue = func(context.Context) (*EventAnnotation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventAnnotationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventAnnotationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventAnnotation entities.
func (m *EventAnnotationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventAnnotationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventAnnotationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventAnnotation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *EventAnnotationMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *EventAnnotationMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the EventAnnotation entity.
// If the EventAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventAnnotationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *EventAnnotationMutation) ResetTenantID() {
	m.tenant = nil
}

// SetEventID sets the "event_id" field.
func (m *EventAnnotationMutation) SetEventID(u uuid.UUID) {
	m.event = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventAnnotationMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventAnnotation entity.
// If the EventAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventAnnotationMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventAnnotationMutation) ResetEventID() {
	m.event = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *EventAnnotationMutation) SetCreatorID(u uuid.UUID) {
	m.creator = &u
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *EventAnnotationMutation) CreatorID() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the EventAnnotation entity.
// If the EventAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventAnnotationMutation) OldCreatorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *EventAnnotationMutation) ResetCreatorID() {
	m.creator = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventAnnotationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventAnnotationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventAnnotation entity.
// If the EventAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventAnnotationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventAnnotationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMinutesOccupied sets the "minutes_occupied" field.
func (m *EventAnnotationMutation) SetMinutesOccupied(i int) {
	m.minutes_occupied = &i
	m.addminutes_occupied = nil
}

// MinutesOccupied returns the value of the "minutes_occupied" field in the mutation.
func (m *EventAnnotationMutation) MinutesOccupied() (r int, exists bool) {
	v := m.minutes_occupied
	if v == nil {
		return
	}
	return *v, true
}

// OldMinutesOccupied returns the old "minutes_occupied" field's value of the EventAnnotation entity.
// If the EventAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventAnnotationMutation) OldMinutesOccupied(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinutesOccupied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinutesOccupied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinutesOccupied: %w", err)
	}
	return oldValue.MinutesOccupied, nil
}

// AddMinutesOccupied adds i to the "minutes_occupied" field.
func (m *EventAnnotationMutation) AddMinutesOccupied(i int) {
	if m.addminutes_occupied != nil {
		*m.addminutes_occupied += i
	} else {
		m.addminutes_occupied = &i
	}
}

// AddedMinutesOccupied returns the value that was added to the "minutes_occupied" field in this mutation.
func (m *EventAnnotationMutation) AddedMinutesOccupied() (r int, exists bool) {
	v := m.addminutes_occupied
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinutesOccupied resets all changes to the "minutes_occupied" field.
func (m *EventAnnotationMutation) ResetMinutesOccupied() {
	m.minutes_occupied = nil
	m.addminutes_occupied = nil
}

// SetNotes sets the "notes" field.
func (m *EventAnnotationMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *EventAnnotationMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the EventAnnotation entity.
// If the EventAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventAnnotationMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *EventAnnotationMutation) ResetNotes() {
	m.notes = nil
}

// SetTags sets the "tags" field.
func (m *EventAnnotationMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EventAnnotationMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EventAnnotation entity.
// If the EventAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventAnnotationMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EventAnnotationMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EventAnnotationMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *EventAnnotationMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *EventAnnotationMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[eventannotation.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *EventAnnotationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *EventAnnotationMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *EventAnnotationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventAnnotationMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[eventannotation.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventAnnotationMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventAnnotationMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventAnnotationMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *EventAnnotationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[eventannotation.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *EventAnnotationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EventAnnotationMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EventAnnotationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddHandoverIDs adds the "handovers" edge to the OncallShiftHandover entity by ids.
func (m *EventAnnotationMutation) AddHandoverIDs(ids ...uuid.UUID) {
	if m.handovers == nil {
		m.handovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.handovers[ids[i]] = struct{}{}
	}
}

// ClearHandovers clears the "handovers" edge to the OncallShiftHandover entity.
func (m *EventAnnotationMutation) ClearHandovers() {
	m.clearedhandovers = true
}

// HandoversCleared reports if the "handovers" edge to the OncallShiftHandover entity was cleared.
func (m *EventAnnotationMutation) HandoversCleared() bool {
	return m.clearedhandovers
}

// RemoveHandoverIDs removes the "handovers" edge to the OncallShiftHandover entity by IDs.
func (m *EventAnnotationMutation) RemoveHandoverIDs(ids ...uuid.UUID) {
	if m.removedhandovers == nil {
		m.removedhandovers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.handovers, ids[i])
		m.removedhandovers[ids[i]] = struct{}{}
	}
}

// RemovedHandovers returns the removed IDs of the "handovers" edge to the OncallShiftHandover entity.
func (m *EventAnnotationMutation) RemovedHandoversIDs() (ids []uuid.UUID) {
	for id := range m.removedhandovers {
		ids = append(ids, id)
	}
	return
}

// HandoversIDs returns the "handovers" edge IDs in the mutation.
func (m *EventAnnotationMutation) HandoversIDs() (ids []uuid.UUID) {
	for id := range m.handovers {
		ids = append(ids, id)
	}
	return
}

// ResetHandovers resets all changes to the "handovers" edge.
func (m *EventAnnotationMutation) ResetHandovers() {
	m.handovers = nil
	m.clearedhandovers = false
	m.removedhandovers = nil
}

// Where appends a list predicates to the EventAnnotationMutation builder.
func (m *EventAnnotationMutation) Where(ps ...predicate.EventAnnotation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventAnnotationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventAnnotationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventAnnotation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventAnnotationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventAnnotationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventAnnotation).
func (m *EventAnnotationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventAnnotationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, eventannotation.FieldTenantID)
	}
	if m.event != nil {
		fields = append(fields, eventannotation.FieldEventID)
	}
	if m.creator != nil {
		fields = append(fields, eventannotation.FieldCreatorID)
	}
	if m.created_at != nil {
		fields = append(fields, eventannotation.FieldCreatedAt)
	}
	if m.minutes_occupied != nil {
		fields = append(fields, eventannotation.FieldMinutesOccupied)
	}
	if m.notes != nil {
		fields = append(fields, eventannotation.FieldNotes)
	}
	if m.tags != nil {
		fields = append(fields, eventannotation.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventAnnotationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventannotation.FieldTenantID:
		return m.TenantID()
	case eventannotation.FieldEventID:
		return m.EventID()
	case eventannotation.FieldCreatorID:
		return m.CreatorID()
	case eventannotation.FieldCreatedAt:
		return m.CreatedAt()
	case eventannotation.FieldMinutesOccupied:
		return m.MinutesOccupied()
	case eventannotation.FieldNotes:
		return m.Notes()
	case eventannotation.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventAnnotationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventannotation.FieldTenantID:
		return m.OldTenantID(ctx)
	case eventannotation.FieldEventID:
		return m.OldEventID(ctx)
	case eventannotation.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case eventannotation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventannotation.FieldMinutesOccupied:
		return m.OldMinutesOccupied(ctx)
	case eventannotation.FieldNotes:
		return m.OldNotes(ctx)
	case eventannotation.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown EventAnnotation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventAnnotationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventannotation.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case eventannotation.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case eventannotation.FieldCreatorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case eventannotation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventannotation.FieldMinutesOccupied:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinutesOccupied(v)
		return nil
	case eventannotation.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case eventannotation.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown EventAnnotation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventAnnotationMutation) AddedFields() []string {
	var fields []string
	if m.addminutes_occupied != nil {
		fields = append(fields, eventannotation.FieldMinutesOccupied)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventAnnotationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case eventannotation.FieldMinutesOccupied:
		return m.AddedMinutesOccupied()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventAnnotationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case eventannotation.FieldMinutesOccupied:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinutesOccupied(v)
		return nil
	}
	return fmt.Errorf("unknown EventAnnotation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventAnnotationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventAnnotationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventAnnotationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventAnnotation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventAnnotationMutation) ResetField(name string) error {
	switch name {
	case eventannotation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case eventannotation.FieldEventID:
		m.ResetEventID()
		return nil
	case eventannotation.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case eventannotation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventannotation.FieldMinutesOccupied:
		m.ResetMinutesOccupied()
		return nil
	case eventannotation.FieldNotes:
		m.ResetNotes()
		return nil
	case eventannotation.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown EventAnnotation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventAnnotationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, eventannotation.EdgeTenant)
	}
	if m.event != nil {
		edges = append(edges, eventannotation.EdgeEvent)
	}
	if m.creator != nil {
		edges = append(edges, eventannotation.EdgeCreator)
	}
	if m.handovers != nil {
		edges = append(edges, eventannotation.EdgeHandovers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventAnnotationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventannotation.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case eventannotation.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case eventannotation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case eventannotation.EdgeHandovers:
		ids := make([]ent.Value, 0, len(m.handovers))
		for id := range m.handovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventAnnotationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedhandovers != nil {
		edges = append(edges, eventannotation.EdgeHandovers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventAnnotationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case eventannotation.EdgeHandovers:
		ids := make([]ent.Value, 0, len(m.removedhandovers))
		for id := range m.removedhandovers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventAnnotationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, eventannotation.EdgeTenant)
	}
	if m.clearedevent {
		edges = append(edges, eventannotation.EdgeEvent)
	}
	if m.clearedcreator {
		edges = append(edges, eventannotation.EdgeCreator)
	}
	if m.clearedhandovers {
		edges = append(edges, eventannotation.EdgeHandovers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventAnnotationMutation) EdgeCleared(name string) bool {
	switch name {
	case eventannotation.EdgeTenant:
		return m.clearedtenant
	case eventannotation.EdgeEvent:
		return m.clearedevent
	case eventannotation.EdgeCreator:
		return m.clearedcreator
	case eventannotation.EdgeHandovers:
		return m.clearedhandovers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventAnnotationMutation) ClearEdge(name string) error {
	switch name {
	case eventannotation.EdgeTenant:
		m.ClearTenant()
		return nil
	case eventannotation.EdgeEvent:
		m.ClearEvent()
		return nil
	case eventannotation.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown EventAnnotation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventAnnotationMutation) ResetEdge(name string) error {
	switch name {
	case eventannotation.EdgeTenant:
		m.ResetTenant()
		return nil
	case eventannotation.EdgeEvent:
		m.ResetEvent()
		return nil
	case eventannotation.EdgeCreator:
		m.ResetCreator()
		return nil
	case eventannotation.EdgeHandovers:
		m.ResetHandovers()
		return nil
	}
	return fmt.Errorf("unknown EventAnnotation edge %s", name)
}

// IncidentMutation represents an operation that mutates the Incident nodes in the graph.
type IncidentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	external_id             *string
	created_at              *time.Time
	updated_at              *time.Time
	slug                    *string
	title                   *string
	summary                 *string
	chat_channel_id         *string
	opened_at               *time.Time
	clearedFields           map[string]struct{}
	tenant                  *int
	clearedtenant           bool
	severity                *uuid.UUID
	clearedseverity         bool
	_type                   *uuid.UUID
	cleared_type            bool
	milestones              map[uuid.UUID]struct{}
	removedmilestones       map[uuid.UUID]struct{}
	clearedmilestones       bool
	events                  map[uuid.UUID]struct{}
	removedevents           map[uuid.UUID]struct{}
	clearedevents           bool
	retrospective           *uuid.UUID
	clearedretrospective    bool
	users                   map[uuid.UUID]struct{}
	removedusers            map[uuid.UUID]struct{}
	clearedusers            bool
	role_assignments        map[uuid.UUID]struct{}
	removedrole_assignments map[uuid.UUID]struct{}
	clearedrole_assignments bool
	linked_incidents        map[uuid.UUID]struct{}
	removedlinked_incidents map[uuid.UUID]struct{}
	clearedlinked_incidents bool
	field_selections        map[uuid.UUID]struct{}
	removedfield_selections map[uuid.UUID]struct{}
	clearedfield_selections bool
	tasks                   map[uuid.UUID]struct{}
	removedtasks            map[uuid.UUID]struct{}
	clearedtasks            bool
	tag_assignments         map[uuid.UUID]struct{}
	removedtag_assignments  map[uuid.UUID]struct{}
	clearedtag_assignments  bool
	debriefs                map[uuid.UUID]struct{}
	removeddebriefs         map[uuid.UUID]struct{}
	cleareddebriefs         bool
	review_sessions         map[uuid.UUID]struct{}
	removedreview_sessions  map[uuid.UUID]struct{}
	clearedreview_sessions  bool
	user_roles              map[uuid.UUID]struct{}
	removeduser_roles       map[uuid.UUID]struct{}
	cleareduser_roles       bool
	incident_links          map[int]struct{}
	removedincident_links   map[int]struct{}
	clearedincident_links   bool
	done                    bool
	oldValue                func(context.Context) (*Incident, error)
	predicates              []predicate.Incident
}

var _ ent.Mutation = (*IncidentMutation)(nil)

// incidentOption allows management of the mutation configuration using functional options.
type incidentOption func(*IncidentMutation)

// newIncidentMutation creates new mutation for the Incident entity.
func newIncidentMutation(c config, op Op, opts ...incidentOption) *IncidentMutation {
	m := &IncidentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncident,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentID sets the ID field of the mutation.
func withIncidentID(id uuid.UUID) incidentOption {
	return func(m *IncidentMutation) {
		var (
			err   error
			once  sync.Once
			value *Incident
		)
		m.oldValue = func(ctx context.Context) (*Incident, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Incident.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncident sets the old Incident of the mutation.
func withIncident(node *Incident) incidentOption {
	return func(m *IncidentMutation) {
		m.oldValue = func(context.Context) (*Incident, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Incident entities.
func (m *IncidentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Incident.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *IncidentMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *IncidentMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *IncidentMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[incident.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *IncidentMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *IncidentMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, incident.FieldExternalID)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSlug sets the "slug" field.
func (m *IncidentMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *IncidentMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *IncidentMutation) ResetSlug() {
	m.slug = nil
}

// SetTitle sets the "title" field.
func (m *IncidentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentMutation) ResetTitle() {
	m.title = nil
}

// SetSeverityID sets the "severity_id" field.
func (m *IncidentMutation) SetSeverityID(u uuid.UUID) {
	m.severity = &u
}

// SeverityID returns the value of the "severity_id" field in the mutation.
func (m *IncidentMutation) SeverityID() (r uuid.UUID, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverityID returns the old "severity_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSeverityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverityID: %w", err)
	}
	return oldValue.SeverityID, nil
}

// ResetSeverityID resets all changes to the "severity_id" field.
func (m *IncidentMutation) ResetSeverityID() {
	m.severity = nil
}

// SetTypeID sets the "type_id" field.
func (m *IncidentMutation) SetTypeID(u uuid.UUID) {
	m._type = &u
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *IncidentMutation) TypeID() (r uuid.UUID, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *IncidentMutation) ResetTypeID() {
	m._type = nil
}

// SetSummary sets the "summary" field.
func (m *IncidentMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *IncidentMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *IncidentMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[incident.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *IncidentMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[incident.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *IncidentMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, incident.FieldSummary)
}

// SetChatChannelID sets the "chat_channel_id" field.
func (m *IncidentMutation) SetChatChannelID(s string) {
	m.chat_channel_id = &s
}

// ChatChannelID returns the value of the "chat_channel_id" field in the mutation.
func (m *IncidentMutation) ChatChannelID() (r string, exists bool) {
	v := m.chat_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatChannelID returns the old "chat_channel_id" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldChatChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatChannelID: %w", err)
	}
	return oldValue.ChatChannelID, nil
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (m *IncidentMutation) ClearChatChannelID() {
	m.chat_channel_id = nil
	m.clearedFields[incident.FieldChatChannelID] = struct{}{}
}

// ChatChannelIDCleared returns if the "chat_channel_id" field was cleared in this mutation.
func (m *IncidentMutation) ChatChannelIDCleared() bool {
	_, ok := m.clearedFields[incident.FieldChatChannelID]
	return ok
}

// ResetChatChannelID resets all changes to the "chat_channel_id" field.
func (m *IncidentMutation) ResetChatChannelID() {
	m.chat_channel_id = nil
	delete(m.clearedFields, incident.FieldChatChannelID)
}

// SetOpenedAt sets the "opened_at" field.
func (m *IncidentMutation) SetOpenedAt(t time.Time) {
	m.opened_at = &t
}

// OpenedAt returns the value of the "opened_at" field in the mutation.
func (m *IncidentMutation) OpenedAt() (r time.Time, exists bool) {
	v := m.opened_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenedAt returns the old "opened_at" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldOpenedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenedAt: %w", err)
	}
	return oldValue.OpenedAt, nil
}

// ResetOpenedAt resets all changes to the "opened_at" field.
func (m *IncidentMutation) ResetOpenedAt() {
	m.opened_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incident.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearSeverity clears the "severity" edge to the IncidentSeverity entity.
func (m *IncidentMutation) ClearSeverity() {
	m.clearedseverity = true
	m.clearedFields[incident.FieldSeverityID] = struct{}{}
}

// SeverityCleared reports if the "severity" edge to the IncidentSeverity entity was cleared.
func (m *IncidentMutation) SeverityCleared() bool {
	return m.clearedseverity
}

// SeverityIDs returns the "severity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeverityID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) SeverityIDs() (ids []uuid.UUID) {
	if id := m.severity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeverity resets all changes to the "severity" edge.
func (m *IncidentMutation) ResetSeverity() {
	m.severity = nil
	m.clearedseverity = false
}

// ClearType clears the "type" edge to the IncidentType entity.
func (m *IncidentMutation) ClearType() {
	m.cleared_type = true
	m.clearedFields[incident.FieldTypeID] = struct{}{}
}

// TypeCleared reports if the "type" edge to the IncidentType entity was cleared.
func (m *IncidentMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) TypeIDs() (ids []uuid.UUID) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *IncidentMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// AddMilestoneIDs adds the "milestones" edge to the IncidentMilestone entity by ids.
func (m *IncidentMutation) AddMilestoneIDs(ids ...uuid.UUID) {
	if m.milestones == nil {
		m.milestones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.milestones[ids[i]] = struct{}{}
	}
}

// ClearMilestones clears the "milestones" edge to the IncidentMilestone entity.
func (m *IncidentMutation) ClearMilestones() {
	m.clearedmilestones = true
}

// MilestonesCleared reports if the "milestones" edge to the IncidentMilestone entity was cleared.
func (m *IncidentMutation) MilestonesCleared() bool {
	return m.clearedmilestones
}

// RemoveMilestoneIDs removes the "milestones" edge to the IncidentMilestone entity by IDs.
func (m *IncidentMutation) RemoveMilestoneIDs(ids ...uuid.UUID) {
	if m.removedmilestones == nil {
		m.removedmilestones = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.milestones, ids[i])
		m.removedmilestones[ids[i]] = struct{}{}
	}
}

// RemovedMilestones returns the removed IDs of the "milestones" edge to the IncidentMilestone entity.
func (m *IncidentMutation) RemovedMilestonesIDs() (ids []uuid.UUID) {
	for id := range m.removedmilestones {
		ids = append(ids, id)
	}
	return
}

// MilestonesIDs returns the "milestones" edge IDs in the mutation.
func (m *IncidentMutation) MilestonesIDs() (ids []uuid.UUID) {
	for id := range m.milestones {
		ids = append(ids, id)
	}
	return
}

// ResetMilestones resets all changes to the "milestones" edge.
func (m *IncidentMutation) ResetMilestones() {
	m.milestones = nil
	m.clearedmilestones = false
	m.removedmilestones = nil
}

// AddEventIDs adds the "events" edge to the IncidentEvent entity by ids.
func (m *IncidentMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the IncidentEvent entity.
func (m *IncidentMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the IncidentEvent entity was cleared.
func (m *IncidentMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the IncidentEvent entity by IDs.
func (m *IncidentMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the IncidentEvent entity.
func (m *IncidentMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *IncidentMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *IncidentMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// SetRetrospectiveID sets the "retrospective" edge to the Retrospective entity by id.
func (m *IncidentMutation) SetRetrospectiveID(id uuid.UUID) {
	m.retrospective = &id
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *IncidentMutation) ClearRetrospective() {
	m.clearedretrospective = true
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *IncidentMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveID returns the "retrospective" edge ID in the mutation.
func (m *IncidentMutation) RetrospectiveID() (id uuid.UUID, exists bool) {
	if m.retrospective != nil {
		return *m.retrospective, true
	}
	return
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *IncidentMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *IncidentMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *IncidentMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *IncidentMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *IncidentMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *IncidentMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *IncidentMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *IncidentMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *IncidentMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRoleAssignmentIDs adds the "role_assignments" edge to the IncidentRoleAssignment entity by ids.
func (m *IncidentMutation) AddRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.role_assignments == nil {
		m.role_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_assignments[ids[i]] = struct{}{}
	}
}

// ClearRoleAssignments clears the "role_assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentMutation) ClearRoleAssignments() {
	m.clearedrole_assignments = true
}

// RoleAssignmentsCleared reports if the "role_assignments" edge to the IncidentRoleAssignment entity was cleared.
func (m *IncidentMutation) RoleAssignmentsCleared() bool {
	return m.clearedrole_assignments
}

// RemoveRoleAssignmentIDs removes the "role_assignments" edge to the IncidentRoleAssignment entity by IDs.
func (m *IncidentMutation) RemoveRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.removedrole_assignments == nil {
		m.removedrole_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_assignments, ids[i])
		m.removedrole_assignments[ids[i]] = struct{}{}
	}
}

// RemovedRoleAssignments returns the removed IDs of the "role_assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentMutation) RemovedRoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_assignments {
		ids = append(ids, id)
	}
	return
}

// RoleAssignmentsIDs returns the "role_assignments" edge IDs in the mutation.
func (m *IncidentMutation) RoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.role_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetRoleAssignments resets all changes to the "role_assignments" edge.
func (m *IncidentMutation) ResetRoleAssignments() {
	m.role_assignments = nil
	m.clearedrole_assignments = false
	m.removedrole_assignments = nil
}

// AddLinkedIncidentIDs adds the "linked_incidents" edge to the Incident entity by ids.
func (m *IncidentMutation) AddLinkedIncidentIDs(ids ...uuid.UUID) {
	if m.linked_incidents == nil {
		m.linked_incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.linked_incidents[ids[i]] = struct{}{}
	}
}

// ClearLinkedIncidents clears the "linked_incidents" edge to the Incident entity.
func (m *IncidentMutation) ClearLinkedIncidents() {
	m.clearedlinked_incidents = true
}

// LinkedIncidentsCleared reports if the "linked_incidents" edge to the Incident entity was cleared.
func (m *IncidentMutation) LinkedIncidentsCleared() bool {
	return m.clearedlinked_incidents
}

// RemoveLinkedIncidentIDs removes the "linked_incidents" edge to the Incident entity by IDs.
func (m *IncidentMutation) RemoveLinkedIncidentIDs(ids ...uuid.UUID) {
	if m.removedlinked_incidents == nil {
		m.removedlinked_incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.linked_incidents, ids[i])
		m.removedlinked_incidents[ids[i]] = struct{}{}
	}
}

// RemovedLinkedIncidents returns the removed IDs of the "linked_incidents" edge to the Incident entity.
func (m *IncidentMutation) RemovedLinkedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedlinked_incidents {
		ids = append(ids, id)
	}
	return
}

// LinkedIncidentsIDs returns the "linked_incidents" edge IDs in the mutation.
func (m *IncidentMutation) LinkedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.linked_incidents {
		ids = append(ids, id)
	}
	return
}

// ResetLinkedIncidents resets all changes to the "linked_incidents" edge.
func (m *IncidentMutation) ResetLinkedIncidents() {
	m.linked_incidents = nil
	m.clearedlinked_incidents = false
	m.removedlinked_incidents = nil
}

// AddFieldSelectionIDs adds the "field_selections" edge to the IncidentFieldOption entity by ids.
func (m *IncidentMutation) AddFieldSelectionIDs(ids ...uuid.UUID) {
	if m.field_selections == nil {
		m.field_selections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.field_selections[ids[i]] = struct{}{}
	}
}

// ClearFieldSelections clears the "field_selections" edge to the IncidentFieldOption entity.
func (m *IncidentMutation) ClearFieldSelections() {
	m.clearedfield_selections = true
}

// FieldSelectionsCleared reports if the "field_selections" edge to the IncidentFieldOption entity was cleared.
func (m *IncidentMutation) FieldSelectionsCleared() bool {
	return m.clearedfield_selections
}

// RemoveFieldSelectionIDs removes the "field_selections" edge to the IncidentFieldOption entity by IDs.
func (m *IncidentMutation) RemoveFieldSelectionIDs(ids ...uuid.UUID) {
	if m.removedfield_selections == nil {
		m.removedfield_selections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.field_selections, ids[i])
		m.removedfield_selections[ids[i]] = struct{}{}
	}
}

// RemovedFieldSelections returns the removed IDs of the "field_selections" edge to the IncidentFieldOption entity.
func (m *IncidentMutation) RemovedFieldSelectionsIDs() (ids []uuid.UUID) {
	for id := range m.removedfield_selections {
		ids = append(ids, id)
	}
	return
}

// FieldSelectionsIDs returns the "field_selections" edge IDs in the mutation.
func (m *IncidentMutation) FieldSelectionsIDs() (ids []uuid.UUID) {
	for id := range m.field_selections {
		ids = append(ids, id)
	}
	return
}

// ResetFieldSelections resets all changes to the "field_selections" edge.
func (m *IncidentMutation) ResetFieldSelections() {
	m.field_selections = nil
	m.clearedfield_selections = false
	m.removedfield_selections = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *IncidentMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *IncidentMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *IncidentMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *IncidentMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *IncidentMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *IncidentMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *IncidentMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddTagAssignmentIDs adds the "tag_assignments" edge to the IncidentTag entity by ids.
func (m *IncidentMutation) AddTagAssignmentIDs(ids ...uuid.UUID) {
	if m.tag_assignments == nil {
		m.tag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tag_assignments[ids[i]] = struct{}{}
	}
}

// ClearTagAssignments clears the "tag_assignments" edge to the IncidentTag entity.
func (m *IncidentMutation) ClearTagAssignments() {
	m.clearedtag_assignments = true
}

// TagAssignmentsCleared reports if the "tag_assignments" edge to the IncidentTag entity was cleared.
func (m *IncidentMutation) TagAssignmentsCleared() bool {
	return m.clearedtag_assignments
}

// RemoveTagAssignmentIDs removes the "tag_assignments" edge to the IncidentTag entity by IDs.
func (m *IncidentMutation) RemoveTagAssignmentIDs(ids ...uuid.UUID) {
	if m.removedtag_assignments == nil {
		m.removedtag_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tag_assignments, ids[i])
		m.removedtag_assignments[ids[i]] = struct{}{}
	}
}

// RemovedTagAssignments returns the removed IDs of the "tag_assignments" edge to the IncidentTag entity.
func (m *IncidentMutation) RemovedTagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedtag_assignments {
		ids = append(ids, id)
	}
	return
}

// TagAssignmentsIDs returns the "tag_assignments" edge IDs in the mutation.
func (m *IncidentMutation) TagAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.tag_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetTagAssignments resets all changes to the "tag_assignments" edge.
func (m *IncidentMutation) ResetTagAssignments() {
	m.tag_assignments = nil
	m.clearedtag_assignments = false
	m.removedtag_assignments = nil
}

// AddDebriefIDs adds the "debriefs" edge to the IncidentDebrief entity by ids.
func (m *IncidentMutation) AddDebriefIDs(ids ...uuid.UUID) {
	if m.debriefs == nil {
		m.debriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debriefs[ids[i]] = struct{}{}
	}
}

// ClearDebriefs clears the "debriefs" edge to the IncidentDebrief entity.
func (m *IncidentMutation) ClearDebriefs() {
	m.cleareddebriefs = true
}

// DebriefsCleared reports if the "debriefs" edge to the IncidentDebrief entity was cleared.
func (m *IncidentMutation) DebriefsCleared() bool {
	return m.cleareddebriefs
}

// RemoveDebriefIDs removes the "debriefs" edge to the IncidentDebrief entity by IDs.
func (m *IncidentMutation) RemoveDebriefIDs(ids ...uuid.UUID) {
	if m.removeddebriefs == nil {
		m.removeddebriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debriefs, ids[i])
		m.removeddebriefs[ids[i]] = struct{}{}
	}
}

// RemovedDebriefs returns the removed IDs of the "debriefs" edge to the IncidentDebrief entity.
func (m *IncidentMutation) RemovedDebriefsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebriefs {
		ids = append(ids, id)
	}
	return
}

// DebriefsIDs returns the "debriefs" edge IDs in the mutation.
func (m *IncidentMutation) DebriefsIDs() (ids []uuid.UUID) {
	for id := range m.debriefs {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefs resets all changes to the "debriefs" edge.
func (m *IncidentMutation) ResetDebriefs() {
	m.debriefs = nil
	m.cleareddebriefs = false
	m.removeddebriefs = nil
}

// AddReviewSessionIDs adds the "review_sessions" edge to the MeetingSession entity by ids.
func (m *IncidentMutation) AddReviewSessionIDs(ids ...uuid.UUID) {
	if m.review_sessions == nil {
		m.review_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.review_sessions[ids[i]] = struct{}{}
	}
}

// ClearReviewSessions clears the "review_sessions" edge to the MeetingSession entity.
func (m *IncidentMutation) ClearReviewSessions() {
	m.clearedreview_sessions = true
}

// ReviewSessionsCleared reports if the "review_sessions" edge to the MeetingSession entity was cleared.
func (m *IncidentMutation) ReviewSessionsCleared() bool {
	return m.clearedreview_sessions
}

// RemoveReviewSessionIDs removes the "review_sessions" edge to the MeetingSession entity by IDs.
func (m *IncidentMutation) RemoveReviewSessionIDs(ids ...uuid.UUID) {
	if m.removedreview_sessions == nil {
		m.removedreview_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.review_sessions, ids[i])
		m.removedreview_sessions[ids[i]] = struct{}{}
	}
}

// RemovedReviewSessions returns the removed IDs of the "review_sessions" edge to the MeetingSession entity.
func (m *IncidentMutation) RemovedReviewSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedreview_sessions {
		ids = append(ids, id)
	}
	return
}

// ReviewSessionsIDs returns the "review_sessions" edge IDs in the mutation.
func (m *IncidentMutation) ReviewSessionsIDs() (ids []uuid.UUID) {
	for id := range m.review_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetReviewSessions resets all changes to the "review_sessions" edge.
func (m *IncidentMutation) ResetReviewSessions() {
	m.review_sessions = nil
	m.clearedreview_sessions = false
	m.removedreview_sessions = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the IncidentRoleAssignment entity by ids.
func (m *IncidentMutation) AddUserRoleIDs(ids ...uuid.UUID) {
	if m.user_roles == nil {
		m.user_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the IncidentRoleAssignment entity.
func (m *IncidentMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the IncidentRoleAssignment entity was cleared.
func (m *IncidentMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the IncidentRoleAssignment entity by IDs.
func (m *IncidentMutation) RemoveUserRoleIDs(ids ...uuid.UUID) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the IncidentRoleAssignment entity.
func (m *IncidentMutation) RemovedUserRolesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *IncidentMutation) UserRolesIDs() (ids []uuid.UUID) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *IncidentMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddIncidentLinkIDs adds the "incident_links" edge to the IncidentLink entity by ids.
func (m *IncidentMutation) AddIncidentLinkIDs(ids ...int) {
	if m.incident_links == nil {
		m.incident_links = make(map[int]struct{})
	}
	for i := range ids {
		m.incident_links[ids[i]] = struct{}{}
	}
}

// ClearIncidentLinks clears the "incident_links" edge to the IncidentLink entity.
func (m *IncidentMutation) ClearIncidentLinks() {
	m.clearedincident_links = true
}

// IncidentLinksCleared reports if the "incident_links" edge to the IncidentLink entity was cleared.
func (m *IncidentMutation) IncidentLinksCleared() bool {
	return m.clearedincident_links
}

// RemoveIncidentLinkIDs removes the "incident_links" edge to the IncidentLink entity by IDs.
func (m *IncidentMutation) RemoveIncidentLinkIDs(ids ...int) {
	if m.removedincident_links == nil {
		m.removedincident_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.incident_links, ids[i])
		m.removedincident_links[ids[i]] = struct{}{}
	}
}

// RemovedIncidentLinks returns the removed IDs of the "incident_links" edge to the IncidentLink entity.
func (m *IncidentMutation) RemovedIncidentLinksIDs() (ids []int) {
	for id := range m.removedincident_links {
		ids = append(ids, id)
	}
	return
}

// IncidentLinksIDs returns the "incident_links" edge IDs in the mutation.
func (m *IncidentMutation) IncidentLinksIDs() (ids []int) {
	for id := range m.incident_links {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentLinks resets all changes to the "incident_links" edge.
func (m *IncidentMutation) ResetIncidentLinks() {
	m.incident_links = nil
	m.clearedincident_links = false
	m.removedincident_links = nil
}

// Where appends a list predicates to the IncidentMutation builder.
func (m *IncidentMutation) Where(ps ...predicate.Incident) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Incident, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Incident).
func (m *IncidentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant != nil {
		fields = append(fields, incident.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, incident.FieldExternalID)
	}
	if m.created_at != nil {
		fields = append(fields, incident.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incident.FieldUpdatedAt)
	}
	if m.slug != nil {
		fields = append(fields, incident.FieldSlug)
	}
	if m.title != nil {
		fields = append(fields, incident.FieldTitle)
	}
	if m.severity != nil {
		fields = append(fields, incident.FieldSeverityID)
	}
	if m._type != nil {
		fields = append(fields, incident.FieldTypeID)
	}
	if m.summary != nil {
		fields = append(fields, incident.FieldSummary)
	}
	if m.chat_channel_id != nil {
		fields = append(fields, incident.FieldChatChannelID)
	}
	if m.opened_at != nil {
		fields = append(fields, incident.FieldOpenedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldTenantID:
		return m.TenantID()
	case incident.FieldExternalID:
		return m.ExternalID()
	case incident.FieldCreatedAt:
		return m.CreatedAt()
	case incident.FieldUpdatedAt:
		return m.UpdatedAt()
	case incident.FieldSlug:
		return m.Slug()
	case incident.FieldTitle:
		return m.Title()
	case incident.FieldSeverityID:
		return m.SeverityID()
	case incident.FieldTypeID:
		return m.TypeID()
	case incident.FieldSummary:
		return m.Summary()
	case incident.FieldChatChannelID:
		return m.ChatChannelID()
	case incident.FieldOpenedAt:
		return m.OpenedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incident.FieldTenantID:
		return m.OldTenantID(ctx)
	case incident.FieldExternalID:
		return m.OldExternalID(ctx)
	case incident.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incident.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case incident.FieldSlug:
		return m.OldSlug(ctx)
	case incident.FieldTitle:
		return m.OldTitle(ctx)
	case incident.FieldSeverityID:
		return m.OldSeverityID(ctx)
	case incident.FieldTypeID:
		return m.OldTypeID(ctx)
	case incident.FieldSummary:
		return m.OldSummary(ctx)
	case incident.FieldChatChannelID:
		return m.OldChatChannelID(ctx)
	case incident.FieldOpenedAt:
		return m.OldOpenedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Incident field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incident.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incident.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case incident.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incident.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case incident.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case incident.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incident.FieldSeverityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverityID(v)
		return nil
	case incident.FieldTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	case incident.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case incident.FieldChatChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatChannelID(v)
		return nil
	case incident.FieldOpenedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Incident numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incident.FieldExternalID) {
		fields = append(fields, incident.FieldExternalID)
	}
	if m.FieldCleared(incident.FieldSummary) {
		fields = append(fields, incident.FieldSummary)
	}
	if m.FieldCleared(incident.FieldChatChannelID) {
		fields = append(fields, incident.FieldChatChannelID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMutation) ClearField(name string) error {
	switch name {
	case incident.FieldExternalID:
		m.ClearExternalID()
		return nil
	case incident.FieldSummary:
		m.ClearSummary()
		return nil
	case incident.FieldChatChannelID:
		m.ClearChatChannelID()
		return nil
	}
	return fmt.Errorf("unknown Incident nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMutation) ResetField(name string) error {
	switch name {
	case incident.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incident.FieldExternalID:
		m.ResetExternalID()
		return nil
	case incident.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incident.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case incident.FieldSlug:
		m.ResetSlug()
		return nil
	case incident.FieldTitle:
		m.ResetTitle()
		return nil
	case incident.FieldSeverityID:
		m.ResetSeverityID()
		return nil
	case incident.FieldTypeID:
		m.ResetTypeID()
		return nil
	case incident.FieldSummary:
		m.ResetSummary()
		return nil
	case incident.FieldChatChannelID:
		m.ResetChatChannelID()
		return nil
	case incident.FieldOpenedAt:
		m.ResetOpenedAt()
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.tenant != nil {
		edges = append(edges, incident.EdgeTenant)
	}
	if m.severity != nil {
		edges = append(edges, incident.EdgeSeverity)
	}
	if m._type != nil {
		edges = append(edges, incident.EdgeType)
	}
	if m.milestones != nil {
		edges = append(edges, incident.EdgeMilestones)
	}
	if m.events != nil {
		edges = append(edges, incident.EdgeEvents)
	}
	if m.retrospective != nil {
		edges = append(edges, incident.EdgeRetrospective)
	}
	if m.users != nil {
		edges = append(edges, incident.EdgeUsers)
	}
	if m.role_assignments != nil {
		edges = append(edges, incident.EdgeRoleAssignments)
	}
	if m.linked_incidents != nil {
		edges = append(edges, incident.EdgeLinkedIncidents)
	}
	if m.field_selections != nil {
		edges = append(edges, incident.EdgeFieldSelections)
	}
	if m.tasks != nil {
		edges = append(edges, incident.EdgeTasks)
	}
	if m.tag_assignments != nil {
		edges = append(edges, incident.EdgeTagAssignments)
	}
	if m.debriefs != nil {
		edges = append(edges, incident.EdgeDebriefs)
	}
	if m.review_sessions != nil {
		edges = append(edges, incident.EdgeReviewSessions)
	}
	if m.user_roles != nil {
		edges = append(edges, incident.EdgeUserRoles)
	}
	if m.incident_links != nil {
		edges = append(edges, incident.EdgeIncidentLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeSeverity:
		if id := m.severity; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.milestones))
		for id := range m.milestones {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	case incident.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.role_assignments))
		for id := range m.role_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeLinkedIncidents:
		ids := make([]ent.Value, 0, len(m.linked_incidents))
		for id := range m.linked_incidents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFieldSelections:
		ids := make([]ent.Value, 0, len(m.field_selections))
		for id := range m.field_selections {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTagAssignments:
		ids := make([]ent.Value, 0, len(m.tag_assignments))
		for id := range m.tag_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeDebriefs:
		ids := make([]ent.Value, 0, len(m.debriefs))
		for id := range m.debriefs {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeReviewSessions:
		ids := make([]ent.Value, 0, len(m.review_sessions))
		for id := range m.review_sessions {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentLinks:
		ids := make([]ent.Value, 0, len(m.incident_links))
		for id := range m.incident_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedmilestones != nil {
		edges = append(edges, incident.EdgeMilestones)
	}
	if m.removedevents != nil {
		edges = append(edges, incident.EdgeEvents)
	}
	if m.removedusers != nil {
		edges = append(edges, incident.EdgeUsers)
	}
	if m.removedrole_assignments != nil {
		edges = append(edges, incident.EdgeRoleAssignments)
	}
	if m.removedlinked_incidents != nil {
		edges = append(edges, incident.EdgeLinkedIncidents)
	}
	if m.removedfield_selections != nil {
		edges = append(edges, incident.EdgeFieldSelections)
	}
	if m.removedtasks != nil {
		edges = append(edges, incident.EdgeTasks)
	}
	if m.removedtag_assignments != nil {
		edges = append(edges, incident.EdgeTagAssignments)
	}
	if m.removeddebriefs != nil {
		edges = append(edges, incident.EdgeDebriefs)
	}
	if m.removedreview_sessions != nil {
		edges = append(edges, incident.EdgeReviewSessions)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, incident.EdgeUserRoles)
	}
	if m.removedincident_links != nil {
		edges = append(edges, incident.EdgeIncidentLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeMilestones:
		ids := make([]ent.Value, 0, len(m.removedmilestones))
		for id := range m.removedmilestones {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.removedrole_assignments))
		for id := range m.removedrole_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeLinkedIncidents:
		ids := make([]ent.Value, 0, len(m.removedlinked_incidents))
		for id := range m.removedlinked_incidents {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFieldSelections:
		ids := make([]ent.Value, 0, len(m.removedfield_selections))
		for id := range m.removedfield_selections {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeTagAssignments:
		ids := make([]ent.Value, 0, len(m.removedtag_assignments))
		for id := range m.removedtag_assignments {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeDebriefs:
		ids := make([]ent.Value, 0, len(m.removeddebriefs))
		for id := range m.removeddebriefs {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeReviewSessions:
		ids := make([]ent.Value, 0, len(m.removedreview_sessions))
		for id := range m.removedreview_sessions {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeIncidentLinks:
		ids := make([]ent.Value, 0, len(m.removedincident_links))
		for id := range m.removedincident_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedtenant {
		edges = append(edges, incident.EdgeTenant)
	}
	if m.clearedseverity {
		edges = append(edges, incident.EdgeSeverity)
	}
	if m.cleared_type {
		edges = append(edges, incident.EdgeType)
	}
	if m.clearedmilestones {
		edges = append(edges, incident.EdgeMilestones)
	}
	if m.clearedevents {
		edges = append(edges, incident.EdgeEvents)
	}
	if m.clearedretrospective {
		edges = append(edges, incident.EdgeRetrospective)
	}
	if m.clearedusers {
		edges = append(edges, incident.EdgeUsers)
	}
	if m.clearedrole_assignments {
		edges = append(edges, incident.EdgeRoleAssignments)
	}
	if m.clearedlinked_incidents {
		edges = append(edges, incident.EdgeLinkedIncidents)
	}
	if m.clearedfield_selections {
		edges = append(edges, incident.EdgeFieldSelections)
	}
	if m.clearedtasks {
		edges = append(edges, incident.EdgeTasks)
	}
	if m.clearedtag_assignments {
		edges = append(edges, incident.EdgeTagAssignments)
	}
	if m.cleareddebriefs {
		edges = append(edges, incident.EdgeDebriefs)
	}
	if m.clearedreview_sessions {
		edges = append(edges, incident.EdgeReviewSessions)
	}
	if m.cleareduser_roles {
		edges = append(edges, incident.EdgeUserRoles)
	}
	if m.clearedincident_links {
		edges = append(edges, incident.EdgeIncidentLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMutation) EdgeCleared(name string) bool {
	switch name {
	case incident.EdgeTenant:
		return m.clearedtenant
	case incident.EdgeSeverity:
		return m.clearedseverity
	case incident.EdgeType:
		return m.cleared_type
	case incident.EdgeMilestones:
		return m.clearedmilestones
	case incident.EdgeEvents:
		return m.clearedevents
	case incident.EdgeRetrospective:
		return m.clearedretrospective
	case incident.EdgeUsers:
		return m.clearedusers
	case incident.EdgeRoleAssignments:
		return m.clearedrole_assignments
	case incident.EdgeLinkedIncidents:
		return m.clearedlinked_incidents
	case incident.EdgeFieldSelections:
		return m.clearedfield_selections
	case incident.EdgeTasks:
		return m.clearedtasks
	case incident.EdgeTagAssignments:
		return m.clearedtag_assignments
	case incident.EdgeDebriefs:
		return m.cleareddebriefs
	case incident.EdgeReviewSessions:
		return m.clearedreview_sessions
	case incident.EdgeUserRoles:
		return m.cleareduser_roles
	case incident.EdgeIncidentLinks:
		return m.clearedincident_links
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMutation) ClearEdge(name string) error {
	switch name {
	case incident.EdgeTenant:
		m.ClearTenant()
		return nil
	case incident.EdgeSeverity:
		m.ClearSeverity()
		return nil
	case incident.EdgeType:
		m.ClearType()
		return nil
	case incident.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	}
	return fmt.Errorf("unknown Incident unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMutation) ResetEdge(name string) error {
	switch name {
	case incident.EdgeTenant:
		m.ResetTenant()
		return nil
	case incident.EdgeSeverity:
		m.ResetSeverity()
		return nil
	case incident.EdgeType:
		m.ResetType()
		return nil
	case incident.EdgeMilestones:
		m.ResetMilestones()
		return nil
	case incident.EdgeEvents:
		m.ResetEvents()
		return nil
	case incident.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	case incident.EdgeUsers:
		m.ResetUsers()
		return nil
	case incident.EdgeRoleAssignments:
		m.ResetRoleAssignments()
		return nil
	case incident.EdgeLinkedIncidents:
		m.ResetLinkedIncidents()
		return nil
	case incident.EdgeFieldSelections:
		m.ResetFieldSelections()
		return nil
	case incident.EdgeTasks:
		m.ResetTasks()
		return nil
	case incident.EdgeTagAssignments:
		m.ResetTagAssignments()
		return nil
	case incident.EdgeDebriefs:
		m.ResetDebriefs()
		return nil
	case incident.EdgeReviewSessions:
		m.ResetReviewSessions()
		return nil
	case incident.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case incident.EdgeIncidentLinks:
		m.ResetIncidentLinks()
		return nil
	}
	return fmt.Errorf("unknown Incident edge %s", name)
}

// IncidentDebriefMutation represents an operation that mutates the IncidentDebrief nodes in the graph.
type IncidentDebriefMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	required           *bool
	started            *bool
	clearedFields      map[string]struct{}
	tenant             *int
	clearedtenant      bool
	incident           *uuid.UUID
	clearedincident    bool
	user               *uuid.UUID
	cleareduser        bool
	messages           map[uuid.UUID]struct{}
	removedmessages    map[uuid.UUID]struct{}
	clearedmessages    bool
	suggestions        map[uuid.UUID]struct{}
	removedsuggestions map[uuid.UUID]struct{}
	clearedsuggestions bool
	done               bool
	oldValue           func(context.Context) (*IncidentDebrief, error)
	predicates         []predicate.IncidentDebrief
}

var _ ent.Mutation = (*IncidentDebriefMutation)(nil)

// incidentdebriefOption allows management of the mutation configuration using functional options.
type incidentdebriefOption func(*IncidentDebriefMutation)

// newIncidentDebriefMutation creates new mutation for the IncidentDebrief entity.
func newIncidentDebriefMutation(c config, op Op, opts ...incidentdebriefOption) *IncidentDebriefMutation {
	m := &IncidentDebriefMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebrief,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefID sets the ID field of the mutation.
func withIncidentDebriefID(id uuid.UUID) incidentdebriefOption {
	return func(m *IncidentDebriefMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebrief
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebrief, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebrief.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebrief sets the old IncidentDebrief of the mutation.
func withIncidentDebrief(node *IncidentDebrief) incidentdebriefOption {
	return func(m *IncidentDebriefMutation) {
		m.oldValue = func(context.Context) (*IncidentDebrief, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebrief entities.
func (m *IncidentDebriefMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebrief.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentDebriefMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentDebriefMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentDebriefMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentDebriefMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentDebriefMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentDebriefMutation) ResetIncidentID() {
	m.incident = nil
}

// SetUserID sets the "user_id" field.
func (m *IncidentDebriefMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IncidentDebriefMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IncidentDebriefMutation) ResetUserID() {
	m.user = nil
}

// SetRequired sets the "required" field.
func (m *IncidentDebriefMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *IncidentDebriefMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *IncidentDebriefMutation) ResetRequired() {
	m.required = nil
}

// SetStarted sets the "started" field.
func (m *IncidentDebriefMutation) SetStarted(b bool) {
	m.started = &b
}

// Started returns the value of the "started" field in the mutation.
func (m *IncidentDebriefMutation) Started() (r bool, exists bool) {
	v := m.started
	if v == nil {
		return
	}
	return *v, true
}

// OldStarted returns the old "started" field's value of the IncidentDebrief entity.
// If the IncidentDebrief object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMutation) OldStarted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarted: %w", err)
	}
	return oldValue.Started, nil
}

// ResetStarted resets all changes to the "started" field.
func (m *IncidentDebriefMutation) ResetStarted() {
	m.started = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentDebriefMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentdebrief.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentDebriefMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentDebriefMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentDebriefMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentdebrief.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentDebriefMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentDebriefMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *IncidentDebriefMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[incidentdebrief.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IncidentDebriefMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IncidentDebriefMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMessageIDs adds the "messages" edge to the IncidentDebriefMessage entity by ids.
func (m *IncidentDebriefMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the IncidentDebriefMessage entity was cleared.
func (m *IncidentDebriefMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the IncidentDebriefMessage entity by IDs.
func (m *IncidentDebriefMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *IncidentDebriefMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *IncidentDebriefMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddSuggestionIDs adds the "suggestions" edge to the IncidentDebriefSuggestion entity by ids.
func (m *IncidentDebriefMutation) AddSuggestionIDs(ids ...uuid.UUID) {
	if m.suggestions == nil {
		m.suggestions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.suggestions[ids[i]] = struct{}{}
	}
}

// ClearSuggestions clears the "suggestions" edge to the IncidentDebriefSuggestion entity.
func (m *IncidentDebriefMutation) ClearSuggestions() {
	m.clearedsuggestions = true
}

// SuggestionsCleared reports if the "suggestions" edge to the IncidentDebriefSuggestion entity was cleared.
func (m *IncidentDebriefMutation) SuggestionsCleared() bool {
	return m.clearedsuggestions
}

// RemoveSuggestionIDs removes the "suggestions" edge to the IncidentDebriefSuggestion entity by IDs.
func (m *IncidentDebriefMutation) RemoveSuggestionIDs(ids ...uuid.UUID) {
	if m.removedsuggestions == nil {
		m.removedsuggestions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.suggestions, ids[i])
		m.removedsuggestions[ids[i]] = struct{}{}
	}
}

// RemovedSuggestions returns the removed IDs of the "suggestions" edge to the IncidentDebriefSuggestion entity.
func (m *IncidentDebriefMutation) RemovedSuggestionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsuggestions {
		ids = append(ids, id)
	}
	return
}

// SuggestionsIDs returns the "suggestions" edge IDs in the mutation.
func (m *IncidentDebriefMutation) SuggestionsIDs() (ids []uuid.UUID) {
	for id := range m.suggestions {
		ids = append(ids, id)
	}
	return
}

// ResetSuggestions resets all changes to the "suggestions" edge.
func (m *IncidentDebriefMutation) ResetSuggestions() {
	m.suggestions = nil
	m.clearedsuggestions = false
	m.removedsuggestions = nil
}

// Where appends a list predicates to the IncidentDebriefMutation builder.
func (m *IncidentDebriefMutation) Where(ps ...predicate.IncidentDebrief) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebrief, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebrief).
func (m *IncidentDebriefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, incidentdebrief.FieldTenantID)
	}
	if m.incident != nil {
		fields = append(fields, incidentdebrief.FieldIncidentID)
	}
	if m.user != nil {
		fields = append(fields, incidentdebrief.FieldUserID)
	}
	if m.required != nil {
		fields = append(fields, incidentdebrief.FieldRequired)
	}
	if m.started != nil {
		fields = append(fields, incidentdebrief.FieldStarted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebrief.FieldTenantID:
		return m.TenantID()
	case incidentdebrief.FieldIncidentID:
		return m.IncidentID()
	case incidentdebrief.FieldUserID:
		return m.UserID()
	case incidentdebrief.FieldRequired:
		return m.Required()
	case incidentdebrief.FieldStarted:
		return m.Started()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebrief.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentdebrief.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentdebrief.FieldUserID:
		return m.OldUserID(ctx)
	case incidentdebrief.FieldRequired:
		return m.OldRequired(ctx)
	case incidentdebrief.FieldStarted:
		return m.OldStarted(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebrief field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebrief.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentdebrief.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentdebrief.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case incidentdebrief.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case incidentdebrief.FieldStarted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarted(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebrief numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentDebrief nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefMutation) ResetField(name string) error {
	switch name {
	case incidentdebrief.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentdebrief.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentdebrief.FieldUserID:
		m.ResetUserID()
		return nil
	case incidentdebrief.FieldRequired:
		m.ResetRequired()
		return nil
	case incidentdebrief.FieldStarted:
		m.ResetStarted()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, incidentdebrief.EdgeTenant)
	}
	if m.incident != nil {
		edges = append(edges, incidentdebrief.EdgeIncident)
	}
	if m.user != nil {
		edges = append(edges, incidentdebrief.EdgeUser)
	}
	if m.messages != nil {
		edges = append(edges, incidentdebrief.EdgeMessages)
	}
	if m.suggestions != nil {
		edges = append(edges, incidentdebrief.EdgeSuggestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebrief.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebrief.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebrief.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebrief.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebrief.EdgeSuggestions:
		ids := make([]ent.Value, 0, len(m.suggestions))
		for id := range m.suggestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmessages != nil {
		edges = append(edges, incidentdebrief.EdgeMessages)
	}
	if m.removedsuggestions != nil {
		edges = append(edges, incidentdebrief.EdgeSuggestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentdebrief.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebrief.EdgeSuggestions:
		ids := make([]ent.Value, 0, len(m.removedsuggestions))
		for id := range m.removedsuggestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, incidentdebrief.EdgeTenant)
	}
	if m.clearedincident {
		edges = append(edges, incidentdebrief.EdgeIncident)
	}
	if m.cleareduser {
		edges = append(edges, incidentdebrief.EdgeUser)
	}
	if m.clearedmessages {
		edges = append(edges, incidentdebrief.EdgeMessages)
	}
	if m.clearedsuggestions {
		edges = append(edges, incidentdebrief.EdgeSuggestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebrief.EdgeTenant:
		return m.clearedtenant
	case incidentdebrief.EdgeIncident:
		return m.clearedincident
	case incidentdebrief.EdgeUser:
		return m.cleareduser
	case incidentdebrief.EdgeMessages:
		return m.clearedmessages
	case incidentdebrief.EdgeSuggestions:
		return m.clearedsuggestions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefMutation) ClearEdge(name string) error {
	switch name {
	case incidentdebrief.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentdebrief.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentdebrief.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebrief.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentdebrief.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentdebrief.EdgeUser:
		m.ResetUser()
		return nil
	case incidentdebrief.EdgeMessages:
		m.ResetMessages()
		return nil
	case incidentdebrief.EdgeSuggestions:
		m.ResetSuggestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebrief edge %s", name)
}

// IncidentDebriefMessageMutation represents an operation that mutates the IncidentDebriefMessage nodes in the graph.
type IncidentDebriefMessageMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	_type                *incidentdebriefmessage.Type
	requested_tool       *incidentdebriefmessage.RequestedTool
	body                 *string
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	debrief              *uuid.UUID
	cleareddebrief       bool
	from_question        *uuid.UUID
	clearedfrom_question bool
	done                 bool
	oldValue             func(context.Context) (*IncidentDebriefMessage, error)
	predicates           []predicate.IncidentDebriefMessage
}

var _ ent.Mutation = (*IncidentDebriefMessageMutation)(nil)

// incidentdebriefmessageOption allows management of the mutation configuration using functional options.
type incidentdebriefmessageOption func(*IncidentDebriefMessageMutation)

// newIncidentDebriefMessageMutation creates new mutation for the IncidentDebriefMessage entity.
func newIncidentDebriefMessageMutation(c config, op Op, opts ...incidentdebriefmessageOption) *IncidentDebriefMessageMutation {
	m := &IncidentDebriefMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebriefMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefMessageID sets the ID field of the mutation.
func withIncidentDebriefMessageID(id uuid.UUID) incidentdebriefmessageOption {
	return func(m *IncidentDebriefMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebriefMessage
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebriefMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebriefMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebriefMessage sets the old IncidentDebriefMessage of the mutation.
func withIncidentDebriefMessage(node *IncidentDebriefMessage) incidentdebriefmessageOption {
	return func(m *IncidentDebriefMessageMutation) {
		m.oldValue = func(context.Context) (*IncidentDebriefMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebriefMessage entities.
func (m *IncidentDebriefMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebriefMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentDebriefMessageMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentDebriefMessageMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentDebriefMessageMutation) ResetTenantID() {
	m.tenant = nil
}

// SetDebriefID sets the "debrief_id" field.
func (m *IncidentDebriefMessageMutation) SetDebriefID(u uuid.UUID) {
	m.debrief = &u
}

// DebriefID returns the value of the "debrief_id" field in the mutation.
func (m *IncidentDebriefMessageMutation) DebriefID() (r uuid.UUID, exists bool) {
	v := m.debrief
	if v == nil {
		return
	}
	return *v, true
}

// OldDebriefID returns the old "debrief_id" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldDebriefID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebriefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebriefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebriefID: %w", err)
	}
	return oldValue.DebriefID, nil
}

// ResetDebriefID resets all changes to the "debrief_id" field.
func (m *IncidentDebriefMessageMutation) ResetDebriefID() {
	m.debrief = nil
}

// SetQuestionID sets the "question_id" field.
func (m *IncidentDebriefMessageMutation) SetQuestionID(u uuid.UUID) {
	m.from_question = &u
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *IncidentDebriefMessageMutation) QuestionID() (r uuid.UUID, exists bool) {
	v := m.from_question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldQuestionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *IncidentDebriefMessageMutation) ClearQuestionID() {
	m.from_question = nil
	m.clearedFields[incidentdebriefmessage.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *IncidentDebriefMessageMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[incidentdebriefmessage.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *IncidentDebriefMessageMutation) ResetQuestionID() {
	m.from_question = nil
	delete(m.clearedFields, incidentdebriefmessage.FieldQuestionID)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentDebriefMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentDebriefMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentDebriefMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetType sets the "type" field.
func (m *IncidentDebriefMessageMutation) SetType(i incidentdebriefmessage.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncidentDebriefMessageMutation) GetType() (r incidentdebriefmessage.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldType(ctx context.Context) (v incidentdebriefmessage.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncidentDebriefMessageMutation) ResetType() {
	m._type = nil
}

// SetRequestedTool sets the "requested_tool" field.
func (m *IncidentDebriefMessageMutation) SetRequestedTool(it incidentdebriefmessage.RequestedTool) {
	m.requested_tool = &it
}

// RequestedTool returns the value of the "requested_tool" field in the mutation.
func (m *IncidentDebriefMessageMutation) RequestedTool() (r incidentdebriefmessage.RequestedTool, exists bool) {
	v := m.requested_tool
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedTool returns the old "requested_tool" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldRequestedTool(ctx context.Context) (v incidentdebriefmessage.RequestedTool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedTool: %w", err)
	}
	return oldValue.RequestedTool, nil
}

// ClearRequestedTool clears the value of the "requested_tool" field.
func (m *IncidentDebriefMessageMutation) ClearRequestedTool() {
	m.requested_tool = nil
	m.clearedFields[incidentdebriefmessage.FieldRequestedTool] = struct{}{}
}

// RequestedToolCleared returns if the "requested_tool" field was cleared in this mutation.
func (m *IncidentDebriefMessageMutation) RequestedToolCleared() bool {
	_, ok := m.clearedFields[incidentdebriefmessage.FieldRequestedTool]
	return ok
}

// ResetRequestedTool resets all changes to the "requested_tool" field.
func (m *IncidentDebriefMessageMutation) ResetRequestedTool() {
	m.requested_tool = nil
	delete(m.clearedFields, incidentdebriefmessage.FieldRequestedTool)
}

// SetBody sets the "body" field.
func (m *IncidentDebriefMessageMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *IncidentDebriefMessageMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the IncidentDebriefMessage entity.
// If the IncidentDebriefMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefMessageMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *IncidentDebriefMessageMutation) ResetBody() {
	m.body = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentDebriefMessageMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentdebriefmessage.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentDebriefMessageMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMessageMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentDebriefMessageMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearDebrief clears the "debrief" edge to the IncidentDebrief entity.
func (m *IncidentDebriefMessageMutation) ClearDebrief() {
	m.cleareddebrief = true
	m.clearedFields[incidentdebriefmessage.FieldDebriefID] = struct{}{}
}

// DebriefCleared reports if the "debrief" edge to the IncidentDebrief entity was cleared.
func (m *IncidentDebriefMessageMutation) DebriefCleared() bool {
	return m.cleareddebrief
}

// DebriefIDs returns the "debrief" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DebriefID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMessageMutation) DebriefIDs() (ids []uuid.UUID) {
	if id := m.debrief; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDebrief resets all changes to the "debrief" edge.
func (m *IncidentDebriefMessageMutation) ResetDebrief() {
	m.debrief = nil
	m.cleareddebrief = false
}

// SetFromQuestionID sets the "from_question" edge to the IncidentDebriefQuestion entity by id.
func (m *IncidentDebriefMessageMutation) SetFromQuestionID(id uuid.UUID) {
	m.from_question = &id
}

// ClearFromQuestion clears the "from_question" edge to the IncidentDebriefQuestion entity.
func (m *IncidentDebriefMessageMutation) ClearFromQuestion() {
	m.clearedfrom_question = true
	m.clearedFields[incidentdebriefmessage.FieldQuestionID] = struct{}{}
}

// FromQuestionCleared reports if the "from_question" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentDebriefMessageMutation) FromQuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedfrom_question
}

// FromQuestionID returns the "from_question" edge ID in the mutation.
func (m *IncidentDebriefMessageMutation) FromQuestionID() (id uuid.UUID, exists bool) {
	if m.from_question != nil {
		return *m.from_question, true
	}
	return
}

// FromQuestionIDs returns the "from_question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromQuestionID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefMessageMutation) FromQuestionIDs() (ids []uuid.UUID) {
	if id := m.from_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromQuestion resets all changes to the "from_question" edge.
func (m *IncidentDebriefMessageMutation) ResetFromQuestion() {
	m.from_question = nil
	m.clearedfrom_question = false
}

// Where appends a list predicates to the IncidentDebriefMessageMutation builder.
func (m *IncidentDebriefMessageMutation) Where(ps ...predicate.IncidentDebriefMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebriefMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebriefMessage).
func (m *IncidentDebriefMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefMessageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, incidentdebriefmessage.FieldTenantID)
	}
	if m.debrief != nil {
		fields = append(fields, incidentdebriefmessage.FieldDebriefID)
	}
	if m.from_question != nil {
		fields = append(fields, incidentdebriefmessage.FieldQuestionID)
	}
	if m.created_at != nil {
		fields = append(fields, incidentdebriefmessage.FieldCreatedAt)
	}
	if m._type != nil {
		fields = append(fields, incidentdebriefmessage.FieldType)
	}
	if m.requested_tool != nil {
		fields = append(fields, incidentdebriefmessage.FieldRequestedTool)
	}
	if m.body != nil {
		fields = append(fields, incidentdebriefmessage.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebriefmessage.FieldTenantID:
		return m.TenantID()
	case incidentdebriefmessage.FieldDebriefID:
		return m.DebriefID()
	case incidentdebriefmessage.FieldQuestionID:
		return m.QuestionID()
	case incidentdebriefmessage.FieldCreatedAt:
		return m.CreatedAt()
	case incidentdebriefmessage.FieldType:
		return m.GetType()
	case incidentdebriefmessage.FieldRequestedTool:
		return m.RequestedTool()
	case incidentdebriefmessage.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebriefmessage.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentdebriefmessage.FieldDebriefID:
		return m.OldDebriefID(ctx)
	case incidentdebriefmessage.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case incidentdebriefmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentdebriefmessage.FieldType:
		return m.OldType(ctx)
	case incidentdebriefmessage.FieldRequestedTool:
		return m.OldRequestedTool(ctx)
	case incidentdebriefmessage.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebriefMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebriefmessage.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentdebriefmessage.FieldDebriefID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebriefID(v)
		return nil
	case incidentdebriefmessage.FieldQuestionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case incidentdebriefmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentdebriefmessage.FieldType:
		v, ok := value.(incidentdebriefmessage.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incidentdebriefmessage.FieldRequestedTool:
		v, ok := value.(incidentdebriefmessage.RequestedTool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedTool(v)
		return nil
	case incidentdebriefmessage.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefMessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebriefMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentdebriefmessage.FieldQuestionID) {
		fields = append(fields, incidentdebriefmessage.FieldQuestionID)
	}
	if m.FieldCleared(incidentdebriefmessage.FieldRequestedTool) {
		fields = append(fields, incidentdebriefmessage.FieldRequestedTool)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ClearField(name string) error {
	switch name {
	case incidentdebriefmessage.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	case incidentdebriefmessage.FieldRequestedTool:
		m.ClearRequestedTool()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ResetField(name string) error {
	switch name {
	case incidentdebriefmessage.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentdebriefmessage.FieldDebriefID:
		m.ResetDebriefID()
		return nil
	case incidentdebriefmessage.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case incidentdebriefmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentdebriefmessage.FieldType:
		m.ResetType()
		return nil
	case incidentdebriefmessage.FieldRequestedTool:
		m.ResetRequestedTool()
		return nil
	case incidentdebriefmessage.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidentdebriefmessage.EdgeTenant)
	}
	if m.debrief != nil {
		edges = append(edges, incidentdebriefmessage.EdgeDebrief)
	}
	if m.from_question != nil {
		edges = append(edges, incidentdebriefmessage.EdgeFromQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefmessage.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebriefmessage.EdgeDebrief:
		if id := m.debrief; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebriefmessage.EdgeFromQuestion:
		if id := m.from_question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidentdebriefmessage.EdgeTenant)
	}
	if m.cleareddebrief {
		edges = append(edges, incidentdebriefmessage.EdgeDebrief)
	}
	if m.clearedfrom_question {
		edges = append(edges, incidentdebriefmessage.EdgeFromQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebriefmessage.EdgeTenant:
		return m.clearedtenant
	case incidentdebriefmessage.EdgeDebrief:
		return m.cleareddebrief
	case incidentdebriefmessage.EdgeFromQuestion:
		return m.clearedfrom_question
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ClearEdge(name string) error {
	switch name {
	case incidentdebriefmessage.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentdebriefmessage.EdgeDebrief:
		m.ClearDebrief()
		return nil
	case incidentdebriefmessage.EdgeFromQuestion:
		m.ClearFromQuestion()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefMessageMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebriefmessage.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentdebriefmessage.EdgeDebrief:
		m.ResetDebrief()
		return nil
	case incidentdebriefmessage.EdgeFromQuestion:
		m.ResetFromQuestion()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefMessage edge %s", name)
}

// IncidentDebriefQuestionMutation represents an operation that mutates the IncidentDebriefQuestion nodes in the graph.
type IncidentDebriefQuestionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	content                    *string
	clearedFields              map[string]struct{}
	tenant                     *int
	clearedtenant              bool
	messages                   map[uuid.UUID]struct{}
	removedmessages            map[uuid.UUID]struct{}
	clearedmessages            bool
	incident_fields            map[uuid.UUID]struct{}
	removedincident_fields     map[uuid.UUID]struct{}
	clearedincident_fields     bool
	incident_roles             map[uuid.UUID]struct{}
	removedincident_roles      map[uuid.UUID]struct{}
	clearedincident_roles      bool
	incident_severities        map[uuid.UUID]struct{}
	removedincident_severities map[uuid.UUID]struct{}
	clearedincident_severities bool
	incident_tags              map[uuid.UUID]struct{}
	removedincident_tags       map[uuid.UUID]struct{}
	clearedincident_tags       bool
	incident_types             map[uuid.UUID]struct{}
	removedincident_types      map[uuid.UUID]struct{}
	clearedincident_types      bool
	done                       bool
	oldValue                   func(context.Context) (*IncidentDebriefQuestion, error)
	predicates                 []predicate.IncidentDebriefQuestion
}

var _ ent.Mutation = (*IncidentDebriefQuestionMutation)(nil)

// incidentdebriefquestionOption allows management of the mutation configuration using functional options.
type incidentdebriefquestionOption func(*IncidentDebriefQuestionMutation)

// newIncidentDebriefQuestionMutation creates new mutation for the IncidentDebriefQuestion entity.
func newIncidentDebriefQuestionMutation(c config, op Op, opts ...incidentdebriefquestionOption) *IncidentDebriefQuestionMutation {
	m := &IncidentDebriefQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebriefQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefQuestionID sets the ID field of the mutation.
func withIncidentDebriefQuestionID(id uuid.UUID) incidentdebriefquestionOption {
	return func(m *IncidentDebriefQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebriefQuestion
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebriefQuestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebriefQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebriefQuestion sets the old IncidentDebriefQuestion of the mutation.
func withIncidentDebriefQuestion(node *IncidentDebriefQuestion) incidentdebriefquestionOption {
	return func(m *IncidentDebriefQuestionMutation) {
		m.oldValue = func(context.Context) (*IncidentDebriefQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebriefQuestion entities.
func (m *IncidentDebriefQuestionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefQuestionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefQuestionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebriefQuestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentDebriefQuestionMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentDebriefQuestionMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentDebriefQuestion entity.
// If the IncidentDebriefQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefQuestionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentDebriefQuestionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetContent sets the "content" field.
func (m *IncidentDebriefQuestionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *IncidentDebriefQuestionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the IncidentDebriefQuestion entity.
// If the IncidentDebriefQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefQuestionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *IncidentDebriefQuestionMutation) ResetContent() {
	m.content = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentDebriefQuestionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentdebriefquestion.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentDebriefQuestionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefQuestionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentDebriefQuestionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddMessageIDs adds the "messages" edge to the IncidentDebriefMessage entity by ids.
func (m *IncidentDebriefQuestionMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefQuestionMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the IncidentDebriefMessage entity was cleared.
func (m *IncidentDebriefQuestionMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the IncidentDebriefMessage entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the IncidentDebriefMessage entity.
func (m *IncidentDebriefQuestionMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *IncidentDebriefQuestionMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddIncidentFieldIDs adds the "incident_fields" edge to the IncidentField entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentFieldIDs(ids ...uuid.UUID) {
	if m.incident_fields == nil {
		m.incident_fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_fields[ids[i]] = struct{}{}
	}
}

// ClearIncidentFields clears the "incident_fields" edge to the IncidentField entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentFields() {
	m.clearedincident_fields = true
}

// IncidentFieldsCleared reports if the "incident_fields" edge to the IncidentField entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentFieldsCleared() bool {
	return m.clearedincident_fields
}

// RemoveIncidentFieldIDs removes the "incident_fields" edge to the IncidentField entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentFieldIDs(ids ...uuid.UUID) {
	if m.removedincident_fields == nil {
		m.removedincident_fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_fields, ids[i])
		m.removedincident_fields[ids[i]] = struct{}{}
	}
}

// RemovedIncidentFields returns the removed IDs of the "incident_fields" edge to the IncidentField entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_fields {
		ids = append(ids, id)
	}
	return
}

// IncidentFieldsIDs returns the "incident_fields" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentFieldsIDs() (ids []uuid.UUID) {
	for id := range m.incident_fields {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentFields resets all changes to the "incident_fields" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentFields() {
	m.incident_fields = nil
	m.clearedincident_fields = false
	m.removedincident_fields = nil
}

// AddIncidentRoleIDs adds the "incident_roles" edge to the IncidentRole entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentRoleIDs(ids ...uuid.UUID) {
	if m.incident_roles == nil {
		m.incident_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_roles[ids[i]] = struct{}{}
	}
}

// ClearIncidentRoles clears the "incident_roles" edge to the IncidentRole entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentRoles() {
	m.clearedincident_roles = true
}

// IncidentRolesCleared reports if the "incident_roles" edge to the IncidentRole entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentRolesCleared() bool {
	return m.clearedincident_roles
}

// RemoveIncidentRoleIDs removes the "incident_roles" edge to the IncidentRole entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentRoleIDs(ids ...uuid.UUID) {
	if m.removedincident_roles == nil {
		m.removedincident_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_roles, ids[i])
		m.removedincident_roles[ids[i]] = struct{}{}
	}
}

// RemovedIncidentRoles returns the removed IDs of the "incident_roles" edge to the IncidentRole entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_roles {
		ids = append(ids, id)
	}
	return
}

// IncidentRolesIDs returns the "incident_roles" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentRolesIDs() (ids []uuid.UUID) {
	for id := range m.incident_roles {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentRoles resets all changes to the "incident_roles" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentRoles() {
	m.incident_roles = nil
	m.clearedincident_roles = false
	m.removedincident_roles = nil
}

// AddIncidentSeverityIDs adds the "incident_severities" edge to the IncidentSeverity entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentSeverityIDs(ids ...uuid.UUID) {
	if m.incident_severities == nil {
		m.incident_severities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_severities[ids[i]] = struct{}{}
	}
}

// ClearIncidentSeverities clears the "incident_severities" edge to the IncidentSeverity entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentSeverities() {
	m.clearedincident_severities = true
}

// IncidentSeveritiesCleared reports if the "incident_severities" edge to the IncidentSeverity entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentSeveritiesCleared() bool {
	return m.clearedincident_severities
}

// RemoveIncidentSeverityIDs removes the "incident_severities" edge to the IncidentSeverity entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentSeverityIDs(ids ...uuid.UUID) {
	if m.removedincident_severities == nil {
		m.removedincident_severities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_severities, ids[i])
		m.removedincident_severities[ids[i]] = struct{}{}
	}
}

// RemovedIncidentSeverities returns the removed IDs of the "incident_severities" edge to the IncidentSeverity entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentSeveritiesIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_severities {
		ids = append(ids, id)
	}
	return
}

// IncidentSeveritiesIDs returns the "incident_severities" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentSeveritiesIDs() (ids []uuid.UUID) {
	for id := range m.incident_severities {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentSeverities resets all changes to the "incident_severities" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentSeverities() {
	m.incident_severities = nil
	m.clearedincident_severities = false
	m.removedincident_severities = nil
}

// AddIncidentTagIDs adds the "incident_tags" edge to the IncidentTag entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentTagIDs(ids ...uuid.UUID) {
	if m.incident_tags == nil {
		m.incident_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_tags[ids[i]] = struct{}{}
	}
}

// ClearIncidentTags clears the "incident_tags" edge to the IncidentTag entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentTags() {
	m.clearedincident_tags = true
}

// IncidentTagsCleared reports if the "incident_tags" edge to the IncidentTag entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentTagsCleared() bool {
	return m.clearedincident_tags
}

// RemoveIncidentTagIDs removes the "incident_tags" edge to the IncidentTag entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentTagIDs(ids ...uuid.UUID) {
	if m.removedincident_tags == nil {
		m.removedincident_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_tags, ids[i])
		m.removedincident_tags[ids[i]] = struct{}{}
	}
}

// RemovedIncidentTags returns the removed IDs of the "incident_tags" edge to the IncidentTag entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_tags {
		ids = append(ids, id)
	}
	return
}

// IncidentTagsIDs returns the "incident_tags" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentTagsIDs() (ids []uuid.UUID) {
	for id := range m.incident_tags {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentTags resets all changes to the "incident_tags" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentTags() {
	m.incident_tags = nil
	m.clearedincident_tags = false
	m.removedincident_tags = nil
}

// AddIncidentTypeIDs adds the "incident_types" edge to the IncidentType entity by ids.
func (m *IncidentDebriefQuestionMutation) AddIncidentTypeIDs(ids ...uuid.UUID) {
	if m.incident_types == nil {
		m.incident_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_types[ids[i]] = struct{}{}
	}
}

// ClearIncidentTypes clears the "incident_types" edge to the IncidentType entity.
func (m *IncidentDebriefQuestionMutation) ClearIncidentTypes() {
	m.clearedincident_types = true
}

// IncidentTypesCleared reports if the "incident_types" edge to the IncidentType entity was cleared.
func (m *IncidentDebriefQuestionMutation) IncidentTypesCleared() bool {
	return m.clearedincident_types
}

// RemoveIncidentTypeIDs removes the "incident_types" edge to the IncidentType entity by IDs.
func (m *IncidentDebriefQuestionMutation) RemoveIncidentTypeIDs(ids ...uuid.UUID) {
	if m.removedincident_types == nil {
		m.removedincident_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_types, ids[i])
		m.removedincident_types[ids[i]] = struct{}{}
	}
}

// RemovedIncidentTypes returns the removed IDs of the "incident_types" edge to the IncidentType entity.
func (m *IncidentDebriefQuestionMutation) RemovedIncidentTypesIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_types {
		ids = append(ids, id)
	}
	return
}

// IncidentTypesIDs returns the "incident_types" edge IDs in the mutation.
func (m *IncidentDebriefQuestionMutation) IncidentTypesIDs() (ids []uuid.UUID) {
	for id := range m.incident_types {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentTypes resets all changes to the "incident_types" edge.
func (m *IncidentDebriefQuestionMutation) ResetIncidentTypes() {
	m.incident_types = nil
	m.clearedincident_types = false
	m.removedincident_types = nil
}

// Where appends a list predicates to the IncidentDebriefQuestionMutation builder.
func (m *IncidentDebriefQuestionMutation) Where(ps ...predicate.IncidentDebriefQuestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefQuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefQuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebriefQuestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefQuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefQuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebriefQuestion).
func (m *IncidentDebriefQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefQuestionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, incidentdebriefquestion.FieldTenantID)
	}
	if m.content != nil {
		fields = append(fields, incidentdebriefquestion.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebriefquestion.FieldTenantID:
		return m.TenantID()
	case incidentdebriefquestion.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebriefquestion.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentdebriefquestion.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebriefQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebriefquestion.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentdebriefquestion.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefQuestionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefQuestionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentDebriefQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ResetField(name string) error {
	switch name {
	case incidentdebriefquestion.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentdebriefquestion.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.tenant != nil {
		edges = append(edges, incidentdebriefquestion.EdgeTenant)
	}
	if m.messages != nil {
		edges = append(edges, incidentdebriefquestion.EdgeMessages)
	}
	if m.incident_fields != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentFields)
	}
	if m.incident_roles != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentRoles)
	}
	if m.incident_severities != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentSeverities)
	}
	if m.incident_tags != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTags)
	}
	if m.incident_types != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefquestion.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebriefquestion.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentFields:
		ids := make([]ent.Value, 0, len(m.incident_fields))
		for id := range m.incident_fields {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentRoles:
		ids := make([]ent.Value, 0, len(m.incident_roles))
		for id := range m.incident_roles {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentSeverities:
		ids := make([]ent.Value, 0, len(m.incident_severities))
		for id := range m.incident_severities {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTags:
		ids := make([]ent.Value, 0, len(m.incident_tags))
		for id := range m.incident_tags {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTypes:
		ids := make([]ent.Value, 0, len(m.incident_types))
		for id := range m.incident_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmessages != nil {
		edges = append(edges, incidentdebriefquestion.EdgeMessages)
	}
	if m.removedincident_fields != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentFields)
	}
	if m.removedincident_roles != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentRoles)
	}
	if m.removedincident_severities != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentSeverities)
	}
	if m.removedincident_tags != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTags)
	}
	if m.removedincident_types != nil {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefquestion.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentFields:
		ids := make([]ent.Value, 0, len(m.removedincident_fields))
		for id := range m.removedincident_fields {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentRoles:
		ids := make([]ent.Value, 0, len(m.removedincident_roles))
		for id := range m.removedincident_roles {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentSeverities:
		ids := make([]ent.Value, 0, len(m.removedincident_severities))
		for id := range m.removedincident_severities {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTags:
		ids := make([]ent.Value, 0, len(m.removedincident_tags))
		for id := range m.removedincident_tags {
			ids = append(ids, id)
		}
		return ids
	case incidentdebriefquestion.EdgeIncidentTypes:
		ids := make([]ent.Value, 0, len(m.removedincident_types))
		for id := range m.removedincident_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedtenant {
		edges = append(edges, incidentdebriefquestion.EdgeTenant)
	}
	if m.clearedmessages {
		edges = append(edges, incidentdebriefquestion.EdgeMessages)
	}
	if m.clearedincident_fields {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentFields)
	}
	if m.clearedincident_roles {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentRoles)
	}
	if m.clearedincident_severities {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentSeverities)
	}
	if m.clearedincident_tags {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTags)
	}
	if m.clearedincident_types {
		edges = append(edges, incidentdebriefquestion.EdgeIncidentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebriefquestion.EdgeTenant:
		return m.clearedtenant
	case incidentdebriefquestion.EdgeMessages:
		return m.clearedmessages
	case incidentdebriefquestion.EdgeIncidentFields:
		return m.clearedincident_fields
	case incidentdebriefquestion.EdgeIncidentRoles:
		return m.clearedincident_roles
	case incidentdebriefquestion.EdgeIncidentSeverities:
		return m.clearedincident_severities
	case incidentdebriefquestion.EdgeIncidentTags:
		return m.clearedincident_tags
	case incidentdebriefquestion.EdgeIncidentTypes:
		return m.clearedincident_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ClearEdge(name string) error {
	switch name {
	case incidentdebriefquestion.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefQuestionMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebriefquestion.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentdebriefquestion.EdgeMessages:
		m.ResetMessages()
		return nil
	case incidentdebriefquestion.EdgeIncidentFields:
		m.ResetIncidentFields()
		return nil
	case incidentdebriefquestion.EdgeIncidentRoles:
		m.ResetIncidentRoles()
		return nil
	case incidentdebriefquestion.EdgeIncidentSeverities:
		m.ResetIncidentSeverities()
		return nil
	case incidentdebriefquestion.EdgeIncidentTags:
		m.ResetIncidentTags()
		return nil
	case incidentdebriefquestion.EdgeIncidentTypes:
		m.ResetIncidentTypes()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefQuestion edge %s", name)
}

// IncidentDebriefSuggestionMutation represents an operation that mutates the IncidentDebriefSuggestion nodes in the graph.
type IncidentDebriefSuggestionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	content        *string
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	debrief        *uuid.UUID
	cleareddebrief bool
	done           bool
	oldValue       func(context.Context) (*IncidentDebriefSuggestion, error)
	predicates     []predicate.IncidentDebriefSuggestion
}

var _ ent.Mutation = (*IncidentDebriefSuggestionMutation)(nil)

// incidentdebriefsuggestionOption allows management of the mutation configuration using functional options.
type incidentdebriefsuggestionOption func(*IncidentDebriefSuggestionMutation)

// newIncidentDebriefSuggestionMutation creates new mutation for the IncidentDebriefSuggestion entity.
func newIncidentDebriefSuggestionMutation(c config, op Op, opts ...incidentdebriefsuggestionOption) *IncidentDebriefSuggestionMutation {
	m := &IncidentDebriefSuggestionMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentDebriefSuggestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentDebriefSuggestionID sets the ID field of the mutation.
func withIncidentDebriefSuggestionID(id uuid.UUID) incidentdebriefsuggestionOption {
	return func(m *IncidentDebriefSuggestionMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentDebriefSuggestion
		)
		m.oldValue = func(ctx context.Context) (*IncidentDebriefSuggestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentDebriefSuggestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentDebriefSuggestion sets the old IncidentDebriefSuggestion of the mutation.
func withIncidentDebriefSuggestion(node *IncidentDebriefSuggestion) incidentdebriefsuggestionOption {
	return func(m *IncidentDebriefSuggestionMutation) {
		m.oldValue = func(context.Context) (*IncidentDebriefSuggestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentDebriefSuggestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentDebriefSuggestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentDebriefSuggestion entities.
func (m *IncidentDebriefSuggestionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentDebriefSuggestionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentDebriefSuggestionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentDebriefSuggestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentDebriefSuggestionMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentDebriefSuggestionMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentDebriefSuggestion entity.
// If the IncidentDebriefSuggestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefSuggestionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentDebriefSuggestionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetContent sets the "content" field.
func (m *IncidentDebriefSuggestionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *IncidentDebriefSuggestionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the IncidentDebriefSuggestion entity.
// If the IncidentDebriefSuggestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentDebriefSuggestionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *IncidentDebriefSuggestionMutation) ResetContent() {
	m.content = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentDebriefSuggestionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentdebriefsuggestion.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentDebriefSuggestionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefSuggestionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentDebriefSuggestionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDebriefID sets the "debrief" edge to the IncidentDebrief entity by id.
func (m *IncidentDebriefSuggestionMutation) SetDebriefID(id uuid.UUID) {
	m.debrief = &id
}

// ClearDebrief clears the "debrief" edge to the IncidentDebrief entity.
func (m *IncidentDebriefSuggestionMutation) ClearDebrief() {
	m.cleareddebrief = true
}

// DebriefCleared reports if the "debrief" edge to the IncidentDebrief entity was cleared.
func (m *IncidentDebriefSuggestionMutation) DebriefCleared() bool {
	return m.cleareddebrief
}

// DebriefID returns the "debrief" edge ID in the mutation.
func (m *IncidentDebriefSuggestionMutation) DebriefID() (id uuid.UUID, exists bool) {
	if m.debrief != nil {
		return *m.debrief, true
	}
	return
}

// DebriefIDs returns the "debrief" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DebriefID instead. It exists only for internal usage by the builders.
func (m *IncidentDebriefSuggestionMutation) DebriefIDs() (ids []uuid.UUID) {
	if id := m.debrief; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDebrief resets all changes to the "debrief" edge.
func (m *IncidentDebriefSuggestionMutation) ResetDebrief() {
	m.debrief = nil
	m.cleareddebrief = false
}

// Where appends a list predicates to the IncidentDebriefSuggestionMutation builder.
func (m *IncidentDebriefSuggestionMutation) Where(ps ...predicate.IncidentDebriefSuggestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentDebriefSuggestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentDebriefSuggestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentDebriefSuggestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentDebriefSuggestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentDebriefSuggestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentDebriefSuggestion).
func (m *IncidentDebriefSuggestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentDebriefSuggestionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, incidentdebriefsuggestion.FieldTenantID)
	}
	if m.content != nil {
		fields = append(fields, incidentdebriefsuggestion.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentDebriefSuggestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentdebriefsuggestion.FieldTenantID:
		return m.TenantID()
	case incidentdebriefsuggestion.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentDebriefSuggestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentdebriefsuggestion.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentdebriefsuggestion.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentDebriefSuggestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefSuggestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentdebriefsuggestion.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentdebriefsuggestion.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentDebriefSuggestionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentDebriefSuggestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentDebriefSuggestionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentDebriefSuggestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentDebriefSuggestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ResetField(name string) error {
	switch name {
	case incidentdebriefsuggestion.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentdebriefsuggestion.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentDebriefSuggestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, incidentdebriefsuggestion.EdgeTenant)
	}
	if m.debrief != nil {
		edges = append(edges, incidentdebriefsuggestion.EdgeDebrief)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentDebriefSuggestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentdebriefsuggestion.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentdebriefsuggestion.EdgeDebrief:
		if id := m.debrief; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentDebriefSuggestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentDebriefSuggestionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentDebriefSuggestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, incidentdebriefsuggestion.EdgeTenant)
	}
	if m.cleareddebrief {
		edges = append(edges, incidentdebriefsuggestion.EdgeDebrief)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentDebriefSuggestionMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentdebriefsuggestion.EdgeTenant:
		return m.clearedtenant
	case incidentdebriefsuggestion.EdgeDebrief:
		return m.cleareddebrief
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ClearEdge(name string) error {
	switch name {
	case incidentdebriefsuggestion.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentdebriefsuggestion.EdgeDebrief:
		m.ClearDebrief()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentDebriefSuggestionMutation) ResetEdge(name string) error {
	switch name {
	case incidentdebriefsuggestion.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentdebriefsuggestion.EdgeDebrief:
		m.ResetDebrief()
		return nil
	}
	return fmt.Errorf("unknown IncidentDebriefSuggestion edge %s", name)
}

// IncidentEventMutation represents an operation that mutates the IncidentEvent nodes in the graph.
type IncidentEventMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	timestamp                *time.Time
	kind                     *incidentevent.Kind
	title                    *string
	description              *string
	is_key                   *bool
	sequence                 *int
	addsequence              *int
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	incident                 *uuid.UUID
	clearedincident          bool
	event                    *uuid.UUID
	clearedevent             bool
	context                  *uuid.UUID
	clearedcontext           bool
	factors                  map[uuid.UUID]struct{}
	removedfactors           map[uuid.UUID]struct{}
	clearedfactors           bool
	evidence                 map[uuid.UUID]struct{}
	removedevidence          map[uuid.UUID]struct{}
	clearedevidence          bool
	system_components        map[uuid.UUID]struct{}
	removedsystem_components map[uuid.UUID]struct{}
	clearedsystem_components bool
	event_components         map[uuid.UUID]struct{}
	removedevent_components  map[uuid.UUID]struct{}
	clearedevent_components  bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentEvent, error)
	predicates               []predicate.IncidentEvent
}

var _ ent.Mutation = (*IncidentEventMutation)(nil)

// incidenteventOption allows management of the mutation configuration using functional options.
type incidenteventOption func(*IncidentEventMutation)

// newIncidentEventMutation creates new mutation for the IncidentEvent entity.
func newIncidentEventMutation(c config, op Op, opts ...incidenteventOption) *IncidentEventMutation {
	m := &IncidentEventMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventID sets the ID field of the mutation.
func withIncidentEventID(id uuid.UUID) incidenteventOption {
	return func(m *IncidentEventMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEvent
		)
		m.oldValue = func(ctx context.Context) (*IncidentEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEvent sets the old IncidentEvent of the mutation.
func withIncidentEvent(node *IncidentEvent) incidenteventOption {
	return func(m *IncidentEventMutation) {
		m.oldValue = func(context.Context) (*IncidentEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEvent entities.
func (m *IncidentEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentEventMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentEventMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentEventMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentEventMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentEventMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentEventMutation) ResetIncidentID() {
	m.incident = nil
}

// SetEventID sets the "event_id" field.
func (m *IncidentEventMutation) SetEventID(u uuid.UUID) {
	m.event = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *IncidentEventMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ClearEventID clears the value of the "event_id" field.
func (m *IncidentEventMutation) ClearEventID() {
	m.event = nil
	m.clearedFields[incidentevent.FieldEventID] = struct{}{}
}

// EventIDCleared returns if the "event_id" field was cleared in this mutation.
func (m *IncidentEventMutation) EventIDCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldEventID]
	return ok
}

// ResetEventID resets all changes to the "event_id" field.
func (m *IncidentEventMutation) ResetEventID() {
	m.event = nil
	delete(m.clearedFields, incidentevent.FieldEventID)
}

// SetTimestamp sets the "timestamp" field.
func (m *IncidentEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *IncidentEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *IncidentEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetKind sets the "kind" field.
func (m *IncidentEventMutation) SetKind(i incidentevent.Kind) {
	m.kind = &i
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IncidentEventMutation) Kind() (r incidentevent.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldKind(ctx context.Context) (v incidentevent.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *IncidentEventMutation) ResetKind() {
	m.kind = nil
}

// SetTitle sets the "title" field.
func (m *IncidentEventMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentEventMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentEventMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IncidentEventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentEventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentEventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentevent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentEventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentevent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentEventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentevent.FieldDescription)
}

// SetIsKey sets the "is_key" field.
func (m *IncidentEventMutation) SetIsKey(b bool) {
	m.is_key = &b
}

// IsKey returns the value of the "is_key" field in the mutation.
func (m *IncidentEventMutation) IsKey() (r bool, exists bool) {
	v := m.is_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIsKey returns the old "is_key" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldIsKey(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsKey: %w", err)
	}
	return oldValue.IsKey, nil
}

// ResetIsKey resets all changes to the "is_key" field.
func (m *IncidentEventMutation) ResetIsKey() {
	m.is_key = nil
}

// SetSequence sets the "sequence" field.
func (m *IncidentEventMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *IncidentEventMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *IncidentEventMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *IncidentEventMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *IncidentEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IncidentEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IncidentEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IncidentEvent entity.
// If the IncidentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IncidentEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentEventMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentevent.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentEventMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentEventMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentEventMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentEventMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentevent.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentEventMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentEventMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentEventMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *IncidentEventMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[incidentevent.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *IncidentEventMutation) EventCleared() bool {
	return m.EventIDCleared() || m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetContextID sets the "context" edge to the IncidentEventContext entity by id.
func (m *IncidentEventMutation) SetContextID(id uuid.UUID) {
	m.context = &id
}

// ClearContext clears the "context" edge to the IncidentEventContext entity.
func (m *IncidentEventMutation) ClearContext() {
	m.clearedcontext = true
}

// ContextCleared reports if the "context" edge to the IncidentEventContext entity was cleared.
func (m *IncidentEventMutation) ContextCleared() bool {
	return m.clearedcontext
}

// ContextID returns the "context" edge ID in the mutation.
func (m *IncidentEventMutation) ContextID() (id uuid.UUID, exists bool) {
	if m.context != nil {
		return *m.context, true
	}
	return
}

// ContextIDs returns the "context" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContextID instead. It exists only for internal usage by the builders.
func (m *IncidentEventMutation) ContextIDs() (ids []uuid.UUID) {
	if id := m.context; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContext resets all changes to the "context" edge.
func (m *IncidentEventMutation) ResetContext() {
	m.context = nil
	m.clearedcontext = false
}

// AddFactorIDs adds the "factors" edge to the IncidentEventContributingFactor entity by ids.
func (m *IncidentEventMutation) AddFactorIDs(ids ...uuid.UUID) {
	if m.factors == nil {
		m.factors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.factors[ids[i]] = struct{}{}
	}
}

// ClearFactors clears the "factors" edge to the IncidentEventContributingFactor entity.
func (m *IncidentEventMutation) ClearFactors() {
	m.clearedfactors = true
}

// FactorsCleared reports if the "factors" edge to the IncidentEventContributingFactor entity was cleared.
func (m *IncidentEventMutation) FactorsCleared() bool {
	return m.clearedfactors
}

// RemoveFactorIDs removes the "factors" edge to the IncidentEventContributingFactor entity by IDs.
func (m *IncidentEventMutation) RemoveFactorIDs(ids ...uuid.UUID) {
	if m.removedfactors == nil {
		m.removedfactors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.factors, ids[i])
		m.removedfactors[ids[i]] = struct{}{}
	}
}

// RemovedFactors returns the removed IDs of the "factors" edge to the IncidentEventContributingFactor entity.
func (m *IncidentEventMutation) RemovedFactorsIDs() (ids []uuid.UUID) {
	for id := range m.removedfactors {
		ids = append(ids, id)
	}
	return
}

// FactorsIDs returns the "factors" edge IDs in the mutation.
func (m *IncidentEventMutation) FactorsIDs() (ids []uuid.UUID) {
	for id := range m.factors {
		ids = append(ids, id)
	}
	return
}

// ResetFactors resets all changes to the "factors" edge.
func (m *IncidentEventMutation) ResetFactors() {
	m.factors = nil
	m.clearedfactors = false
	m.removedfactors = nil
}

// AddEvidenceIDs adds the "evidence" edge to the IncidentEventEvidence entity by ids.
func (m *IncidentEventMutation) AddEvidenceIDs(ids ...uuid.UUID) {
	if m.evidence == nil {
		m.evidence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.evidence[ids[i]] = struct{}{}
	}
}

// ClearEvidence clears the "evidence" edge to the IncidentEventEvidence entity.
func (m *IncidentEventMutation) ClearEvidence() {
	m.clearedevidence = true
}

// EvidenceCleared reports if the "evidence" edge to the IncidentEventEvidence entity was cleared.
func (m *IncidentEventMutation) EvidenceCleared() bool {
	return m.clearedevidence
}

// RemoveEvidenceIDs removes the "evidence" edge to the IncidentEventEvidence entity by IDs.
func (m *IncidentEventMutation) RemoveEvidenceIDs(ids ...uuid.UUID) {
	if m.removedevidence == nil {
		m.removedevidence = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.evidence, ids[i])
		m.removedevidence[ids[i]] = struct{}{}
	}
}

// RemovedEvidence returns the removed IDs of the "evidence" edge to the IncidentEventEvidence entity.
func (m *IncidentEventMutation) RemovedEvidenceIDs() (ids []uuid.UUID) {
	for id := range m.removedevidence {
		ids = append(ids, id)
	}
	return
}

// EvidenceIDs returns the "evidence" edge IDs in the mutation.
func (m *IncidentEventMutation) EvidenceIDs() (ids []uuid.UUID) {
	for id := range m.evidence {
		ids = append(ids, id)
	}
	return
}

// ResetEvidence resets all changes to the "evidence" edge.
func (m *IncidentEventMutation) ResetEvidence() {
	m.evidence = nil
	m.clearedevidence = false
	m.removedevidence = nil
}

// AddSystemComponentIDs adds the "system_components" edge to the SystemComponent entity by ids.
func (m *IncidentEventMutation) AddSystemComponentIDs(ids ...uuid.UUID) {
	if m.system_components == nil {
		m.system_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.system_components[ids[i]] = struct{}{}
	}
}

// ClearSystemComponents clears the "system_components" edge to the SystemComponent entity.
func (m *IncidentEventMutation) ClearSystemComponents() {
	m.clearedsystem_components = true
}

// SystemComponentsCleared reports if the "system_components" edge to the SystemComponent entity was cleared.
func (m *IncidentEventMutation) SystemComponentsCleared() bool {
	return m.clearedsystem_components
}

// RemoveSystemComponentIDs removes the "system_components" edge to the SystemComponent entity by IDs.
func (m *IncidentEventMutation) RemoveSystemComponentIDs(ids ...uuid.UUID) {
	if m.removedsystem_components == nil {
		m.removedsystem_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.system_components, ids[i])
		m.removedsystem_components[ids[i]] = struct{}{}
	}
}

// RemovedSystemComponents returns the removed IDs of the "system_components" edge to the SystemComponent entity.
func (m *IncidentEventMutation) RemovedSystemComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedsystem_components {
		ids = append(ids, id)
	}
	return
}

// SystemComponentsIDs returns the "system_components" edge IDs in the mutation.
func (m *IncidentEventMutation) SystemComponentsIDs() (ids []uuid.UUID) {
	for id := range m.system_components {
		ids = append(ids, id)
	}
	return
}

// ResetSystemComponents resets all changes to the "system_components" edge.
func (m *IncidentEventMutation) ResetSystemComponents() {
	m.system_components = nil
	m.clearedsystem_components = false
	m.removedsystem_components = nil
}

// AddEventComponentIDs adds the "event_components" edge to the IncidentEventSystemComponent entity by ids.
func (m *IncidentEventMutation) AddEventComponentIDs(ids ...uuid.UUID) {
	if m.event_components == nil {
		m.event_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.event_components[ids[i]] = struct{}{}
	}
}

// ClearEventComponents clears the "event_components" edge to the IncidentEventSystemComponent entity.
func (m *IncidentEventMutation) ClearEventComponents() {
	m.clearedevent_components = true
}

// EventComponentsCleared reports if the "event_components" edge to the IncidentEventSystemComponent entity was cleared.
func (m *IncidentEventMutation) EventComponentsCleared() bool {
	return m.clearedevent_components
}

// RemoveEventComponentIDs removes the "event_components" edge to the IncidentEventSystemComponent entity by IDs.
func (m *IncidentEventMutation) RemoveEventComponentIDs(ids ...uuid.UUID) {
	if m.removedevent_components == nil {
		m.removedevent_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.event_components, ids[i])
		m.removedevent_components[ids[i]] = struct{}{}
	}
}

// RemovedEventComponents returns the removed IDs of the "event_components" edge to the IncidentEventSystemComponent entity.
func (m *IncidentEventMutation) RemovedEventComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedevent_components {
		ids = append(ids, id)
	}
	return
}

// EventComponentsIDs returns the "event_components" edge IDs in the mutation.
func (m *IncidentEventMutation) EventComponentsIDs() (ids []uuid.UUID) {
	for id := range m.event_components {
		ids = append(ids, id)
	}
	return
}

// ResetEventComponents resets all changes to the "event_components" edge.
func (m *IncidentEventMutation) ResetEventComponents() {
	m.event_components = nil
	m.clearedevent_components = false
	m.removedevent_components = nil
}

// Where appends a list predicates to the IncidentEventMutation builder.
func (m *IncidentEventMutation) Where(ps ...predicate.IncidentEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEvent).
func (m *IncidentEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant != nil {
		fields = append(fields, incidentevent.FieldTenantID)
	}
	if m.incident != nil {
		fields = append(fields, incidentevent.FieldIncidentID)
	}
	if m.event != nil {
		fields = append(fields, incidentevent.FieldEventID)
	}
	if m.timestamp != nil {
		fields = append(fields, incidentevent.FieldTimestamp)
	}
	if m.kind != nil {
		fields = append(fields, incidentevent.FieldKind)
	}
	if m.title != nil {
		fields = append(fields, incidentevent.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, incidentevent.FieldDescription)
	}
	if m.is_key != nil {
		fields = append(fields, incidentevent.FieldIsKey)
	}
	if m.sequence != nil {
		fields = append(fields, incidentevent.FieldSequence)
	}
	if m.created_at != nil {
		fields = append(fields, incidentevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, incidentevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentevent.FieldTenantID:
		return m.TenantID()
	case incidentevent.FieldIncidentID:
		return m.IncidentID()
	case incidentevent.FieldEventID:
		return m.EventID()
	case incidentevent.FieldTimestamp:
		return m.Timestamp()
	case incidentevent.FieldKind:
		return m.Kind()
	case incidentevent.FieldTitle:
		return m.Title()
	case incidentevent.FieldDescription:
		return m.Description()
	case incidentevent.FieldIsKey:
		return m.IsKey()
	case incidentevent.FieldSequence:
		return m.Sequence()
	case incidentevent.FieldCreatedAt:
		return m.CreatedAt()
	case incidentevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentevent.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentevent.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentevent.FieldEventID:
		return m.OldEventID(ctx)
	case incidentevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case incidentevent.FieldKind:
		return m.OldKind(ctx)
	case incidentevent.FieldTitle:
		return m.OldTitle(ctx)
	case incidentevent.FieldDescription:
		return m.OldDescription(ctx)
	case incidentevent.FieldIsKey:
		return m.OldIsKey(ctx)
	case incidentevent.FieldSequence:
		return m.OldSequence(ctx)
	case incidentevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case incidentevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentevent.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentevent.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentevent.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case incidentevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case incidentevent.FieldKind:
		v, ok := value.(incidentevent.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case incidentevent.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incidentevent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentevent.FieldIsKey:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsKey(v)
		return nil
	case incidentevent.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case incidentevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case incidentevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, incidentevent.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentevent.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentevent.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentevent.FieldEventID) {
		fields = append(fields, incidentevent.FieldEventID)
	}
	if m.FieldCleared(incidentevent.FieldDescription) {
		fields = append(fields, incidentevent.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventMutation) ClearField(name string) error {
	switch name {
	case incidentevent.FieldEventID:
		m.ClearEventID()
		return nil
	case incidentevent.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventMutation) ResetField(name string) error {
	switch name {
	case incidentevent.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentevent.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentevent.FieldEventID:
		m.ResetEventID()
		return nil
	case incidentevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case incidentevent.FieldKind:
		m.ResetKind()
		return nil
	case incidentevent.FieldTitle:
		m.ResetTitle()
		return nil
	case incidentevent.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentevent.FieldIsKey:
		m.ResetIsKey()
		return nil
	case incidentevent.FieldSequence:
		m.ResetSequence()
		return nil
	case incidentevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case incidentevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tenant != nil {
		edges = append(edges, incidentevent.EdgeTenant)
	}
	if m.incident != nil {
		edges = append(edges, incidentevent.EdgeIncident)
	}
	if m.event != nil {
		edges = append(edges, incidentevent.EdgeEvent)
	}
	if m.context != nil {
		edges = append(edges, incidentevent.EdgeContext)
	}
	if m.factors != nil {
		edges = append(edges, incidentevent.EdgeFactors)
	}
	if m.evidence != nil {
		edges = append(edges, incidentevent.EdgeEvidence)
	}
	if m.system_components != nil {
		edges = append(edges, incidentevent.EdgeSystemComponents)
	}
	if m.event_components != nil {
		edges = append(edges, incidentevent.EdgeEventComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentevent.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentevent.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentevent.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case incidentevent.EdgeContext:
		if id := m.context; id != nil {
			return []ent.Value{*id}
		}
	case incidentevent.EdgeFactors:
		ids := make([]ent.Value, 0, len(m.factors))
		for id := range m.factors {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeEvidence:
		ids := make([]ent.Value, 0, len(m.evidence))
		for id := range m.evidence {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeSystemComponents:
		ids := make([]ent.Value, 0, len(m.system_components))
		for id := range m.system_components {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeEventComponents:
		ids := make([]ent.Value, 0, len(m.event_components))
		for id := range m.event_components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedfactors != nil {
		edges = append(edges, incidentevent.EdgeFactors)
	}
	if m.removedevidence != nil {
		edges = append(edges, incidentevent.EdgeEvidence)
	}
	if m.removedsystem_components != nil {
		edges = append(edges, incidentevent.EdgeSystemComponents)
	}
	if m.removedevent_components != nil {
		edges = append(edges, incidentevent.EdgeEventComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentevent.EdgeFactors:
		ids := make([]ent.Value, 0, len(m.removedfactors))
		for id := range m.removedfactors {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeEvidence:
		ids := make([]ent.Value, 0, len(m.removedevidence))
		for id := range m.removedevidence {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeSystemComponents:
		ids := make([]ent.Value, 0, len(m.removedsystem_components))
		for id := range m.removedsystem_components {
			ids = append(ids, id)
		}
		return ids
	case incidentevent.EdgeEventComponents:
		ids := make([]ent.Value, 0, len(m.removedevent_components))
		for id := range m.removedevent_components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtenant {
		edges = append(edges, incidentevent.EdgeTenant)
	}
	if m.clearedincident {
		edges = append(edges, incidentevent.EdgeIncident)
	}
	if m.clearedevent {
		edges = append(edges, incidentevent.EdgeEvent)
	}
	if m.clearedcontext {
		edges = append(edges, incidentevent.EdgeContext)
	}
	if m.clearedfactors {
		edges = append(edges, incidentevent.EdgeFactors)
	}
	if m.clearedevidence {
		edges = append(edges, incidentevent.EdgeEvidence)
	}
	if m.clearedsystem_components {
		edges = append(edges, incidentevent.EdgeSystemComponents)
	}
	if m.clearedevent_components {
		edges = append(edges, incidentevent.EdgeEventComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentevent.EdgeTenant:
		return m.clearedtenant
	case incidentevent.EdgeIncident:
		return m.clearedincident
	case incidentevent.EdgeEvent:
		return m.clearedevent
	case incidentevent.EdgeContext:
		return m.clearedcontext
	case incidentevent.EdgeFactors:
		return m.clearedfactors
	case incidentevent.EdgeEvidence:
		return m.clearedevidence
	case incidentevent.EdgeSystemComponents:
		return m.clearedsystem_components
	case incidentevent.EdgeEventComponents:
		return m.clearedevent_components
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventMutation) ClearEdge(name string) error {
	switch name {
	case incidentevent.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentevent.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentevent.EdgeEvent:
		m.ClearEvent()
		return nil
	case incidentevent.EdgeContext:
		m.ClearContext()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventMutation) ResetEdge(name string) error {
	switch name {
	case incidentevent.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentevent.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentevent.EdgeEvent:
		m.ResetEvent()
		return nil
	case incidentevent.EdgeContext:
		m.ResetContext()
		return nil
	case incidentevent.EdgeFactors:
		m.ResetFactors()
		return nil
	case incidentevent.EdgeEvidence:
		m.ResetEvidence()
		return nil
	case incidentevent.EdgeSystemComponents:
		m.ResetSystemComponents()
		return nil
	case incidentevent.EdgeEventComponents:
		m.ResetEventComponents()
		return nil
	}
	return fmt.Errorf("unknown IncidentEvent edge %s", name)
}

// IncidentEventContextMutation represents an operation that mutates the IncidentEventContext nodes in the graph.
type IncidentEventContextMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	system_state             *string
	decision_options         *[]string
	appenddecision_options   []string
	decision_rationale       *string
	involved_personnel       *[]string
	appendinvolved_personnel []string
	created_at               *time.Time
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	event                    *uuid.UUID
	clearedevent             bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentEventContext, error)
	predicates               []predicate.IncidentEventContext
}

var _ ent.Mutation = (*IncidentEventContextMutation)(nil)

// incidenteventcontextOption allows management of the mutation configuration using functional options.
type incidenteventcontextOption func(*IncidentEventContextMutation)

// newIncidentEventContextMutation creates new mutation for the IncidentEventContext entity.
func newIncidentEventContextMutation(c config, op Op, opts ...incidenteventcontextOption) *IncidentEventContextMutation {
	m := &IncidentEventContextMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEventContext,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventContextID sets the ID field of the mutation.
func withIncidentEventContextID(id uuid.UUID) incidenteventcontextOption {
	return func(m *IncidentEventContextMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEventContext
		)
		m.oldValue = func(ctx context.Context) (*IncidentEventContext, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEventContext.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEventContext sets the old IncidentEventContext of the mutation.
func withIncidentEventContext(node *IncidentEventContext) incidenteventcontextOption {
	return func(m *IncidentEventContextMutation) {
		m.oldValue = func(context.Context) (*IncidentEventContext, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventContextMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventContextMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEventContext entities.
func (m *IncidentEventContextMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventContextMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventContextMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEventContext.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentEventContextMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentEventContextMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentEventContextMutation) ResetTenantID() {
	m.tenant = nil
}

// SetSystemState sets the "system_state" field.
func (m *IncidentEventContextMutation) SetSystemState(s string) {
	m.system_state = &s
}

// SystemState returns the value of the "system_state" field in the mutation.
func (m *IncidentEventContextMutation) SystemState() (r string, exists bool) {
	v := m.system_state
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemState returns the old "system_state" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldSystemState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemState: %w", err)
	}
	return oldValue.SystemState, nil
}

// ClearSystemState clears the value of the "system_state" field.
func (m *IncidentEventContextMutation) ClearSystemState() {
	m.system_state = nil
	m.clearedFields[incidenteventcontext.FieldSystemState] = struct{}{}
}

// SystemStateCleared returns if the "system_state" field was cleared in this mutation.
func (m *IncidentEventContextMutation) SystemStateCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldSystemState]
	return ok
}

// ResetSystemState resets all changes to the "system_state" field.
func (m *IncidentEventContextMutation) ResetSystemState() {
	m.system_state = nil
	delete(m.clearedFields, incidenteventcontext.FieldSystemState)
}

// SetDecisionOptions sets the "decision_options" field.
func (m *IncidentEventContextMutation) SetDecisionOptions(s []string) {
	m.decision_options = &s
	m.appenddecision_options = nil
}

// DecisionOptions returns the value of the "decision_options" field in the mutation.
func (m *IncidentEventContextMutation) DecisionOptions() (r []string, exists bool) {
	v := m.decision_options
	if v == nil {
		return
	}
	return *v, true
}

// OldDecisionOptions returns the old "decision_options" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldDecisionOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecisionOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecisionOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecisionOptions: %w", err)
	}
	return oldValue.DecisionOptions, nil
}

// AppendDecisionOptions adds s to the "decision_options" field.
func (m *IncidentEventContextMutation) AppendDecisionOptions(s []string) {
	m.appenddecision_options = append(m.appenddecision_options, s...)
}

// AppendedDecisionOptions returns the list of values that were appended to the "decision_options" field in this mutation.
func (m *IncidentEventContextMutation) AppendedDecisionOptions() ([]string, bool) {
	if len(m.appenddecision_options) == 0 {
		return nil, false
	}
	return m.appenddecision_options, true
}

// ClearDecisionOptions clears the value of the "decision_options" field.
func (m *IncidentEventContextMutation) ClearDecisionOptions() {
	m.decision_options = nil
	m.appenddecision_options = nil
	m.clearedFields[incidenteventcontext.FieldDecisionOptions] = struct{}{}
}

// DecisionOptionsCleared returns if the "decision_options" field was cleared in this mutation.
func (m *IncidentEventContextMutation) DecisionOptionsCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldDecisionOptions]
	return ok
}

// ResetDecisionOptions resets all changes to the "decision_options" field.
func (m *IncidentEventContextMutation) ResetDecisionOptions() {
	m.decision_options = nil
	m.appenddecision_options = nil
	delete(m.clearedFields, incidenteventcontext.FieldDecisionOptions)
}

// SetDecisionRationale sets the "decision_rationale" field.
func (m *IncidentEventContextMutation) SetDecisionRationale(s string) {
	m.decision_rationale = &s
}

// DecisionRationale returns the value of the "decision_rationale" field in the mutation.
func (m *IncidentEventContextMutation) DecisionRationale() (r string, exists bool) {
	v := m.decision_rationale
	if v == nil {
		return
	}
	return *v, true
}

// OldDecisionRationale returns the old "decision_rationale" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldDecisionRationale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecisionRationale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecisionRationale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecisionRationale: %w", err)
	}
	return oldValue.DecisionRationale, nil
}

// ClearDecisionRationale clears the value of the "decision_rationale" field.
func (m *IncidentEventContextMutation) ClearDecisionRationale() {
	m.decision_rationale = nil
	m.clearedFields[incidenteventcontext.FieldDecisionRationale] = struct{}{}
}

// DecisionRationaleCleared returns if the "decision_rationale" field was cleared in this mutation.
func (m *IncidentEventContextMutation) DecisionRationaleCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldDecisionRationale]
	return ok
}

// ResetDecisionRationale resets all changes to the "decision_rationale" field.
func (m *IncidentEventContextMutation) ResetDecisionRationale() {
	m.decision_rationale = nil
	delete(m.clearedFields, incidenteventcontext.FieldDecisionRationale)
}

// SetInvolvedPersonnel sets the "involved_personnel" field.
func (m *IncidentEventContextMutation) SetInvolvedPersonnel(s []string) {
	m.involved_personnel = &s
	m.appendinvolved_personnel = nil
}

// InvolvedPersonnel returns the value of the "involved_personnel" field in the mutation.
func (m *IncidentEventContextMutation) InvolvedPersonnel() (r []string, exists bool) {
	v := m.involved_personnel
	if v == nil {
		return
	}
	return *v, true
}

// OldInvolvedPersonnel returns the old "involved_personnel" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldInvolvedPersonnel(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvolvedPersonnel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvolvedPersonnel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvolvedPersonnel: %w", err)
	}
	return oldValue.InvolvedPersonnel, nil
}

// AppendInvolvedPersonnel adds s to the "involved_personnel" field.
func (m *IncidentEventContextMutation) AppendInvolvedPersonnel(s []string) {
	m.appendinvolved_personnel = append(m.appendinvolved_personnel, s...)
}

// AppendedInvolvedPersonnel returns the list of values that were appended to the "involved_personnel" field in this mutation.
func (m *IncidentEventContextMutation) AppendedInvolvedPersonnel() ([]string, bool) {
	if len(m.appendinvolved_personnel) == 0 {
		return nil, false
	}
	return m.appendinvolved_personnel, true
}

// ClearInvolvedPersonnel clears the value of the "involved_personnel" field.
func (m *IncidentEventContextMutation) ClearInvolvedPersonnel() {
	m.involved_personnel = nil
	m.appendinvolved_personnel = nil
	m.clearedFields[incidenteventcontext.FieldInvolvedPersonnel] = struct{}{}
}

// InvolvedPersonnelCleared returns if the "involved_personnel" field was cleared in this mutation.
func (m *IncidentEventContextMutation) InvolvedPersonnelCleared() bool {
	_, ok := m.clearedFields[incidenteventcontext.FieldInvolvedPersonnel]
	return ok
}

// ResetInvolvedPersonnel resets all changes to the "involved_personnel" field.
func (m *IncidentEventContextMutation) ResetInvolvedPersonnel() {
	m.involved_personnel = nil
	m.appendinvolved_personnel = nil
	delete(m.clearedFields, incidenteventcontext.FieldInvolvedPersonnel)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventContextMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventContextMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEventContext entity.
// If the IncidentEventContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContextMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventContextMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentEventContextMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidenteventcontext.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentEventContextMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentEventContextMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentEventContextMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEventID sets the "event" edge to the IncidentEvent entity by id.
func (m *IncidentEventContextMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the IncidentEvent entity.
func (m *IncidentEventContextMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the IncidentEvent entity was cleared.
func (m *IncidentEventContextMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *IncidentEventContextMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventContextMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventContextMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the IncidentEventContextMutation builder.
func (m *IncidentEventContextMutation) Where(ps ...predicate.IncidentEventContext) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventContextMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventContextMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEventContext, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventContextMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventContextMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEventContext).
func (m *IncidentEventContextMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventContextMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, incidenteventcontext.FieldTenantID)
	}
	if m.system_state != nil {
		fields = append(fields, incidenteventcontext.FieldSystemState)
	}
	if m.decision_options != nil {
		fields = append(fields, incidenteventcontext.FieldDecisionOptions)
	}
	if m.decision_rationale != nil {
		fields = append(fields, incidenteventcontext.FieldDecisionRationale)
	}
	if m.involved_personnel != nil {
		fields = append(fields, incidenteventcontext.FieldInvolvedPersonnel)
	}
	if m.created_at != nil {
		fields = append(fields, incidenteventcontext.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventContextMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenteventcontext.FieldTenantID:
		return m.TenantID()
	case incidenteventcontext.FieldSystemState:
		return m.SystemState()
	case incidenteventcontext.FieldDecisionOptions:
		return m.DecisionOptions()
	case incidenteventcontext.FieldDecisionRationale:
		return m.DecisionRationale()
	case incidenteventcontext.FieldInvolvedPersonnel:
		return m.InvolvedPersonnel()
	case incidenteventcontext.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventContextMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenteventcontext.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidenteventcontext.FieldSystemState:
		return m.OldSystemState(ctx)
	case incidenteventcontext.FieldDecisionOptions:
		return m.OldDecisionOptions(ctx)
	case incidenteventcontext.FieldDecisionRationale:
		return m.OldDecisionRationale(ctx)
	case incidenteventcontext.FieldInvolvedPersonnel:
		return m.OldInvolvedPersonnel(ctx)
	case incidenteventcontext.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEventContext field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContextMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenteventcontext.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidenteventcontext.FieldSystemState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemState(v)
		return nil
	case incidenteventcontext.FieldDecisionOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecisionOptions(v)
		return nil
	case incidenteventcontext.FieldDecisionRationale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecisionRationale(v)
		return nil
	case incidenteventcontext.FieldInvolvedPersonnel:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvolvedPersonnel(v)
		return nil
	case incidenteventcontext.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventContextMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventContextMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContextMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentEventContext numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventContextMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenteventcontext.FieldSystemState) {
		fields = append(fields, incidenteventcontext.FieldSystemState)
	}
	if m.FieldCleared(incidenteventcontext.FieldDecisionOptions) {
		fields = append(fields, incidenteventcontext.FieldDecisionOptions)
	}
	if m.FieldCleared(incidenteventcontext.FieldDecisionRationale) {
		fields = append(fields, incidenteventcontext.FieldDecisionRationale)
	}
	if m.FieldCleared(incidenteventcontext.FieldInvolvedPersonnel) {
		fields = append(fields, incidenteventcontext.FieldInvolvedPersonnel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventContextMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventContextMutation) ClearField(name string) error {
	switch name {
	case incidenteventcontext.FieldSystemState:
		m.ClearSystemState()
		return nil
	case incidenteventcontext.FieldDecisionOptions:
		m.ClearDecisionOptions()
		return nil
	case incidenteventcontext.FieldDecisionRationale:
		m.ClearDecisionRationale()
		return nil
	case incidenteventcontext.FieldInvolvedPersonnel:
		m.ClearInvolvedPersonnel()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventContextMutation) ResetField(name string) error {
	switch name {
	case incidenteventcontext.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidenteventcontext.FieldSystemState:
		m.ResetSystemState()
		return nil
	case incidenteventcontext.FieldDecisionOptions:
		m.ResetDecisionOptions()
		return nil
	case incidenteventcontext.FieldDecisionRationale:
		m.ResetDecisionRationale()
		return nil
	case incidenteventcontext.FieldInvolvedPersonnel:
		m.ResetInvolvedPersonnel()
		return nil
	case incidenteventcontext.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventContextMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, incidenteventcontext.EdgeTenant)
	}
	if m.event != nil {
		edges = append(edges, incidenteventcontext.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventContextMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenteventcontext.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidenteventcontext.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventContextMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventContextMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventContextMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, incidenteventcontext.EdgeTenant)
	}
	if m.clearedevent {
		edges = append(edges, incidenteventcontext.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventContextMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenteventcontext.EdgeTenant:
		return m.clearedtenant
	case incidenteventcontext.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventContextMutation) ClearEdge(name string) error {
	switch name {
	case incidenteventcontext.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidenteventcontext.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventContextMutation) ResetEdge(name string) error {
	switch name {
	case incidenteventcontext.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidenteventcontext.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContext edge %s", name)
}

// IncidentEventContributingFactorMutation represents an operation that mutates the IncidentEventContributingFactor nodes in the graph.
type IncidentEventContributingFactorMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	factor_type   *string
	description   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	event         *uuid.UUID
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*IncidentEventContributingFactor, error)
	predicates    []predicate.IncidentEventContributingFactor
}

var _ ent.Mutation = (*IncidentEventContributingFactorMutation)(nil)

// incidenteventcontributingfactorOption allows management of the mutation configuration using functional options.
type incidenteventcontributingfactorOption func(*IncidentEventContributingFactorMutation)

// newIncidentEventContributingFactorMutation creates new mutation for the IncidentEventContributingFactor entity.
func newIncidentEventContributingFactorMutation(c config, op Op, opts ...incidenteventcontributingfactorOption) *IncidentEventContributingFactorMutation {
	m := &IncidentEventContributingFactorMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEventContributingFactor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventContributingFactorID sets the ID field of the mutation.
func withIncidentEventContributingFactorID(id uuid.UUID) incidenteventcontributingfactorOption {
	return func(m *IncidentEventContributingFactorMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEventContributingFactor
		)
		m.oldValue = func(ctx context.Context) (*IncidentEventContributingFactor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEventContributingFactor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEventContributingFactor sets the old IncidentEventContributingFactor of the mutation.
func withIncidentEventContributingFactor(node *IncidentEventContributingFactor) incidenteventcontributingfactorOption {
	return func(m *IncidentEventContributingFactorMutation) {
		m.oldValue = func(context.Context) (*IncidentEventContributingFactor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventContributingFactorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventContributingFactorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEventContributingFactor entities.
func (m *IncidentEventContributingFactorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventContributingFactorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventContributingFactorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEventContributingFactor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentEventContributingFactorMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentEventContributingFactorMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentEventContributingFactor entity.
// If the IncidentEventContributingFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContributingFactorMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentEventContributingFactorMutation) ResetTenantID() {
	m.tenant = nil
}

// SetFactorType sets the "factor_type" field.
func (m *IncidentEventContributingFactorMutation) SetFactorType(s string) {
	m.factor_type = &s
}

// FactorType returns the value of the "factor_type" field in the mutation.
func (m *IncidentEventContributingFactorMutation) FactorType() (r string, exists bool) {
	v := m.factor_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFactorType returns the old "factor_type" field's value of the IncidentEventContributingFactor entity.
// If the IncidentEventContributingFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContributingFactorMutation) OldFactorType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFactorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFactorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFactorType: %w", err)
	}
	return oldValue.FactorType, nil
}

// ResetFactorType resets all changes to the "factor_type" field.
func (m *IncidentEventContributingFactorMutation) ResetFactorType() {
	m.factor_type = nil
}

// SetDescription sets the "description" field.
func (m *IncidentEventContributingFactorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentEventContributingFactorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentEventContributingFactor entity.
// If the IncidentEventContributingFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContributingFactorMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentEventContributingFactorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidenteventcontributingfactor.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidenteventcontributingfactor.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentEventContributingFactorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidenteventcontributingfactor.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventContributingFactorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventContributingFactorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEventContributingFactor entity.
// If the IncidentEventContributingFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventContributingFactorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventContributingFactorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentEventContributingFactorMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidenteventcontributingfactor.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentEventContributingFactorMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentEventContributingFactorMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentEventContributingFactorMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEventID sets the "event" edge to the IncidentEvent entity by id.
func (m *IncidentEventContributingFactorMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the IncidentEvent entity.
func (m *IncidentEventContributingFactorMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the IncidentEvent entity was cleared.
func (m *IncidentEventContributingFactorMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *IncidentEventContributingFactorMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventContributingFactorMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventContributingFactorMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the IncidentEventContributingFactorMutation builder.
func (m *IncidentEventContributingFactorMutation) Where(ps ...predicate.IncidentEventContributingFactor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventContributingFactorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventContributingFactorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEventContributingFactor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventContributingFactorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventContributingFactorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEventContributingFactor).
func (m *IncidentEventContributingFactorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventContributingFactorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, incidenteventcontributingfactor.FieldTenantID)
	}
	if m.factor_type != nil {
		fields = append(fields, incidenteventcontributingfactor.FieldFactorType)
	}
	if m.description != nil {
		fields = append(fields, incidenteventcontributingfactor.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, incidenteventcontributingfactor.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventContributingFactorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenteventcontributingfactor.FieldTenantID:
		return m.TenantID()
	case incidenteventcontributingfactor.FieldFactorType:
		return m.FactorType()
	case incidenteventcontributingfactor.FieldDescription:
		return m.Description()
	case incidenteventcontributingfactor.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventContributingFactorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenteventcontributingfactor.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidenteventcontributingfactor.FieldFactorType:
		return m.OldFactorType(ctx)
	case incidenteventcontributingfactor.FieldDescription:
		return m.OldDescription(ctx)
	case incidenteventcontributingfactor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEventContributingFactor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContributingFactorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenteventcontributingfactor.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidenteventcontributingfactor.FieldFactorType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFactorType(v)
		return nil
	case incidenteventcontributingfactor.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidenteventcontributingfactor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventContributingFactorMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventContributingFactorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventContributingFactorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventContributingFactorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenteventcontributingfactor.FieldDescription) {
		fields = append(fields, incidenteventcontributingfactor.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ClearField(name string) error {
	switch name {
	case incidenteventcontributingfactor.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ResetField(name string) error {
	switch name {
	case incidenteventcontributingfactor.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidenteventcontributingfactor.FieldFactorType:
		m.ResetFactorType()
		return nil
	case incidenteventcontributingfactor.FieldDescription:
		m.ResetDescription()
		return nil
	case incidenteventcontributingfactor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventContributingFactorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, incidenteventcontributingfactor.EdgeTenant)
	}
	if m.event != nil {
		edges = append(edges, incidenteventcontributingfactor.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventContributingFactorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenteventcontributingfactor.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidenteventcontributingfactor.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventContributingFactorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventContributingFactorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, incidenteventcontributingfactor.EdgeTenant)
	}
	if m.clearedevent {
		edges = append(edges, incidenteventcontributingfactor.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventContributingFactorMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenteventcontributingfactor.EdgeTenant:
		return m.clearedtenant
	case incidenteventcontributingfactor.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ClearEdge(name string) error {
	switch name {
	case incidenteventcontributingfactor.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidenteventcontributingfactor.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventContributingFactorMutation) ResetEdge(name string) error {
	switch name {
	case incidenteventcontributingfactor.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidenteventcontributingfactor.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventContributingFactor edge %s", name)
}

// IncidentEventEvidenceMutation represents an operation that mutates the IncidentEventEvidence nodes in the graph.
type IncidentEventEvidenceMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	evidence_type *incidenteventevidence.EvidenceType
	url           *string
	title         *string
	description   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	event         *uuid.UUID
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*IncidentEventEvidence, error)
	predicates    []predicate.IncidentEventEvidence
}

var _ ent.Mutation = (*IncidentEventEvidenceMutation)(nil)

// incidenteventevidenceOption allows management of the mutation configuration using functional options.
type incidenteventevidenceOption func(*IncidentEventEvidenceMutation)

// newIncidentEventEvidenceMutation creates new mutation for the IncidentEventEvidence entity.
func newIncidentEventEvidenceMutation(c config, op Op, opts ...incidenteventevidenceOption) *IncidentEventEvidenceMutation {
	m := &IncidentEventEvidenceMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEventEvidence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventEvidenceID sets the ID field of the mutation.
func withIncidentEventEvidenceID(id uuid.UUID) incidenteventevidenceOption {
	return func(m *IncidentEventEvidenceMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEventEvidence
		)
		m.oldValue = func(ctx context.Context) (*IncidentEventEvidence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEventEvidence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEventEvidence sets the old IncidentEventEvidence of the mutation.
func withIncidentEventEvidence(node *IncidentEventEvidence) incidenteventevidenceOption {
	return func(m *IncidentEventEvidenceMutation) {
		m.oldValue = func(context.Context) (*IncidentEventEvidence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventEvidenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventEvidenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEventEvidence entities.
func (m *IncidentEventEvidenceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventEvidenceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventEvidenceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEventEvidence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentEventEvidenceMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentEventEvidenceMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentEventEvidenceMutation) ResetTenantID() {
	m.tenant = nil
}

// SetEvidenceType sets the "evidence_type" field.
func (m *IncidentEventEvidenceMutation) SetEvidenceType(it incidenteventevidence.EvidenceType) {
	m.evidence_type = &it
}

// EvidenceType returns the value of the "evidence_type" field in the mutation.
func (m *IncidentEventEvidenceMutation) EvidenceType() (r incidenteventevidence.EvidenceType, exists bool) {
	v := m.evidence_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEvidenceType returns the old "evidence_type" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldEvidenceType(ctx context.Context) (v incidenteventevidence.EvidenceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvidenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvidenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvidenceType: %w", err)
	}
	return oldValue.EvidenceType, nil
}

// ResetEvidenceType resets all changes to the "evidence_type" field.
func (m *IncidentEventEvidenceMutation) ResetEvidenceType() {
	m.evidence_type = nil
}

// SetURL sets the "url" field.
func (m *IncidentEventEvidenceMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *IncidentEventEvidenceMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *IncidentEventEvidenceMutation) ResetURL() {
	m.url = nil
}

// SetTitle sets the "title" field.
func (m *IncidentEventEvidenceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IncidentEventEvidenceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IncidentEventEvidenceMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IncidentEventEvidenceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentEventEvidenceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentEventEvidenceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidenteventevidence.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentEventEvidenceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidenteventevidence.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentEventEvidenceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidenteventevidence.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventEvidenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventEvidenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEventEvidence entity.
// If the IncidentEventEvidence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventEvidenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventEvidenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentEventEvidenceMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidenteventevidence.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentEventEvidenceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentEventEvidenceMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentEventEvidenceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEventID sets the "event" edge to the IncidentEvent entity by id.
func (m *IncidentEventEvidenceMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the IncidentEvent entity.
func (m *IncidentEventEvidenceMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the IncidentEvent entity was cleared.
func (m *IncidentEventEvidenceMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *IncidentEventEvidenceMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventEvidenceMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventEvidenceMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the IncidentEventEvidenceMutation builder.
func (m *IncidentEventEvidenceMutation) Where(ps ...predicate.IncidentEventEvidence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventEvidenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventEvidenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEventEvidence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventEvidenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventEvidenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEventEvidence).
func (m *IncidentEventEvidenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventEvidenceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, incidenteventevidence.FieldTenantID)
	}
	if m.evidence_type != nil {
		fields = append(fields, incidenteventevidence.FieldEvidenceType)
	}
	if m.url != nil {
		fields = append(fields, incidenteventevidence.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, incidenteventevidence.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, incidenteventevidence.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, incidenteventevidence.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventEvidenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenteventevidence.FieldTenantID:
		return m.TenantID()
	case incidenteventevidence.FieldEvidenceType:
		return m.EvidenceType()
	case incidenteventevidence.FieldURL:
		return m.URL()
	case incidenteventevidence.FieldTitle:
		return m.Title()
	case incidenteventevidence.FieldDescription:
		return m.Description()
	case incidenteventevidence.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventEvidenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenteventevidence.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidenteventevidence.FieldEvidenceType:
		return m.OldEvidenceType(ctx)
	case incidenteventevidence.FieldURL:
		return m.OldURL(ctx)
	case incidenteventevidence.FieldTitle:
		return m.OldTitle(ctx)
	case incidenteventevidence.FieldDescription:
		return m.OldDescription(ctx)
	case incidenteventevidence.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEventEvidence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventEvidenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenteventevidence.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidenteventevidence.FieldEvidenceType:
		v, ok := value.(incidenteventevidence.EvidenceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvidenceType(v)
		return nil
	case incidenteventevidence.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case incidenteventevidence.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case incidenteventevidence.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidenteventevidence.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventEvidenceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventEvidenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventEvidenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentEventEvidence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventEvidenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenteventevidence.FieldDescription) {
		fields = append(fields, incidenteventevidence.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventEvidenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ClearField(name string) error {
	switch name {
	case incidenteventevidence.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ResetField(name string) error {
	switch name {
	case incidenteventevidence.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidenteventevidence.FieldEvidenceType:
		m.ResetEvidenceType()
		return nil
	case incidenteventevidence.FieldURL:
		m.ResetURL()
		return nil
	case incidenteventevidence.FieldTitle:
		m.ResetTitle()
		return nil
	case incidenteventevidence.FieldDescription:
		m.ResetDescription()
		return nil
	case incidenteventevidence.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventEvidenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, incidenteventevidence.EdgeTenant)
	}
	if m.event != nil {
		edges = append(edges, incidenteventevidence.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventEvidenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenteventevidence.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidenteventevidence.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventEvidenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventEvidenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventEvidenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, incidenteventevidence.EdgeTenant)
	}
	if m.clearedevent {
		edges = append(edges, incidenteventevidence.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventEvidenceMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenteventevidence.EdgeTenant:
		return m.clearedtenant
	case incidenteventevidence.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ClearEdge(name string) error {
	switch name {
	case incidenteventevidence.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidenteventevidence.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventEvidenceMutation) ResetEdge(name string) error {
	switch name {
	case incidenteventevidence.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidenteventevidence.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventEvidence edge %s", name)
}

// IncidentEventSystemComponentMutation represents an operation that mutates the IncidentEventSystemComponent nodes in the graph.
type IncidentEventSystemComponentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	relationship            *incidenteventsystemcomponent.Relationship
	created_at              *time.Time
	clearedFields           map[string]struct{}
	tenant                  *int
	clearedtenant           bool
	event                   *uuid.UUID
	clearedevent            bool
	system_component        *uuid.UUID
	clearedsystem_component bool
	done                    bool
	oldValue                func(context.Context) (*IncidentEventSystemComponent, error)
	predicates              []predicate.IncidentEventSystemComponent
}

var _ ent.Mutation = (*IncidentEventSystemComponentMutation)(nil)

// incidenteventsystemcomponentOption allows management of the mutation configuration using functional options.
type incidenteventsystemcomponentOption func(*IncidentEventSystemComponentMutation)

// newIncidentEventSystemComponentMutation creates new mutation for the IncidentEventSystemComponent entity.
func newIncidentEventSystemComponentMutation(c config, op Op, opts ...incidenteventsystemcomponentOption) *IncidentEventSystemComponentMutation {
	m := &IncidentEventSystemComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentEventSystemComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentEventSystemComponentID sets the ID field of the mutation.
func withIncidentEventSystemComponentID(id uuid.UUID) incidenteventsystemcomponentOption {
	return func(m *IncidentEventSystemComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentEventSystemComponent
		)
		m.oldValue = func(ctx context.Context) (*IncidentEventSystemComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentEventSystemComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentEventSystemComponent sets the old IncidentEventSystemComponent of the mutation.
func withIncidentEventSystemComponent(node *IncidentEventSystemComponent) incidenteventsystemcomponentOption {
	return func(m *IncidentEventSystemComponentMutation) {
		m.oldValue = func(context.Context) (*IncidentEventSystemComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentEventSystemComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentEventSystemComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentEventSystemComponent entities.
func (m *IncidentEventSystemComponentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentEventSystemComponentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentEventSystemComponentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentEventSystemComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentEventSystemComponentMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentEventSystemComponentMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentEventSystemComponent entity.
// If the IncidentEventSystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventSystemComponentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentEventSystemComponentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIncidentEventID sets the "incident_event_id" field.
func (m *IncidentEventSystemComponentMutation) SetIncidentEventID(u uuid.UUID) {
	m.event = &u
}

// IncidentEventID returns the value of the "incident_event_id" field in the mutation.
func (m *IncidentEventSystemComponentMutation) IncidentEventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentEventID returns the old "incident_event_id" field's value of the IncidentEventSystemComponent entity.
// If the IncidentEventSystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventSystemComponentMutation) OldIncidentEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentEventID: %w", err)
	}
	return oldValue.IncidentEventID, nil
}

// ResetIncidentEventID resets all changes to the "incident_event_id" field.
func (m *IncidentEventSystemComponentMutation) ResetIncidentEventID() {
	m.event = nil
}

// SetSystemComponentID sets the "system_component_id" field.
func (m *IncidentEventSystemComponentMutation) SetSystemComponentID(u uuid.UUID) {
	m.system_component = &u
}

// SystemComponentID returns the value of the "system_component_id" field in the mutation.
func (m *IncidentEventSystemComponentMutation) SystemComponentID() (r uuid.UUID, exists bool) {
	v := m.system_component
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemComponentID returns the old "system_component_id" field's value of the IncidentEventSystemComponent entity.
// If the IncidentEventSystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventSystemComponentMutation) OldSystemComponentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemComponentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemComponentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemComponentID: %w", err)
	}
	return oldValue.SystemComponentID, nil
}

// ResetSystemComponentID resets all changes to the "system_component_id" field.
func (m *IncidentEventSystemComponentMutation) ResetSystemComponentID() {
	m.system_component = nil
}

// SetRelationship sets the "relationship" field.
func (m *IncidentEventSystemComponentMutation) SetRelationship(i incidenteventsystemcomponent.Relationship) {
	m.relationship = &i
}

// Relationship returns the value of the "relationship" field in the mutation.
func (m *IncidentEventSystemComponentMutation) Relationship() (r incidenteventsystemcomponent.Relationship, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationship returns the old "relationship" field's value of the IncidentEventSystemComponent entity.
// If the IncidentEventSystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventSystemComponentMutation) OldRelationship(ctx context.Context) (v incidenteventsystemcomponent.Relationship, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationship is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationship requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationship: %w", err)
	}
	return oldValue.Relationship, nil
}

// ResetRelationship resets all changes to the "relationship" field.
func (m *IncidentEventSystemComponentMutation) ResetRelationship() {
	m.relationship = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IncidentEventSystemComponentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IncidentEventSystemComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IncidentEventSystemComponent entity.
// If the IncidentEventSystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentEventSystemComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IncidentEventSystemComponentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentEventSystemComponentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidenteventsystemcomponent.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentEventSystemComponentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentEventSystemComponentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentEventSystemComponentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEventID sets the "event" edge to the IncidentEventSystemComponent entity by id.
func (m *IncidentEventSystemComponentMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the IncidentEventSystemComponent entity.
func (m *IncidentEventSystemComponentMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[incidenteventsystemcomponent.FieldIncidentEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the IncidentEventSystemComponent entity was cleared.
func (m *IncidentEventSystemComponentMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *IncidentEventSystemComponentMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *IncidentEventSystemComponentMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *IncidentEventSystemComponentMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// ClearSystemComponent clears the "system_component" edge to the SystemComponent entity.
func (m *IncidentEventSystemComponentMutation) ClearSystemComponent() {
	m.clearedsystem_component = true
	m.clearedFields[incidenteventsystemcomponent.FieldSystemComponentID] = struct{}{}
}

// SystemComponentCleared reports if the "system_component" edge to the SystemComponent entity was cleared.
func (m *IncidentEventSystemComponentMutation) SystemComponentCleared() bool {
	return m.clearedsystem_component
}

// SystemComponentIDs returns the "system_component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SystemComponentID instead. It exists only for internal usage by the builders.
func (m *IncidentEventSystemComponentMutation) SystemComponentIDs() (ids []uuid.UUID) {
	if id := m.system_component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSystemComponent resets all changes to the "system_component" edge.
func (m *IncidentEventSystemComponentMutation) ResetSystemComponent() {
	m.system_component = nil
	m.clearedsystem_component = false
}

// Where appends a list predicates to the IncidentEventSystemComponentMutation builder.
func (m *IncidentEventSystemComponentMutation) Where(ps ...predicate.IncidentEventSystemComponent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentEventSystemComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentEventSystemComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentEventSystemComponent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentEventSystemComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentEventSystemComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentEventSystemComponent).
func (m *IncidentEventSystemComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentEventSystemComponentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, incidenteventsystemcomponent.FieldTenantID)
	}
	if m.event != nil {
		fields = append(fields, incidenteventsystemcomponent.FieldIncidentEventID)
	}
	if m.system_component != nil {
		fields = append(fields, incidenteventsystemcomponent.FieldSystemComponentID)
	}
	if m.relationship != nil {
		fields = append(fields, incidenteventsystemcomponent.FieldRelationship)
	}
	if m.created_at != nil {
		fields = append(fields, incidenteventsystemcomponent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentEventSystemComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenteventsystemcomponent.FieldTenantID:
		return m.TenantID()
	case incidenteventsystemcomponent.FieldIncidentEventID:
		return m.IncidentEventID()
	case incidenteventsystemcomponent.FieldSystemComponentID:
		return m.SystemComponentID()
	case incidenteventsystemcomponent.FieldRelationship:
		return m.Relationship()
	case incidenteventsystemcomponent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentEventSystemComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenteventsystemcomponent.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidenteventsystemcomponent.FieldIncidentEventID:
		return m.OldIncidentEventID(ctx)
	case incidenteventsystemcomponent.FieldSystemComponentID:
		return m.OldSystemComponentID(ctx)
	case incidenteventsystemcomponent.FieldRelationship:
		return m.OldRelationship(ctx)
	case incidenteventsystemcomponent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentEventSystemComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventSystemComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenteventsystemcomponent.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidenteventsystemcomponent.FieldIncidentEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentEventID(v)
		return nil
	case incidenteventsystemcomponent.FieldSystemComponentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemComponentID(v)
		return nil
	case incidenteventsystemcomponent.FieldRelationship:
		v, ok := value.(incidenteventsystemcomponent.Relationship)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationship(v)
		return nil
	case incidenteventsystemcomponent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentEventSystemComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentEventSystemComponentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentEventSystemComponentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentEventSystemComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentEventSystemComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentEventSystemComponentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentEventSystemComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentEventSystemComponentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentEventSystemComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentEventSystemComponentMutation) ResetField(name string) error {
	switch name {
	case incidenteventsystemcomponent.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidenteventsystemcomponent.FieldIncidentEventID:
		m.ResetIncidentEventID()
		return nil
	case incidenteventsystemcomponent.FieldSystemComponentID:
		m.ResetSystemComponentID()
		return nil
	case incidenteventsystemcomponent.FieldRelationship:
		m.ResetRelationship()
		return nil
	case incidenteventsystemcomponent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventSystemComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentEventSystemComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidenteventsystemcomponent.EdgeTenant)
	}
	if m.event != nil {
		edges = append(edges, incidenteventsystemcomponent.EdgeEvent)
	}
	if m.system_component != nil {
		edges = append(edges, incidenteventsystemcomponent.EdgeSystemComponent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentEventSystemComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenteventsystemcomponent.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidenteventsystemcomponent.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case incidenteventsystemcomponent.EdgeSystemComponent:
		if id := m.system_component; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentEventSystemComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentEventSystemComponentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentEventSystemComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidenteventsystemcomponent.EdgeTenant)
	}
	if m.clearedevent {
		edges = append(edges, incidenteventsystemcomponent.EdgeEvent)
	}
	if m.clearedsystem_component {
		edges = append(edges, incidenteventsystemcomponent.EdgeSystemComponent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentEventSystemComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenteventsystemcomponent.EdgeTenant:
		return m.clearedtenant
	case incidenteventsystemcomponent.EdgeEvent:
		return m.clearedevent
	case incidenteventsystemcomponent.EdgeSystemComponent:
		return m.clearedsystem_component
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentEventSystemComponentMutation) ClearEdge(name string) error {
	switch name {
	case incidenteventsystemcomponent.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidenteventsystemcomponent.EdgeEvent:
		m.ClearEvent()
		return nil
	case incidenteventsystemcomponent.EdgeSystemComponent:
		m.ClearSystemComponent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventSystemComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentEventSystemComponentMutation) ResetEdge(name string) error {
	switch name {
	case incidenteventsystemcomponent.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidenteventsystemcomponent.EdgeEvent:
		m.ResetEvent()
		return nil
	case incidenteventsystemcomponent.EdgeSystemComponent:
		m.ResetSystemComponent()
		return nil
	}
	return fmt.Errorf("unknown IncidentEventSystemComponent edge %s", name)
}

// IncidentFieldMutation represents an operation that mutates the IncidentField nodes in the graph.
type IncidentFieldMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	name                     *string
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	options                  map[uuid.UUID]struct{}
	removedoptions           map[uuid.UUID]struct{}
	clearedoptions           bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentField, error)
	predicates               []predicate.IncidentField
}

var _ ent.Mutation = (*IncidentFieldMutation)(nil)

// incidentfieldOption allows management of the mutation configuration using functional options.
type incidentfieldOption func(*IncidentFieldMutation)

// newIncidentFieldMutation creates new mutation for the IncidentField entity.
func newIncidentFieldMutation(c config, op Op, opts ...incidentfieldOption) *IncidentFieldMutation {
	m := &IncidentFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentFieldID sets the ID field of the mutation.
func withIncidentFieldID(id uuid.UUID) incidentfieldOption {
	return func(m *IncidentFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentField
		)
		m.oldValue = func(ctx context.Context) (*IncidentField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentField sets the old IncidentField of the mutation.
func withIncidentField(node *IncidentField) incidentfieldOption {
	return func(m *IncidentFieldMutation) {
		m.oldValue = func(context.Context) (*IncidentField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentField entities.
func (m *IncidentFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentFieldMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentFieldMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentField entity.
// If the IncidentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentFieldMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentFieldMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentFieldMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentField entity.
// If the IncidentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentFieldMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentfield.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentFieldMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentfield.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentFieldMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentfield.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *IncidentFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentField entity.
// If the IncidentField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentFieldMutation) ResetName() {
	m.name = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentFieldMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentfield.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentFieldMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentFieldMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentFieldMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddOptionIDs adds the "options" edge to the IncidentFieldOption entity by ids.
func (m *IncidentFieldMutation) AddOptionIDs(ids ...uuid.UUID) {
	if m.options == nil {
		m.options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.options[ids[i]] = struct{}{}
	}
}

// ClearOptions clears the "options" edge to the IncidentFieldOption entity.
func (m *IncidentFieldMutation) ClearOptions() {
	m.clearedoptions = true
}

// OptionsCleared reports if the "options" edge to the IncidentFieldOption entity was cleared.
func (m *IncidentFieldMutation) OptionsCleared() bool {
	return m.clearedoptions
}

// RemoveOptionIDs removes the "options" edge to the IncidentFieldOption entity by IDs.
func (m *IncidentFieldMutation) RemoveOptionIDs(ids ...uuid.UUID) {
	if m.removedoptions == nil {
		m.removedoptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.options, ids[i])
		m.removedoptions[ids[i]] = struct{}{}
	}
}

// RemovedOptions returns the removed IDs of the "options" edge to the IncidentFieldOption entity.
func (m *IncidentFieldMutation) RemovedOptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedoptions {
		ids = append(ids, id)
	}
	return
}

// OptionsIDs returns the "options" edge IDs in the mutation.
func (m *IncidentFieldMutation) OptionsIDs() (ids []uuid.UUID) {
	for id := range m.options {
		ids = append(ids, id)
	}
	return
}

// ResetOptions resets all changes to the "options" edge.
func (m *IncidentFieldMutation) ResetOptions() {
	m.options = nil
	m.clearedoptions = false
	m.removedoptions = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentFieldMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentFieldMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentFieldMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentFieldMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentFieldMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentFieldMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentFieldMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentFieldMutation builder.
func (m *IncidentFieldMutation) Where(ps ...predicate.IncidentField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentField).
func (m *IncidentFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentFieldMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, incidentfield.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, incidentfield.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, incidentfield.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentfield.FieldTenantID:
		return m.TenantID()
	case incidentfield.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentfield.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentfield.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentfield.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentfield.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentfield.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentfield.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentfield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentFieldMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentFieldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentfield.FieldArchiveTime) {
		fields = append(fields, incidentfield.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentFieldMutation) ClearField(name string) error {
	switch name {
	case incidentfield.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentFieldMutation) ResetField(name string) error {
	switch name {
	case incidentfield.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentfield.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentfield.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown IncidentField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidentfield.EdgeTenant)
	}
	if m.options != nil {
		edges = append(edges, incidentfield.EdgeOptions)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidentfield.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentfield.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentfield.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.options))
		for id := range m.options {
			ids = append(ids, id)
		}
		return ids
	case incidentfield.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedoptions != nil {
		edges = append(edges, incidentfield.EdgeOptions)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidentfield.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentFieldMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentfield.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.removedoptions))
		for id := range m.removedoptions {
			ids = append(ids, id)
		}
		return ids
	case incidentfield.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidentfield.EdgeTenant)
	}
	if m.clearedoptions {
		edges = append(edges, incidentfield.EdgeOptions)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidentfield.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentfield.EdgeTenant:
		return m.clearedtenant
	case incidentfield.EdgeOptions:
		return m.clearedoptions
	case incidentfield.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentFieldMutation) ClearEdge(name string) error {
	switch name {
	case incidentfield.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IncidentField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentFieldMutation) ResetEdge(name string) error {
	switch name {
	case incidentfield.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentfield.EdgeOptions:
		m.ResetOptions()
		return nil
	case incidentfield.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentField edge %s", name)
}

// IncidentFieldOptionMutation represents an operation that mutates the IncidentFieldOption nodes in the graph.
type IncidentFieldOptionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	archive_time          *time.Time
	_type                 *incidentfieldoption.Type
	value                 *string
	clearedFields         map[string]struct{}
	tenant                *int
	clearedtenant         bool
	incident_field        *uuid.UUID
	clearedincident_field bool
	incidents             map[uuid.UUID]struct{}
	removedincidents      map[uuid.UUID]struct{}
	clearedincidents      bool
	done                  bool
	oldValue              func(context.Context) (*IncidentFieldOption, error)
	predicates            []predicate.IncidentFieldOption
}

var _ ent.Mutation = (*IncidentFieldOptionMutation)(nil)

// incidentfieldoptionOption allows management of the mutation configuration using functional options.
type incidentfieldoptionOption func(*IncidentFieldOptionMutation)

// newIncidentFieldOptionMutation creates new mutation for the IncidentFieldOption entity.
func newIncidentFieldOptionMutation(c config, op Op, opts ...incidentfieldoptionOption) *IncidentFieldOptionMutation {
	m := &IncidentFieldOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentFieldOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentFieldOptionID sets the ID field of the mutation.
func withIncidentFieldOptionID(id uuid.UUID) incidentfieldoptionOption {
	return func(m *IncidentFieldOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentFieldOption
		)
		m.oldValue = func(ctx context.Context) (*IncidentFieldOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentFieldOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentFieldOption sets the old IncidentFieldOption of the mutation.
func withIncidentFieldOption(node *IncidentFieldOption) incidentfieldoptionOption {
	return func(m *IncidentFieldOptionMutation) {
		m.oldValue = func(context.Context) (*IncidentFieldOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentFieldOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentFieldOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentFieldOption entities.
func (m *IncidentFieldOptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentFieldOptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentFieldOptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentFieldOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentFieldOptionMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentFieldOptionMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentFieldOptionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentFieldOptionMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentFieldOptionMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentFieldOptionMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentfieldoption.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentFieldOptionMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentfieldoption.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentFieldOptionMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentfieldoption.FieldArchiveTime)
}

// SetIncidentFieldID sets the "incident_field_id" field.
func (m *IncidentFieldOptionMutation) SetIncidentFieldID(u uuid.UUID) {
	m.incident_field = &u
}

// IncidentFieldID returns the value of the "incident_field_id" field in the mutation.
func (m *IncidentFieldOptionMutation) IncidentFieldID() (r uuid.UUID, exists bool) {
	v := m.incident_field
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentFieldID returns the old "incident_field_id" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldIncidentFieldID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentFieldID: %w", err)
	}
	return oldValue.IncidentFieldID, nil
}

// ResetIncidentFieldID resets all changes to the "incident_field_id" field.
func (m *IncidentFieldOptionMutation) ResetIncidentFieldID() {
	m.incident_field = nil
}

// SetType sets the "type" field.
func (m *IncidentFieldOptionMutation) SetType(i incidentfieldoption.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *IncidentFieldOptionMutation) GetType() (r incidentfieldoption.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldType(ctx context.Context) (v incidentfieldoption.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IncidentFieldOptionMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *IncidentFieldOptionMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *IncidentFieldOptionMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the IncidentFieldOption entity.
// If the IncidentFieldOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentFieldOptionMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *IncidentFieldOptionMutation) ResetValue() {
	m.value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentFieldOptionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentfieldoption.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentFieldOptionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentFieldOptionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentFieldOptionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearIncidentField clears the "incident_field" edge to the IncidentField entity.
func (m *IncidentFieldOptionMutation) ClearIncidentField() {
	m.clearedincident_field = true
	m.clearedFields[incidentfieldoption.FieldIncidentFieldID] = struct{}{}
}

// IncidentFieldCleared reports if the "incident_field" edge to the IncidentField entity was cleared.
func (m *IncidentFieldOptionMutation) IncidentFieldCleared() bool {
	return m.clearedincident_field
}

// IncidentFieldIDs returns the "incident_field" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentFieldID instead. It exists only for internal usage by the builders.
func (m *IncidentFieldOptionMutation) IncidentFieldIDs() (ids []uuid.UUID) {
	if id := m.incident_field; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncidentField resets all changes to the "incident_field" edge.
func (m *IncidentFieldOptionMutation) ResetIncidentField() {
	m.incident_field = nil
	m.clearedincident_field = false
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentFieldOptionMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentFieldOptionMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentFieldOptionMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentFieldOptionMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentFieldOptionMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentFieldOptionMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentFieldOptionMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// Where appends a list predicates to the IncidentFieldOptionMutation builder.
func (m *IncidentFieldOptionMutation) Where(ps ...predicate.IncidentFieldOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentFieldOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentFieldOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentFieldOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentFieldOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentFieldOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentFieldOption).
func (m *IncidentFieldOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentFieldOptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, incidentfieldoption.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, incidentfieldoption.FieldArchiveTime)
	}
	if m.incident_field != nil {
		fields = append(fields, incidentfieldoption.FieldIncidentFieldID)
	}
	if m._type != nil {
		fields = append(fields, incidentfieldoption.FieldType)
	}
	if m.value != nil {
		fields = append(fields, incidentfieldoption.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentFieldOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentfieldoption.FieldTenantID:
		return m.TenantID()
	case incidentfieldoption.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentfieldoption.FieldIncidentFieldID:
		return m.IncidentFieldID()
	case incidentfieldoption.FieldType:
		return m.GetType()
	case incidentfieldoption.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentFieldOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentfieldoption.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentfieldoption.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentfieldoption.FieldIncidentFieldID:
		return m.OldIncidentFieldID(ctx)
	case incidentfieldoption.FieldType:
		return m.OldType(ctx)
	case incidentfieldoption.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentFieldOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentfieldoption.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentfieldoption.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentfieldoption.FieldIncidentFieldID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentFieldID(v)
		return nil
	case incidentfieldoption.FieldType:
		v, ok := value.(incidentfieldoption.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case incidentfieldoption.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentFieldOptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentFieldOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentFieldOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentFieldOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentFieldOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentfieldoption.FieldArchiveTime) {
		fields = append(fields, incidentfieldoption.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentFieldOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentFieldOptionMutation) ClearField(name string) error {
	switch name {
	case incidentfieldoption.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentFieldOptionMutation) ResetField(name string) error {
	switch name {
	case incidentfieldoption.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentfieldoption.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentfieldoption.FieldIncidentFieldID:
		m.ResetIncidentFieldID()
		return nil
	case incidentfieldoption.FieldType:
		m.ResetType()
		return nil
	case incidentfieldoption.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentFieldOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidentfieldoption.EdgeTenant)
	}
	if m.incident_field != nil {
		edges = append(edges, incidentfieldoption.EdgeIncidentField)
	}
	if m.incidents != nil {
		edges = append(edges, incidentfieldoption.EdgeIncidents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentFieldOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentfieldoption.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentfieldoption.EdgeIncidentField:
		if id := m.incident_field; id != nil {
			return []ent.Value{*id}
		}
	case incidentfieldoption.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentFieldOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedincidents != nil {
		edges = append(edges, incidentfieldoption.EdgeIncidents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentFieldOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentfieldoption.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentFieldOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidentfieldoption.EdgeTenant)
	}
	if m.clearedincident_field {
		edges = append(edges, incidentfieldoption.EdgeIncidentField)
	}
	if m.clearedincidents {
		edges = append(edges, incidentfieldoption.EdgeIncidents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentFieldOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentfieldoption.EdgeTenant:
		return m.clearedtenant
	case incidentfieldoption.EdgeIncidentField:
		return m.clearedincident_field
	case incidentfieldoption.EdgeIncidents:
		return m.clearedincidents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentFieldOptionMutation) ClearEdge(name string) error {
	switch name {
	case incidentfieldoption.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentfieldoption.EdgeIncidentField:
		m.ClearIncidentField()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentFieldOptionMutation) ResetEdge(name string) error {
	switch name {
	case incidentfieldoption.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentfieldoption.EdgeIncidentField:
		m.ResetIncidentField()
		return nil
	case incidentfieldoption.EdgeIncidents:
		m.ResetIncidents()
		return nil
	}
	return fmt.Errorf("unknown IncidentFieldOption edge %s", name)
}

// IncidentLinkMutation represents an operation that mutates the IncidentLink nodes in the graph.
type IncidentLinkMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	description            *string
	link_type              *incidentlink.LinkType
	clearedFields          map[string]struct{}
	tenant                 *int
	clearedtenant          bool
	incident               *uuid.UUID
	clearedincident        bool
	linked_incident        *uuid.UUID
	clearedlinked_incident bool
	done                   bool
	oldValue               func(context.Context) (*IncidentLink, error)
	predicates             []predicate.IncidentLink
}

var _ ent.Mutation = (*IncidentLinkMutation)(nil)

// incidentlinkOption allows management of the mutation configuration using functional options.
type incidentlinkOption func(*IncidentLinkMutation)

// newIncidentLinkMutation creates new mutation for the IncidentLink entity.
func newIncidentLinkMutation(c config, op Op, opts ...incidentlinkOption) *IncidentLinkMutation {
	m := &IncidentLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentLinkID sets the ID field of the mutation.
func withIncidentLinkID(id int) incidentlinkOption {
	return func(m *IncidentLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentLink
		)
		m.oldValue = func(ctx context.Context) (*IncidentLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentLink sets the old IncidentLink of the mutation.
func withIncidentLink(node *IncidentLink) incidentlinkOption {
	return func(m *IncidentLinkMutation) {
		m.oldValue = func(context.Context) (*IncidentLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentLinkMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentLinkMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentLinkMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentLinkMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentLinkMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentLinkMutation) ResetIncidentID() {
	m.incident = nil
}

// SetLinkedIncidentID sets the "linked_incident_id" field.
func (m *IncidentLinkMutation) SetLinkedIncidentID(u uuid.UUID) {
	m.linked_incident = &u
}

// LinkedIncidentID returns the value of the "linked_incident_id" field in the mutation.
func (m *IncidentLinkMutation) LinkedIncidentID() (r uuid.UUID, exists bool) {
	v := m.linked_incident
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedIncidentID returns the old "linked_incident_id" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldLinkedIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedIncidentID: %w", err)
	}
	return oldValue.LinkedIncidentID, nil
}

// ResetLinkedIncidentID resets all changes to the "linked_incident_id" field.
func (m *IncidentLinkMutation) ResetLinkedIncidentID() {
	m.linked_incident = nil
}

// SetDescription sets the "description" field.
func (m *IncidentLinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentLinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentLinkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentlink.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentLinkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentlink.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentLinkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentlink.FieldDescription)
}

// SetLinkType sets the "link_type" field.
func (m *IncidentLinkMutation) SetLinkType(it incidentlink.LinkType) {
	m.link_type = &it
}

// LinkType returns the value of the "link_type" field in the mutation.
func (m *IncidentLinkMutation) LinkType() (r incidentlink.LinkType, exists bool) {
	v := m.link_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkType returns the old "link_type" field's value of the IncidentLink entity.
// If the IncidentLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentLinkMutation) OldLinkType(ctx context.Context) (v incidentlink.LinkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkType: %w", err)
	}
	return oldValue.LinkType, nil
}

// ResetLinkType resets all changes to the "link_type" field.
func (m *IncidentLinkMutation) ResetLinkType() {
	m.link_type = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentLinkMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentlink.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentLinkMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentLinkMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentLinkMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentLinkMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentlink.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentLinkMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentLinkMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentLinkMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearLinkedIncident clears the "linked_incident" edge to the Incident entity.
func (m *IncidentLinkMutation) ClearLinkedIncident() {
	m.clearedlinked_incident = true
	m.clearedFields[incidentlink.FieldLinkedIncidentID] = struct{}{}
}

// LinkedIncidentCleared reports if the "linked_incident" edge to the Incident entity was cleared.
func (m *IncidentLinkMutation) LinkedIncidentCleared() bool {
	return m.clearedlinked_incident
}

// LinkedIncidentIDs returns the "linked_incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkedIncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentLinkMutation) LinkedIncidentIDs() (ids []uuid.UUID) {
	if id := m.linked_incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLinkedIncident resets all changes to the "linked_incident" edge.
func (m *IncidentLinkMutation) ResetLinkedIncident() {
	m.linked_incident = nil
	m.clearedlinked_incident = false
}

// Where appends a list predicates to the IncidentLinkMutation builder.
func (m *IncidentLinkMutation) Where(ps ...predicate.IncidentLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentLink).
func (m *IncidentLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentLinkMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, incidentlink.FieldTenantID)
	}
	if m.incident != nil {
		fields = append(fields, incidentlink.FieldIncidentID)
	}
	if m.linked_incident != nil {
		fields = append(fields, incidentlink.FieldLinkedIncidentID)
	}
	if m.description != nil {
		fields = append(fields, incidentlink.FieldDescription)
	}
	if m.link_type != nil {
		fields = append(fields, incidentlink.FieldLinkType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentlink.FieldTenantID:
		return m.TenantID()
	case incidentlink.FieldIncidentID:
		return m.IncidentID()
	case incidentlink.FieldLinkedIncidentID:
		return m.LinkedIncidentID()
	case incidentlink.FieldDescription:
		return m.Description()
	case incidentlink.FieldLinkType:
		return m.LinkType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentlink.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentlink.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentlink.FieldLinkedIncidentID:
		return m.OldLinkedIncidentID(ctx)
	case incidentlink.FieldDescription:
		return m.OldDescription(ctx)
	case incidentlink.FieldLinkType:
		return m.OldLinkType(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentlink.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentlink.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentlink.FieldLinkedIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedIncidentID(v)
		return nil
	case incidentlink.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentlink.FieldLinkType:
		v, ok := value.(incidentlink.LinkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkType(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentLinkMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentlink.FieldDescription) {
		fields = append(fields, incidentlink.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentLinkMutation) ClearField(name string) error {
	switch name {
	case incidentlink.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentLinkMutation) ResetField(name string) error {
	switch name {
	case incidentlink.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentlink.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentlink.FieldLinkedIncidentID:
		m.ResetLinkedIncidentID()
		return nil
	case incidentlink.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentlink.FieldLinkType:
		m.ResetLinkType()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidentlink.EdgeTenant)
	}
	if m.incident != nil {
		edges = append(edges, incidentlink.EdgeIncident)
	}
	if m.linked_incident != nil {
		edges = append(edges, incidentlink.EdgeLinkedIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentlink.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentlink.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentlink.EdgeLinkedIncident:
		if id := m.linked_incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidentlink.EdgeTenant)
	}
	if m.clearedincident {
		edges = append(edges, incidentlink.EdgeIncident)
	}
	if m.clearedlinked_incident {
		edges = append(edges, incidentlink.EdgeLinkedIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentlink.EdgeTenant:
		return m.clearedtenant
	case incidentlink.EdgeIncident:
		return m.clearedincident
	case incidentlink.EdgeLinkedIncident:
		return m.clearedlinked_incident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentLinkMutation) ClearEdge(name string) error {
	switch name {
	case incidentlink.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentlink.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentlink.EdgeLinkedIncident:
		m.ClearLinkedIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentLinkMutation) ResetEdge(name string) error {
	switch name {
	case incidentlink.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentlink.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentlink.EdgeLinkedIncident:
		m.ResetLinkedIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentLink edge %s", name)
}

// IncidentMilestoneMutation represents an operation that mutates the IncidentMilestone nodes in the graph.
type IncidentMilestoneMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	kind            *incidentmilestone.Kind
	timestamp       *time.Time
	description     *string
	source          *string
	external_id     *string
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	incident        *uuid.UUID
	clearedincident bool
	done            bool
	oldValue        func(context.Context) (*IncidentMilestone, error)
	predicates      []predicate.IncidentMilestone
}

var _ ent.Mutation = (*IncidentMilestoneMutation)(nil)

// incidentmilestoneOption allows management of the mutation configuration using functional options.
type incidentmilestoneOption func(*IncidentMilestoneMutation)

// newIncidentMilestoneMutation creates new mutation for the IncidentMilestone entity.
func newIncidentMilestoneMutation(c config, op Op, opts ...incidentmilestoneOption) *IncidentMilestoneMutation {
	m := &IncidentMilestoneMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentMilestone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentMilestoneID sets the ID field of the mutation.
func withIncidentMilestoneID(id uuid.UUID) incidentmilestoneOption {
	return func(m *IncidentMilestoneMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentMilestone
		)
		m.oldValue = func(ctx context.Context) (*IncidentMilestone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentMilestone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentMilestone sets the old IncidentMilestone of the mutation.
func withIncidentMilestone(node *IncidentMilestone) incidentmilestoneOption {
	return func(m *IncidentMilestoneMutation) {
		m.oldValue = func(context.Context) (*IncidentMilestone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMilestoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMilestoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentMilestone entities.
func (m *IncidentMilestoneMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMilestoneMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMilestoneMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentMilestone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentMilestoneMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentMilestoneMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentMilestoneMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentMilestoneMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentMilestoneMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentMilestoneMutation) ResetIncidentID() {
	m.incident = nil
}

// SetKind sets the "kind" field.
func (m *IncidentMilestoneMutation) SetKind(i incidentmilestone.Kind) {
	m.kind = &i
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IncidentMilestoneMutation) Kind() (r incidentmilestone.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldKind(ctx context.Context) (v incidentmilestone.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *IncidentMilestoneMutation) ResetKind() {
	m.kind = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *IncidentMilestoneMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *IncidentMilestoneMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *IncidentMilestoneMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetDescription sets the "description" field.
func (m *IncidentMilestoneMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentMilestoneMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentMilestoneMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentmilestone.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentMilestoneMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentmilestone.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentMilestoneMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentmilestone.FieldDescription)
}

// SetSource sets the "source" field.
func (m *IncidentMilestoneMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *IncidentMilestoneMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *IncidentMilestoneMutation) ClearSource() {
	m.source = nil
	m.clearedFields[incidentmilestone.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *IncidentMilestoneMutation) SourceCleared() bool {
	_, ok := m.clearedFields[incidentmilestone.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *IncidentMilestoneMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, incidentmilestone.FieldSource)
}

// SetExternalID sets the "external_id" field.
func (m *IncidentMilestoneMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *IncidentMilestoneMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the IncidentMilestone entity.
// If the IncidentMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMilestoneMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *IncidentMilestoneMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[incidentmilestone.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *IncidentMilestoneMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[incidentmilestone.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *IncidentMilestoneMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, incidentmilestone.FieldExternalID)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentMilestoneMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentmilestone.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentMilestoneMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentMilestoneMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentMilestoneMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentMilestoneMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentmilestone.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentMilestoneMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentMilestoneMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentMilestoneMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// Where appends a list predicates to the IncidentMilestoneMutation builder.
func (m *IncidentMilestoneMutation) Where(ps ...predicate.IncidentMilestone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentMilestoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentMilestoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentMilestone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentMilestoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentMilestoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentMilestone).
func (m *IncidentMilestoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMilestoneMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, incidentmilestone.FieldTenantID)
	}
	if m.incident != nil {
		fields = append(fields, incidentmilestone.FieldIncidentID)
	}
	if m.kind != nil {
		fields = append(fields, incidentmilestone.FieldKind)
	}
	if m.timestamp != nil {
		fields = append(fields, incidentmilestone.FieldTimestamp)
	}
	if m.description != nil {
		fields = append(fields, incidentmilestone.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, incidentmilestone.FieldSource)
	}
	if m.external_id != nil {
		fields = append(fields, incidentmilestone.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMilestoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentmilestone.FieldTenantID:
		return m.TenantID()
	case incidentmilestone.FieldIncidentID:
		return m.IncidentID()
	case incidentmilestone.FieldKind:
		return m.Kind()
	case incidentmilestone.FieldTimestamp:
		return m.Timestamp()
	case incidentmilestone.FieldDescription:
		return m.Description()
	case incidentmilestone.FieldSource:
		return m.Source()
	case incidentmilestone.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMilestoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentmilestone.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentmilestone.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentmilestone.FieldKind:
		return m.OldKind(ctx)
	case incidentmilestone.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case incidentmilestone.FieldDescription:
		return m.OldDescription(ctx)
	case incidentmilestone.FieldSource:
		return m.OldSource(ctx)
	case incidentmilestone.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentMilestone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMilestoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentmilestone.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentmilestone.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentmilestone.FieldKind:
		v, ok := value.(incidentmilestone.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case incidentmilestone.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case incidentmilestone.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case incidentmilestone.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case incidentmilestone.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMilestoneMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMilestoneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMilestoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentMilestone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMilestoneMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentmilestone.FieldDescription) {
		fields = append(fields, incidentmilestone.FieldDescription)
	}
	if m.FieldCleared(incidentmilestone.FieldSource) {
		fields = append(fields, incidentmilestone.FieldSource)
	}
	if m.FieldCleared(incidentmilestone.FieldExternalID) {
		fields = append(fields, incidentmilestone.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMilestoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMilestoneMutation) ClearField(name string) error {
	switch name {
	case incidentmilestone.FieldDescription:
		m.ClearDescription()
		return nil
	case incidentmilestone.FieldSource:
		m.ClearSource()
		return nil
	case incidentmilestone.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMilestoneMutation) ResetField(name string) error {
	switch name {
	case incidentmilestone.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentmilestone.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentmilestone.FieldKind:
		m.ResetKind()
		return nil
	case incidentmilestone.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case incidentmilestone.FieldDescription:
		m.ResetDescription()
		return nil
	case incidentmilestone.FieldSource:
		m.ResetSource()
		return nil
	case incidentmilestone.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMilestoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, incidentmilestone.EdgeTenant)
	}
	if m.incident != nil {
		edges = append(edges, incidentmilestone.EdgeIncident)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMilestoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentmilestone.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentmilestone.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMilestoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMilestoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMilestoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, incidentmilestone.EdgeTenant)
	}
	if m.clearedincident {
		edges = append(edges, incidentmilestone.EdgeIncident)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMilestoneMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentmilestone.EdgeTenant:
		return m.clearedtenant
	case incidentmilestone.EdgeIncident:
		return m.clearedincident
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMilestoneMutation) ClearEdge(name string) error {
	switch name {
	case incidentmilestone.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentmilestone.EdgeIncident:
		m.ClearIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMilestoneMutation) ResetEdge(name string) error {
	switch name {
	case incidentmilestone.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentmilestone.EdgeIncident:
		m.ResetIncident()
		return nil
	}
	return fmt.Errorf("unknown IncidentMilestone edge %s", name)
}

// IncidentRoleMutation represents an operation that mutates the IncidentRole nodes in the graph.
type IncidentRoleMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	external_id              *string
	name                     *string
	required                 *bool
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	assignments              map[uuid.UUID]struct{}
	removedassignments       map[uuid.UUID]struct{}
	clearedassignments       bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentRole, error)
	predicates               []predicate.IncidentRole
}

var _ ent.Mutation = (*IncidentRoleMutation)(nil)

// incidentroleOption allows management of the mutation configuration using functional options.
type incidentroleOption func(*IncidentRoleMutation)

// newIncidentRoleMutation creates new mutation for the IncidentRole entity.
func newIncidentRoleMutation(c config, op Op, opts ...incidentroleOption) *IncidentRoleMutation {
	m := &IncidentRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentRoleID sets the ID field of the mutation.
func withIncidentRoleID(id uuid.UUID) incidentroleOption {
	return func(m *IncidentRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentRole
		)
		m.oldValue = func(ctx context.Context) (*IncidentRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentRole sets the old IncidentRole of the mutation.
func withIncidentRole(node *IncidentRole) incidentroleOption {
	return func(m *IncidentRoleMutation) {
		m.oldValue = func(context.Context) (*IncidentRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentRole entities.
func (m *IncidentRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentRoleMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentRoleMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentRoleMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentRoleMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentRoleMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentRoleMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentrole.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentRoleMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentrole.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentRoleMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentrole.FieldArchiveTime)
}

// SetExternalID sets the "external_id" field.
func (m *IncidentRoleMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *IncidentRoleMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *IncidentRoleMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[incidentrole.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *IncidentRoleMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[incidentrole.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *IncidentRoleMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, incidentrole.FieldExternalID)
}

// SetName sets the "name" field.
func (m *IncidentRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentRoleMutation) ResetName() {
	m.name = nil
}

// SetRequired sets the "required" field.
func (m *IncidentRoleMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *IncidentRoleMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the IncidentRole entity.
// If the IncidentRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *IncidentRoleMutation) ResetRequired() {
	m.required = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentRoleMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentrole.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentRoleMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentRoleMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddAssignmentIDs adds the "assignments" edge to the IncidentRoleAssignment entity by ids.
func (m *IncidentRoleMutation) AddAssignmentIDs(ids ...uuid.UUID) {
	if m.assignments == nil {
		m.assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentRoleMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the IncidentRoleAssignment entity was cleared.
func (m *IncidentRoleMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the IncidentRoleAssignment entity by IDs.
func (m *IncidentRoleMutation) RemoveAssignmentIDs(ids ...uuid.UUID) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the IncidentRoleAssignment entity.
func (m *IncidentRoleMutation) RemovedAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *IncidentRoleMutation) AssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *IncidentRoleMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentRoleMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentRoleMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentRoleMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentRoleMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentRoleMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentRoleMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentRoleMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentRoleMutation builder.
func (m *IncidentRoleMutation) Where(ps ...predicate.IncidentRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentRole).
func (m *IncidentRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, incidentrole.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, incidentrole.FieldArchiveTime)
	}
	if m.external_id != nil {
		fields = append(fields, incidentrole.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, incidentrole.FieldName)
	}
	if m.required != nil {
		fields = append(fields, incidentrole.FieldRequired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentrole.FieldTenantID:
		return m.TenantID()
	case incidentrole.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentrole.FieldExternalID:
		return m.ExternalID()
	case incidentrole.FieldName:
		return m.Name()
	case incidentrole.FieldRequired:
		return m.Required()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentrole.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentrole.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentrole.FieldExternalID:
		return m.OldExternalID(ctx)
	case incidentrole.FieldName:
		return m.OldName(ctx)
	case incidentrole.FieldRequired:
		return m.OldRequired(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentrole.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentrole.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentrole.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case incidentrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case incidentrole.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentrole.FieldArchiveTime) {
		fields = append(fields, incidentrole.FieldArchiveTime)
	}
	if m.FieldCleared(incidentrole.FieldExternalID) {
		fields = append(fields, incidentrole.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentRoleMutation) ClearField(name string) error {
	switch name {
	case incidentrole.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case incidentrole.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown IncidentRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentRoleMutation) ResetField(name string) error {
	switch name {
	case incidentrole.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentrole.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentrole.FieldExternalID:
		m.ResetExternalID()
		return nil
	case incidentrole.FieldName:
		m.ResetName()
		return nil
	case incidentrole.FieldRequired:
		m.ResetRequired()
		return nil
	}
	return fmt.Errorf("unknown IncidentRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidentrole.EdgeTenant)
	}
	if m.assignments != nil {
		edges = append(edges, incidentrole.EdgeAssignments)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidentrole.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentrole.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentrole.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case incidentrole.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedassignments != nil {
		edges = append(edges, incidentrole.EdgeAssignments)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidentrole.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentrole.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case incidentrole.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidentrole.EdgeTenant)
	}
	if m.clearedassignments {
		edges = append(edges, incidentrole.EdgeAssignments)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidentrole.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentrole.EdgeTenant:
		return m.clearedtenant
	case incidentrole.EdgeAssignments:
		return m.clearedassignments
	case incidentrole.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentRoleMutation) ClearEdge(name string) error {
	switch name {
	case incidentrole.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IncidentRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentRoleMutation) ResetEdge(name string) error {
	switch name {
	case incidentrole.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentrole.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case incidentrole.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentRole edge %s", name)
}

// IncidentRoleAssignmentMutation represents an operation that mutates the IncidentRoleAssignment nodes in the graph.
type IncidentRoleAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	incident        *uuid.UUID
	clearedincident bool
	user            *uuid.UUID
	cleareduser     bool
	role            *uuid.UUID
	clearedrole     bool
	done            bool
	oldValue        func(context.Context) (*IncidentRoleAssignment, error)
	predicates      []predicate.IncidentRoleAssignment
}

var _ ent.Mutation = (*IncidentRoleAssignmentMutation)(nil)

// incidentroleassignmentOption allows management of the mutation configuration using functional options.
type incidentroleassignmentOption func(*IncidentRoleAssignmentMutation)

// newIncidentRoleAssignmentMutation creates new mutation for the IncidentRoleAssignment entity.
func newIncidentRoleAssignmentMutation(c config, op Op, opts ...incidentroleassignmentOption) *IncidentRoleAssignmentMutation {
	m := &IncidentRoleAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentRoleAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentRoleAssignmentID sets the ID field of the mutation.
func withIncidentRoleAssignmentID(id uuid.UUID) incidentroleassignmentOption {
	return func(m *IncidentRoleAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentRoleAssignment
		)
		m.oldValue = func(ctx context.Context) (*IncidentRoleAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentRoleAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentRoleAssignment sets the old IncidentRoleAssignment of the mutation.
func withIncidentRoleAssignment(node *IncidentRoleAssignment) incidentroleassignmentOption {
	return func(m *IncidentRoleAssignmentMutation) {
		m.oldValue = func(context.Context) (*IncidentRoleAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentRoleAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentRoleAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentRoleAssignment entities.
func (m *IncidentRoleAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentRoleAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentRoleAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentRoleAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentRoleAssignmentMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentRoleAssignmentMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentRoleAssignment entity.
// If the IncidentRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleAssignmentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentRoleAssignmentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *IncidentRoleAssignmentMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *IncidentRoleAssignmentMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the IncidentRoleAssignment entity.
// If the IncidentRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleAssignmentMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *IncidentRoleAssignmentMutation) ResetIncidentID() {
	m.incident = nil
}

// SetUserID sets the "user_id" field.
func (m *IncidentRoleAssignmentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IncidentRoleAssignmentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IncidentRoleAssignment entity.
// If the IncidentRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleAssignmentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IncidentRoleAssignmentMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *IncidentRoleAssignmentMutation) SetRoleID(u uuid.UUID) {
	m.role = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *IncidentRoleAssignmentMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the IncidentRoleAssignment entity.
// If the IncidentRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentRoleAssignmentMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *IncidentRoleAssignmentMutation) ResetRoleID() {
	m.role = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentRoleAssignmentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentroleassignment.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentRoleAssignmentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleAssignmentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentRoleAssignmentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *IncidentRoleAssignmentMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[incidentroleassignment.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *IncidentRoleAssignmentMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleAssignmentMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *IncidentRoleAssignmentMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *IncidentRoleAssignmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[incidentroleassignment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IncidentRoleAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleAssignmentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IncidentRoleAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the IncidentRole entity.
func (m *IncidentRoleAssignmentMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[incidentroleassignment.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the IncidentRole entity was cleared.
func (m *IncidentRoleAssignmentMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *IncidentRoleAssignmentMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *IncidentRoleAssignmentMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the IncidentRoleAssignmentMutation builder.
func (m *IncidentRoleAssignmentMutation) Where(ps ...predicate.IncidentRoleAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentRoleAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentRoleAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentRoleAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentRoleAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentRoleAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentRoleAssignment).
func (m *IncidentRoleAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentRoleAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, incidentroleassignment.FieldTenantID)
	}
	if m.incident != nil {
		fields = append(fields, incidentroleassignment.FieldIncidentID)
	}
	if m.user != nil {
		fields = append(fields, incidentroleassignment.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, incidentroleassignment.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentRoleAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentroleassignment.FieldTenantID:
		return m.TenantID()
	case incidentroleassignment.FieldIncidentID:
		return m.IncidentID()
	case incidentroleassignment.FieldUserID:
		return m.UserID()
	case incidentroleassignment.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentRoleAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentroleassignment.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentroleassignment.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incidentroleassignment.FieldUserID:
		return m.OldUserID(ctx)
	case incidentroleassignment.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentRoleAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentroleassignment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentroleassignment.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incidentroleassignment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case incidentroleassignment.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentRoleAssignmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentRoleAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentRoleAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentRoleAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentRoleAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentRoleAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncidentRoleAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ResetField(name string) error {
	switch name {
	case incidentroleassignment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentroleassignment.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incidentroleassignment.FieldUserID:
		m.ResetUserID()
		return nil
	case incidentroleassignment.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentRoleAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, incidentroleassignment.EdgeTenant)
	}
	if m.incident != nil {
		edges = append(edges, incidentroleassignment.EdgeIncident)
	}
	if m.user != nil {
		edges = append(edges, incidentroleassignment.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, incidentroleassignment.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentRoleAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentroleassignment.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentroleassignment.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case incidentroleassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case incidentroleassignment.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentRoleAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentRoleAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentRoleAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, incidentroleassignment.EdgeTenant)
	}
	if m.clearedincident {
		edges = append(edges, incidentroleassignment.EdgeIncident)
	}
	if m.cleareduser {
		edges = append(edges, incidentroleassignment.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, incidentroleassignment.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentRoleAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentroleassignment.EdgeTenant:
		return m.clearedtenant
	case incidentroleassignment.EdgeIncident:
		return m.clearedincident
	case incidentroleassignment.EdgeUser:
		return m.cleareduser
	case incidentroleassignment.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case incidentroleassignment.EdgeTenant:
		m.ClearTenant()
		return nil
	case incidentroleassignment.EdgeIncident:
		m.ClearIncident()
		return nil
	case incidentroleassignment.EdgeUser:
		m.ClearUser()
		return nil
	case incidentroleassignment.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentRoleAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case incidentroleassignment.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentroleassignment.EdgeIncident:
		m.ResetIncident()
		return nil
	case incidentroleassignment.EdgeUser:
		m.ResetUser()
		return nil
	case incidentroleassignment.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown IncidentRoleAssignment edge %s", name)
}

// IncidentSeverityMutation represents an operation that mutates the IncidentSeverity nodes in the graph.
type IncidentSeverityMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	external_id              *string
	name                     *string
	rank                     *int
	addrank                  *int
	color                    *string
	description              *string
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	incidents                map[uuid.UUID]struct{}
	removedincidents         map[uuid.UUID]struct{}
	clearedincidents         bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentSeverity, error)
	predicates               []predicate.IncidentSeverity
}

var _ ent.Mutation = (*IncidentSeverityMutation)(nil)

// incidentseverityOption allows management of the mutation configuration using functional options.
type incidentseverityOption func(*IncidentSeverityMutation)

// newIncidentSeverityMutation creates new mutation for the IncidentSeverity entity.
func newIncidentSeverityMutation(c config, op Op, opts ...incidentseverityOption) *IncidentSeverityMutation {
	m := &IncidentSeverityMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentSeverity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentSeverityID sets the ID field of the mutation.
func withIncidentSeverityID(id uuid.UUID) incidentseverityOption {
	return func(m *IncidentSeverityMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentSeverity
		)
		m.oldValue = func(ctx context.Context) (*IncidentSeverity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentSeverity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentSeverity sets the old IncidentSeverity of the mutation.
func withIncidentSeverity(node *IncidentSeverity) incidentseverityOption {
	return func(m *IncidentSeverityMutation) {
		m.oldValue = func(context.Context) (*IncidentSeverity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentSeverityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentSeverityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentSeverity entities.
func (m *IncidentSeverityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentSeverityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentSeverityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentSeverity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentSeverityMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentSeverityMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentSeverityMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentSeverityMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentSeverityMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentSeverityMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidentseverity.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentSeverityMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidentseverity.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentSeverityMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidentseverity.FieldArchiveTime)
}

// SetExternalID sets the "external_id" field.
func (m *IncidentSeverityMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *IncidentSeverityMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *IncidentSeverityMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[incidentseverity.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *IncidentSeverityMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[incidentseverity.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *IncidentSeverityMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, incidentseverity.FieldExternalID)
}

// SetName sets the "name" field.
func (m *IncidentSeverityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentSeverityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentSeverityMutation) ResetName() {
	m.name = nil
}

// SetRank sets the "rank" field.
func (m *IncidentSeverityMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *IncidentSeverityMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *IncidentSeverityMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *IncidentSeverityMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *IncidentSeverityMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetColor sets the "color" field.
func (m *IncidentSeverityMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *IncidentSeverityMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *IncidentSeverityMutation) ClearColor() {
	m.color = nil
	m.clearedFields[incidentseverity.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *IncidentSeverityMutation) ColorCleared() bool {
	_, ok := m.clearedFields[incidentseverity.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *IncidentSeverityMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, incidentseverity.FieldColor)
}

// SetDescription sets the "description" field.
func (m *IncidentSeverityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IncidentSeverityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IncidentSeverity entity.
// If the IncidentSeverity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentSeverityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IncidentSeverityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[incidentseverity.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IncidentSeverityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[incidentseverity.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IncidentSeverityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, incidentseverity.FieldDescription)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentSeverityMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidentseverity.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentSeverityMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentSeverityMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentSeverityMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentSeverityMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentSeverityMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentSeverityMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentSeverityMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentSeverityMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentSeverityMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentSeverityMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentSeverityMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentSeverityMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentSeverityMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentSeverityMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentSeverityMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentSeverityMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentSeverityMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentSeverityMutation builder.
func (m *IncidentSeverityMutation) Where(ps ...predicate.IncidentSeverity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentSeverityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentSeverityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentSeverity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentSeverityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentSeverityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentSeverity).
func (m *IncidentSeverityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentSeverityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, incidentseverity.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, incidentseverity.FieldArchiveTime)
	}
	if m.external_id != nil {
		fields = append(fields, incidentseverity.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, incidentseverity.FieldName)
	}
	if m.rank != nil {
		fields = append(fields, incidentseverity.FieldRank)
	}
	if m.color != nil {
		fields = append(fields, incidentseverity.FieldColor)
	}
	if m.description != nil {
		fields = append(fields, incidentseverity.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentSeverityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidentseverity.FieldTenantID:
		return m.TenantID()
	case incidentseverity.FieldArchiveTime:
		return m.ArchiveTime()
	case incidentseverity.FieldExternalID:
		return m.ExternalID()
	case incidentseverity.FieldName:
		return m.Name()
	case incidentseverity.FieldRank:
		return m.Rank()
	case incidentseverity.FieldColor:
		return m.Color()
	case incidentseverity.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentSeverityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidentseverity.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidentseverity.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidentseverity.FieldExternalID:
		return m.OldExternalID(ctx)
	case incidentseverity.FieldName:
		return m.OldName(ctx)
	case incidentseverity.FieldRank:
		return m.OldRank(ctx)
	case incidentseverity.FieldColor:
		return m.OldColor(ctx)
	case incidentseverity.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentSeverity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentSeverityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidentseverity.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidentseverity.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidentseverity.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case incidentseverity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case incidentseverity.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case incidentseverity.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case incidentseverity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentSeverityMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, incidentseverity.FieldRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentSeverityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incidentseverity.FieldRank:
		return m.AddedRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentSeverityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incidentseverity.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentSeverityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidentseverity.FieldArchiveTime) {
		fields = append(fields, incidentseverity.FieldArchiveTime)
	}
	if m.FieldCleared(incidentseverity.FieldExternalID) {
		fields = append(fields, incidentseverity.FieldExternalID)
	}
	if m.FieldCleared(incidentseverity.FieldColor) {
		fields = append(fields, incidentseverity.FieldColor)
	}
	if m.FieldCleared(incidentseverity.FieldDescription) {
		fields = append(fields, incidentseverity.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentSeverityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentSeverityMutation) ClearField(name string) error {
	switch name {
	case incidentseverity.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case incidentseverity.FieldExternalID:
		m.ClearExternalID()
		return nil
	case incidentseverity.FieldColor:
		m.ClearColor()
		return nil
	case incidentseverity.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentSeverityMutation) ResetField(name string) error {
	switch name {
	case incidentseverity.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidentseverity.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidentseverity.FieldExternalID:
		m.ResetExternalID()
		return nil
	case incidentseverity.FieldName:
		m.ResetName()
		return nil
	case incidentseverity.FieldRank:
		m.ResetRank()
		return nil
	case incidentseverity.FieldColor:
		m.ResetColor()
		return nil
	case incidentseverity.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentSeverityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidentseverity.EdgeTenant)
	}
	if m.incidents != nil {
		edges = append(edges, incidentseverity.EdgeIncidents)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidentseverity.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentSeverityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidentseverity.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidentseverity.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case incidentseverity.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentSeverityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedincidents != nil {
		edges = append(edges, incidentseverity.EdgeIncidents)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidentseverity.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentSeverityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidentseverity.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case incidentseverity.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentSeverityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidentseverity.EdgeTenant)
	}
	if m.clearedincidents {
		edges = append(edges, incidentseverity.EdgeIncidents)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidentseverity.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentSeverityMutation) EdgeCleared(name string) bool {
	switch name {
	case incidentseverity.EdgeTenant:
		return m.clearedtenant
	case incidentseverity.EdgeIncidents:
		return m.clearedincidents
	case incidentseverity.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentSeverityMutation) ClearEdge(name string) error {
	switch name {
	case incidentseverity.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentSeverityMutation) ResetEdge(name string) error {
	switch name {
	case incidentseverity.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidentseverity.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case incidentseverity.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentSeverity edge %s", name)
}

// IncidentTagMutation represents an operation that mutates the IncidentTag nodes in the graph.
type IncidentTagMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	key                      *string
	value                    *string
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	incidents                map[uuid.UUID]struct{}
	removedincidents         map[uuid.UUID]struct{}
	clearedincidents         bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentTag, error)
	predicates               []predicate.IncidentTag
}

var _ ent.Mutation = (*IncidentTagMutation)(nil)

// incidenttagOption allows management of the mutation configuration using functional options.
type incidenttagOption func(*IncidentTagMutation)

// newIncidentTagMutation creates new mutation for the IncidentTag entity.
func newIncidentTagMutation(c config, op Op, opts ...incidenttagOption) *IncidentTagMutation {
	m := &IncidentTagMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentTagID sets the ID field of the mutation.
func withIncidentTagID(id uuid.UUID) incidenttagOption {
	return func(m *IncidentTagMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentTag
		)
		m.oldValue = func(ctx context.Context) (*IncidentTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentTag sets the old IncidentTag of the mutation.
func withIncidentTag(node *IncidentTag) incidenttagOption {
	return func(m *IncidentTagMutation) {
		m.oldValue = func(context.Context) (*IncidentTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentTag entities.
func (m *IncidentTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentTagMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentTagMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentTag entity.
// If the IncidentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTagMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentTagMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentTagMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentTagMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentTag entity.
// If the IncidentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTagMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentTagMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidenttag.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentTagMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidenttag.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentTagMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidenttag.FieldArchiveTime)
}

// SetKey sets the "key" field.
func (m *IncidentTagMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *IncidentTagMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the IncidentTag entity.
// If the IncidentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTagMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *IncidentTagMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *IncidentTagMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *IncidentTagMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the IncidentTag entity.
// If the IncidentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTagMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *IncidentTagMutation) ResetValue() {
	m.value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentTagMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidenttag.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentTagMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentTagMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentTagMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentTagMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentTagMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentTagMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentTagMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentTagMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentTagMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentTagMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentTagMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTagMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentTagMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentTagMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTagMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentTagMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentTagMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentTagMutation builder.
func (m *IncidentTagMutation) Where(ps ...predicate.IncidentTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentTag).
func (m *IncidentTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentTagMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, incidenttag.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, incidenttag.FieldArchiveTime)
	}
	if m.key != nil {
		fields = append(fields, incidenttag.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, incidenttag.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenttag.FieldTenantID:
		return m.TenantID()
	case incidenttag.FieldArchiveTime:
		return m.ArchiveTime()
	case incidenttag.FieldKey:
		return m.Key()
	case incidenttag.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenttag.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidenttag.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidenttag.FieldKey:
		return m.OldKey(ctx)
	case incidenttag.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenttag.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidenttag.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidenttag.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case incidenttag.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentTagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenttag.FieldArchiveTime) {
		fields = append(fields, incidenttag.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentTagMutation) ClearField(name string) error {
	switch name {
	case incidenttag.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentTagMutation) ResetField(name string) error {
	switch name {
	case incidenttag.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidenttag.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidenttag.FieldKey:
		m.ResetKey()
		return nil
	case incidenttag.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown IncidentTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidenttag.EdgeTenant)
	}
	if m.incidents != nil {
		edges = append(edges, incidenttag.EdgeIncidents)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidenttag.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenttag.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidenttag.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttag.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedincidents != nil {
		edges = append(edges, incidenttag.EdgeIncidents)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidenttag.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidenttag.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttag.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidenttag.EdgeTenant)
	}
	if m.clearedincidents {
		edges = append(edges, incidenttag.EdgeIncidents)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidenttag.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentTagMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenttag.EdgeTenant:
		return m.clearedtenant
	case incidenttag.EdgeIncidents:
		return m.clearedincidents
	case incidenttag.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentTagMutation) ClearEdge(name string) error {
	switch name {
	case incidenttag.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IncidentTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentTagMutation) ResetEdge(name string) error {
	switch name {
	case incidenttag.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidenttag.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case incidenttag.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentTag edge %s", name)
}

// IncidentTypeMutation represents an operation that mutates the IncidentType nodes in the graph.
type IncidentTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	name                     *string
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	incidents                map[uuid.UUID]struct{}
	removedincidents         map[uuid.UUID]struct{}
	clearedincidents         bool
	debrief_questions        map[uuid.UUID]struct{}
	removeddebrief_questions map[uuid.UUID]struct{}
	cleareddebrief_questions bool
	done                     bool
	oldValue                 func(context.Context) (*IncidentType, error)
	predicates               []predicate.IncidentType
}

var _ ent.Mutation = (*IncidentTypeMutation)(nil)

// incidenttypeOption allows management of the mutation configuration using functional options.
type incidenttypeOption func(*IncidentTypeMutation)

// newIncidentTypeMutation creates new mutation for the IncidentType entity.
func newIncidentTypeMutation(c config, op Op, opts ...incidenttypeOption) *IncidentTypeMutation {
	m := &IncidentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeIncidentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentTypeID sets the ID field of the mutation.
func withIncidentTypeID(id uuid.UUID) incidenttypeOption {
	return func(m *IncidentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *IncidentType
		)
		m.oldValue = func(ctx context.Context) (*IncidentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncidentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncidentType sets the old IncidentType of the mutation.
func withIncidentType(node *IncidentType) incidenttypeOption {
	return func(m *IncidentTypeMutation) {
		m.oldValue = func(context.Context) (*IncidentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncidentType entities.
func (m *IncidentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncidentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IncidentTypeMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IncidentTypeMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IncidentType entity.
// If the IncidentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTypeMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IncidentTypeMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *IncidentTypeMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *IncidentTypeMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the IncidentType entity.
// If the IncidentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTypeMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *IncidentTypeMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[incidenttype.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *IncidentTypeMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[incidenttype.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *IncidentTypeMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, incidenttype.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *IncidentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncidentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncidentType entity.
// If the IncidentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncidentTypeMutation) ResetName() {
	m.name = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IncidentTypeMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[incidenttype.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IncidentTypeMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IncidentTypeMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IncidentTypeMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *IncidentTypeMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *IncidentTypeMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *IncidentTypeMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *IncidentTypeMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *IncidentTypeMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *IncidentTypeMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *IncidentTypeMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddDebriefQuestionIDs adds the "debrief_questions" edge to the IncidentDebriefQuestion entity by ids.
func (m *IncidentTypeMutation) AddDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.debrief_questions == nil {
		m.debrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.debrief_questions[ids[i]] = struct{}{}
	}
}

// ClearDebriefQuestions clears the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTypeMutation) ClearDebriefQuestions() {
	m.cleareddebrief_questions = true
}

// DebriefQuestionsCleared reports if the "debrief_questions" edge to the IncidentDebriefQuestion entity was cleared.
func (m *IncidentTypeMutation) DebriefQuestionsCleared() bool {
	return m.cleareddebrief_questions
}

// RemoveDebriefQuestionIDs removes the "debrief_questions" edge to the IncidentDebriefQuestion entity by IDs.
func (m *IncidentTypeMutation) RemoveDebriefQuestionIDs(ids ...uuid.UUID) {
	if m.removeddebrief_questions == nil {
		m.removeddebrief_questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.debrief_questions, ids[i])
		m.removeddebrief_questions[ids[i]] = struct{}{}
	}
}

// RemovedDebriefQuestions returns the removed IDs of the "debrief_questions" edge to the IncidentDebriefQuestion entity.
func (m *IncidentTypeMutation) RemovedDebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddebrief_questions {
		ids = append(ids, id)
	}
	return
}

// DebriefQuestionsIDs returns the "debrief_questions" edge IDs in the mutation.
func (m *IncidentTypeMutation) DebriefQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.debrief_questions {
		ids = append(ids, id)
	}
	return
}

// ResetDebriefQuestions resets all changes to the "debrief_questions" edge.
func (m *IncidentTypeMutation) ResetDebriefQuestions() {
	m.debrief_questions = nil
	m.cleareddebrief_questions = false
	m.removeddebrief_questions = nil
}

// Where appends a list predicates to the IncidentTypeMutation builder.
func (m *IncidentTypeMutation) Where(ps ...predicate.IncidentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncidentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncidentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncidentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncidentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncidentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncidentType).
func (m *IncidentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, incidenttype.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, incidenttype.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, incidenttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incidenttype.FieldTenantID:
		return m.TenantID()
	case incidenttype.FieldArchiveTime:
		return m.ArchiveTime()
	case incidenttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incidenttype.FieldTenantID:
		return m.OldTenantID(ctx)
	case incidenttype.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case incidenttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown IncidentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incidenttype.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case incidenttype.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case incidenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown IncidentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentTypeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncidentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incidenttype.FieldArchiveTime) {
		fields = append(fields, incidenttype.FieldArchiveTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentTypeMutation) ClearField(name string) error {
	switch name {
	case incidenttype.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	}
	return fmt.Errorf("unknown IncidentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentTypeMutation) ResetField(name string) error {
	switch name {
	case incidenttype.FieldTenantID:
		m.ResetTenantID()
		return nil
	case incidenttype.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case incidenttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown IncidentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, incidenttype.EdgeTenant)
	}
	if m.incidents != nil {
		edges = append(edges, incidenttype.EdgeIncidents)
	}
	if m.debrief_questions != nil {
		edges = append(edges, incidenttype.EdgeDebriefQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incidenttype.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case incidenttype.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttype.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.debrief_questions))
		for id := range m.debrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedincidents != nil {
		edges = append(edges, incidenttype.EdgeIncidents)
	}
	if m.removeddebrief_questions != nil {
		edges = append(edges, incidenttype.EdgeDebriefQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incidenttype.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case incidenttype.EdgeDebriefQuestions:
		ids := make([]ent.Value, 0, len(m.removeddebrief_questions))
		for id := range m.removeddebrief_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, incidenttype.EdgeTenant)
	}
	if m.clearedincidents {
		edges = append(edges, incidenttype.EdgeIncidents)
	}
	if m.cleareddebrief_questions {
		edges = append(edges, incidenttype.EdgeDebriefQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case incidenttype.EdgeTenant:
		return m.clearedtenant
	case incidenttype.EdgeIncidents:
		return m.clearedincidents
	case incidenttype.EdgeDebriefQuestions:
		return m.cleareddebrief_questions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentTypeMutation) ClearEdge(name string) error {
	switch name {
	case incidenttype.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IncidentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentTypeMutation) ResetEdge(name string) error {
	switch name {
	case incidenttype.EdgeTenant:
		m.ResetTenant()
		return nil
	case incidenttype.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case incidenttype.EdgeDebriefQuestions:
		m.ResetDebriefQuestions()
		return nil
	}
	return fmt.Errorf("unknown IncidentType edge %s", name)
}

// IntegrationMutation represents an operation that mutates the Integration nodes in the graph.
type IntegrationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	_config       *[]byte
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*Integration, error)
	predicates    []predicate.Integration
}

var _ ent.Mutation = (*IntegrationMutation)(nil)

// integrationOption allows management of the mutation configuration using functional options.
type integrationOption func(*IntegrationMutation)

// newIntegrationMutation creates new mutation for the Integration entity.
func newIntegrationMutation(c config, op Op, opts ...integrationOption) *IntegrationMutation {
	m := &IntegrationMutation{
		config:        c,
		op:            op,
		typ:           TypeIntegration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntegrationID sets the ID field of the mutation.
func withIntegrationID(id uuid.UUID) integrationOption {
	return func(m *IntegrationMutation) {
		var (
			err   error
			once  sync.Once
			value *Integration
		)
		m.oldValue = func(ctx context.Context) (*Integration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Integration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIntegration sets the old Integration of the mutation.
func withIntegration(node *Integration) integrationOption {
	return func(m *IntegrationMutation) {
		m.oldValue = func(context.Context) (*Integration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntegrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntegrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Integration entities.
func (m *IntegrationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntegrationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntegrationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Integration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IntegrationMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IntegrationMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IntegrationMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *IntegrationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IntegrationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IntegrationMutation) ResetName() {
	m.name = nil
}

// SetConfig sets the "config" field.
func (m *IntegrationMutation) SetConfig(b []byte) {
	m._config = &b
}

// Config returns the value of the "config" field in the mutation.
func (m *IntegrationMutation) Config() (r []byte, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldConfig(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *IntegrationMutation) ResetConfig() {
	m._config = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IntegrationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IntegrationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IntegrationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IntegrationMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[integration.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IntegrationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IntegrationMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IntegrationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the IntegrationMutation builder.
func (m *IntegrationMutation) Where(ps ...predicate.Integration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntegrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntegrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Integration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntegrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntegrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Integration).
func (m *IntegrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntegrationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, integration.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, integration.FieldName)
	}
	if m._config != nil {
		fields = append(fields, integration.FieldConfig)
	}
	if m.updated_at != nil {
		fields = append(fields, integration.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntegrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case integration.FieldTenantID:
		return m.TenantID()
	case integration.FieldName:
		return m.Name()
	case integration.FieldConfig:
		return m.Config()
	case integration.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntegrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case integration.FieldTenantID:
		return m.OldTenantID(ctx)
	case integration.FieldName:
		return m.OldName(ctx)
	case integration.FieldConfig:
		return m.OldConfig(ctx)
	case integration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Integration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case integration.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case integration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case integration.FieldConfig:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case integration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Integration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntegrationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntegrationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Integration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntegrationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntegrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntegrationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Integration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntegrationMutation) ResetField(name string) error {
	switch name {
	case integration.FieldTenantID:
		m.ResetTenantID()
		return nil
	case integration.FieldName:
		m.ResetName()
		return nil
	case integration.FieldConfig:
		m.ResetConfig()
		return nil
	case integration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Integration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntegrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, integration.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntegrationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case integration.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntegrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntegrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntegrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, integration.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntegrationMutation) EdgeCleared(name string) bool {
	switch name {
	case integration.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntegrationMutation) ClearEdge(name string) error {
	switch name {
	case integration.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Integration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntegrationMutation) ResetEdge(name string) error {
	switch name {
	case integration.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Integration edge %s", name)
}

// MeetingScheduleMutation represents an operation that mutates the MeetingSchedule nodes in the graph.
type MeetingScheduleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	archive_time        *time.Time
	name                *string
	description         *string
	begin_minute        *int
	addbegin_minute     *int
	duration_minutes    *int
	addduration_minutes *int
	start_date          *time.Time
	repeats             *meetingschedule.Repeats
	repetition_step     *int
	addrepetition_step  *int
	week_days           *[]string
	appendweek_days     []string
	monthly_on          *meetingschedule.MonthlyOn
	until_date          *time.Time
	num_repetitions     *int
	addnum_repetitions  *int
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	owning_team         map[uuid.UUID]struct{}
	removedowning_team  map[uuid.UUID]struct{}
	clearedowning_team  bool
	sessions            map[uuid.UUID]struct{}
	removedsessions     map[uuid.UUID]struct{}
	clearedsessions     bool
	done                bool
	oldValue            func(context.Context) (*MeetingSchedule, error)
	predicates          []predicate.MeetingSchedule
}

var _ ent.Mutation = (*MeetingScheduleMutation)(nil)

// meetingscheduleOption allows management of the mutation configuration using functional options.
type meetingscheduleOption func(*MeetingScheduleMutation)

// newMeetingScheduleMutation creates new mutation for the MeetingSchedule entity.
func newMeetingScheduleMutation(c config, op Op, opts ...meetingscheduleOption) *MeetingScheduleMutation {
	m := &MeetingScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeMeetingSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMeetingScheduleID sets the ID field of the mutation.
func withMeetingScheduleID(id uuid.UUID) meetingscheduleOption {
	return func(m *MeetingScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *MeetingSchedule
		)
		m.oldValue = func(ctx context.Context) (*MeetingSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MeetingSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeetingSchedule sets the old MeetingSchedule of the mutation.
func withMeetingSchedule(node *MeetingSchedule) meetingscheduleOption {
	return func(m *MeetingScheduleMutation) {
		m.oldValue = func(context.Context) (*MeetingSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MeetingScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MeetingScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MeetingSchedule entities.
func (m *MeetingScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MeetingScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MeetingScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MeetingSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *MeetingScheduleMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MeetingScheduleMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MeetingScheduleMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *MeetingScheduleMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *MeetingScheduleMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *MeetingScheduleMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[meetingschedule.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *MeetingScheduleMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *MeetingScheduleMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, meetingschedule.FieldArchiveTime)
}

// SetName sets the "name" field.
func (m *MeetingScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MeetingScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MeetingScheduleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MeetingScheduleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MeetingScheduleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MeetingScheduleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[meetingschedule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MeetingScheduleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MeetingScheduleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, meetingschedule.FieldDescription)
}

// SetBeginMinute sets the "begin_minute" field.
func (m *MeetingScheduleMutation) SetBeginMinute(i int) {
	m.begin_minute = &i
	m.addbegin_minute = nil
}

// BeginMinute returns the value of the "begin_minute" field in the mutation.
func (m *MeetingScheduleMutation) BeginMinute() (r int, exists bool) {
	v := m.begin_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginMinute returns the old "begin_minute" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldBeginMinute(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginMinute: %w", err)
	}
	return oldValue.BeginMinute, nil
}

// AddBeginMinute adds i to the "begin_minute" field.
func (m *MeetingScheduleMutation) AddBeginMinute(i int) {
	if m.addbegin_minute != nil {
		*m.addbegin_minute += i
	} else {
		m.addbegin_minute = &i
	}
}

// AddedBeginMinute returns the value that was added to the "begin_minute" field in this mutation.
func (m *MeetingScheduleMutation) AddedBeginMinute() (r int, exists bool) {
	v := m.addbegin_minute
	if v == nil {
		return
	}
	return *v, true
}

// ResetBeginMinute resets all changes to the "begin_minute" field.
func (m *MeetingScheduleMutation) ResetBeginMinute() {
	m.begin_minute = nil
	m.addbegin_minute = nil
}

// SetDurationMinutes sets the "duration_minutes" field.
func (m *MeetingScheduleMutation) SetDurationMinutes(i int) {
	m.duration_minutes = &i
	m.addduration_minutes = nil
}

// DurationMinutes returns the value of the "duration_minutes" field in the mutation.
func (m *MeetingScheduleMutation) DurationMinutes() (r int, exists bool) {
	v := m.duration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMinutes returns the old "duration_minutes" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldDurationMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMinutes: %w", err)
	}
	return oldValue.DurationMinutes, nil
}

// AddDurationMinutes adds i to the "duration_minutes" field.
func (m *MeetingScheduleMutation) AddDurationMinutes(i int) {
	if m.addduration_minutes != nil {
		*m.addduration_minutes += i
	} else {
		m.addduration_minutes = &i
	}
}

// AddedDurationMinutes returns the value that was added to the "duration_minutes" field in this mutation.
func (m *MeetingScheduleMutation) AddedDurationMinutes() (r int, exists bool) {
	v := m.addduration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMinutes resets all changes to the "duration_minutes" field.
func (m *MeetingScheduleMutation) ResetDurationMinutes() {
	m.duration_minutes = nil
	m.addduration_minutes = nil
}

// SetStartDate sets the "start_date" field.
func (m *MeetingScheduleMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *MeetingScheduleMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *MeetingScheduleMutation) ResetStartDate() {
	m.start_date = nil
}

// SetRepeats sets the "repeats" field.
func (m *MeetingScheduleMutation) SetRepeats(value meetingschedule.Repeats) {
	m.repeats = &value
}

// Repeats returns the value of the "repeats" field in the mutation.
func (m *MeetingScheduleMutation) Repeats() (r meetingschedule.Repeats, exists bool) {
	v := m.repeats
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeats returns the old "repeats" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldRepeats(ctx context.Context) (v meetingschedule.Repeats, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeats: %w", err)
	}
	return oldValue.Repeats, nil
}

// ResetRepeats resets all changes to the "repeats" field.
func (m *MeetingScheduleMutation) ResetRepeats() {
	m.repeats = nil
}

// SetRepetitionStep sets the "repetition_step" field.
func (m *MeetingScheduleMutation) SetRepetitionStep(i int) {
	m.repetition_step = &i
	m.addrepetition_step = nil
}

// RepetitionStep returns the value of the "repetition_step" field in the mutation.
func (m *MeetingScheduleMutation) RepetitionStep() (r int, exists bool) {
	v := m.repetition_step
	if v == nil {
		return
	}
	return *v, true
}

// OldRepetitionStep returns the old "repetition_step" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldRepetitionStep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepetitionStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepetitionStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepetitionStep: %w", err)
	}
	return oldValue.RepetitionStep, nil
}

// AddRepetitionStep adds i to the "repetition_step" field.
func (m *MeetingScheduleMutation) AddRepetitionStep(i int) {
	if m.addrepetition_step != nil {
		*m.addrepetition_step += i
	} else {
		m.addrepetition_step = &i
	}
}

// AddedRepetitionStep returns the value that was added to the "repetition_step" field in this mutation.
func (m *MeetingScheduleMutation) AddedRepetitionStep() (r int, exists bool) {
	v := m.addrepetition_step
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepetitionStep resets all changes to the "repetition_step" field.
func (m *MeetingScheduleMutation) ResetRepetitionStep() {
	m.repetition_step = nil
	m.addrepetition_step = nil
}

// SetWeekDays sets the "week_days" field.
func (m *MeetingScheduleMutation) SetWeekDays(s []string) {
	m.week_days = &s
	m.appendweek_days = nil
}

// WeekDays returns the value of the "week_days" field in the mutation.
func (m *MeetingScheduleMutation) WeekDays() (r []string, exists bool) {
	v := m.week_days
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekDays returns the old "week_days" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldWeekDays(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekDays: %w", err)
	}
	return oldValue.WeekDays, nil
}

// AppendWeekDays adds s to the "week_days" field.
func (m *MeetingScheduleMutation) AppendWeekDays(s []string) {
	m.appendweek_days = append(m.appendweek_days, s...)
}

// AppendedWeekDays returns the list of values that were appended to the "week_days" field in this mutation.
func (m *MeetingScheduleMutation) AppendedWeekDays() ([]string, bool) {
	if len(m.appendweek_days) == 0 {
		return nil, false
	}
	return m.appendweek_days, true
}

// ClearWeekDays clears the value of the "week_days" field.
func (m *MeetingScheduleMutation) ClearWeekDays() {
	m.week_days = nil
	m.appendweek_days = nil
	m.clearedFields[meetingschedule.FieldWeekDays] = struct{}{}
}

// WeekDaysCleared returns if the "week_days" field was cleared in this mutation.
func (m *MeetingScheduleMutation) WeekDaysCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldWeekDays]
	return ok
}

// ResetWeekDays resets all changes to the "week_days" field.
func (m *MeetingScheduleMutation) ResetWeekDays() {
	m.week_days = nil
	m.appendweek_days = nil
	delete(m.clearedFields, meetingschedule.FieldWeekDays)
}

// SetMonthlyOn sets the "monthly_on" field.
func (m *MeetingScheduleMutation) SetMonthlyOn(mo meetingschedule.MonthlyOn) {
	m.monthly_on = &mo
}

// MonthlyOn returns the value of the "monthly_on" field in the mutation.
func (m *MeetingScheduleMutation) MonthlyOn() (r meetingschedule.MonthlyOn, exists bool) {
	v := m.monthly_on
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyOn returns the old "monthly_on" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldMonthlyOn(ctx context.Context) (v meetingschedule.MonthlyOn, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyOn: %w", err)
	}
	return oldValue.MonthlyOn, nil
}

// ClearMonthlyOn clears the value of the "monthly_on" field.
func (m *MeetingScheduleMutation) ClearMonthlyOn() {
	m.monthly_on = nil
	m.clearedFields[meetingschedule.FieldMonthlyOn] = struct{}{}
}

// MonthlyOnCleared returns if the "monthly_on" field was cleared in this mutation.
func (m *MeetingScheduleMutation) MonthlyOnCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldMonthlyOn]
	return ok
}

// ResetMonthlyOn resets all changes to the "monthly_on" field.
func (m *MeetingScheduleMutation) ResetMonthlyOn() {
	m.monthly_on = nil
	delete(m.clearedFields, meetingschedule.FieldMonthlyOn)
}

// SetUntilDate sets the "until_date" field.
func (m *MeetingScheduleMutation) SetUntilDate(t time.Time) {
	m.until_date = &t
}

// UntilDate returns the value of the "until_date" field in the mutation.
func (m *MeetingScheduleMutation) UntilDate() (r time.Time, exists bool) {
	v := m.until_date
	if v == nil {
		return
	}
	return *v, true
}

// OldUntilDate returns the old "until_date" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldUntilDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUntilDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUntilDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUntilDate: %w", err)
	}
	return oldValue.UntilDate, nil
}

// ClearUntilDate clears the value of the "until_date" field.
func (m *MeetingScheduleMutation) ClearUntilDate() {
	m.until_date = nil
	m.clearedFields[meetingschedule.FieldUntilDate] = struct{}{}
}

// UntilDateCleared returns if the "until_date" field was cleared in this mutation.
func (m *MeetingScheduleMutation) UntilDateCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldUntilDate]
	return ok
}

// ResetUntilDate resets all changes to the "until_date" field.
func (m *MeetingScheduleMutation) ResetUntilDate() {
	m.until_date = nil
	delete(m.clearedFields, meetingschedule.FieldUntilDate)
}

// SetNumRepetitions sets the "num_repetitions" field.
func (m *MeetingScheduleMutation) SetNumRepetitions(i int) {
	m.num_repetitions = &i
	m.addnum_repetitions = nil
}

// NumRepetitions returns the value of the "num_repetitions" field in the mutation.
func (m *MeetingScheduleMutation) NumRepetitions() (r int, exists bool) {
	v := m.num_repetitions
	if v == nil {
		return
	}
	return *v, true
}

// OldNumRepetitions returns the old "num_repetitions" field's value of the MeetingSchedule entity.
// If the MeetingSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingScheduleMutation) OldNumRepetitions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumRepetitions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumRepetitions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumRepetitions: %w", err)
	}
	return oldValue.NumRepetitions, nil
}

// AddNumRepetitions adds i to the "num_repetitions" field.
func (m *MeetingScheduleMutation) AddNumRepetitions(i int) {
	if m.addnum_repetitions != nil {
		*m.addnum_repetitions += i
	} else {
		m.addnum_repetitions = &i
	}
}

// AddedNumRepetitions returns the value that was added to the "num_repetitions" field in this mutation.
func (m *MeetingScheduleMutation) AddedNumRepetitions() (r int, exists bool) {
	v := m.addnum_repetitions
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumRepetitions clears the value of the "num_repetitions" field.
func (m *MeetingScheduleMutation) ClearNumRepetitions() {
	m.num_repetitions = nil
	m.addnum_repetitions = nil
	m.clearedFields[meetingschedule.FieldNumRepetitions] = struct{}{}
}

// NumRepetitionsCleared returns if the "num_repetitions" field was cleared in this mutation.
func (m *MeetingScheduleMutation) NumRepetitionsCleared() bool {
	_, ok := m.clearedFields[meetingschedule.FieldNumRepetitions]
	return ok
}

// ResetNumRepetitions resets all changes to the "num_repetitions" field.
func (m *MeetingScheduleMutation) ResetNumRepetitions() {
	m.num_repetitions = nil
	m.addnum_repetitions = nil
	delete(m.clearedFields, meetingschedule.FieldNumRepetitions)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *MeetingScheduleMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[meetingschedule.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *MeetingScheduleMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *MeetingScheduleMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *MeetingScheduleMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddOwningTeamIDs adds the "owning_team" edge to the Team entity by ids.
func (m *MeetingScheduleMutation) AddOwningTeamIDs(ids ...uuid.UUID) {
	if m.owning_team == nil {
		m.owning_team = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.owning_team[ids[i]] = struct{}{}
	}
}

// ClearOwningTeam clears the "owning_team" edge to the Team entity.
func (m *MeetingScheduleMutation) ClearOwningTeam() {
	m.clearedowning_team = true
}

// OwningTeamCleared reports if the "owning_team" edge to the Team entity was cleared.
func (m *MeetingScheduleMutation) OwningTeamCleared() bool {
	return m.clearedowning_team
}

// RemoveOwningTeamIDs removes the "owning_team" edge to the Team entity by IDs.
func (m *MeetingScheduleMutation) RemoveOwningTeamIDs(ids ...uuid.UUID) {
	if m.removedowning_team == nil {
		m.removedowning_team = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.owning_team, ids[i])
		m.removedowning_team[ids[i]] = struct{}{}
	}
}

// RemovedOwningTeam returns the removed IDs of the "owning_team" edge to the Team entity.
func (m *MeetingScheduleMutation) RemovedOwningTeamIDs() (ids []uuid.UUID) {
	for id := range m.removedowning_team {
		ids = append(ids, id)
	}
	return
}

// OwningTeamIDs returns the "owning_team" edge IDs in the mutation.
func (m *MeetingScheduleMutation) OwningTeamIDs() (ids []uuid.UUID) {
	for id := range m.owning_team {
		ids = append(ids, id)
	}
	return
}

// ResetOwningTeam resets all changes to the "owning_team" edge.
func (m *MeetingScheduleMutation) ResetOwningTeam() {
	m.owning_team = nil
	m.clearedowning_team = false
	m.removedowning_team = nil
}

// AddSessionIDs adds the "sessions" edge to the MeetingSession entity by ids.
func (m *MeetingScheduleMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the MeetingSession entity.
func (m *MeetingScheduleMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the MeetingSession entity was cleared.
func (m *MeetingScheduleMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the MeetingSession entity by IDs.
func (m *MeetingScheduleMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the MeetingSession entity.
func (m *MeetingScheduleMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *MeetingScheduleMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *MeetingScheduleMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the MeetingScheduleMutation builder.
func (m *MeetingScheduleMutation) Where(ps ...predicate.MeetingSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MeetingScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MeetingScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MeetingSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MeetingScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MeetingScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MeetingSchedule).
func (m *MeetingScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MeetingScheduleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.tenant != nil {
		fields = append(fields, meetingschedule.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, meetingschedule.FieldArchiveTime)
	}
	if m.name != nil {
		fields = append(fields, meetingschedule.FieldName)
	}
	if m.description != nil {
		fields = append(fields, meetingschedule.FieldDescription)
	}
	if m.begin_minute != nil {
		fields = append(fields, meetingschedule.FieldBeginMinute)
	}
	if m.duration_minutes != nil {
		fields = append(fields, meetingschedule.FieldDurationMinutes)
	}
	if m.start_date != nil {
		fields = append(fields, meetingschedule.FieldStartDate)
	}
	if m.repeats != nil {
		fields = append(fields, meetingschedule.FieldRepeats)
	}
	if m.repetition_step != nil {
		fields = append(fields, meetingschedule.FieldRepetitionStep)
	}
	if m.week_days != nil {
		fields = append(fields, meetingschedule.FieldWeekDays)
	}
	if m.monthly_on != nil {
		fields = append(fields, meetingschedule.FieldMonthlyOn)
	}
	if m.until_date != nil {
		fields = append(fields, meetingschedule.FieldUntilDate)
	}
	if m.num_repetitions != nil {
		fields = append(fields, meetingschedule.FieldNumRepetitions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MeetingScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case meetingschedule.FieldTenantID:
		return m.TenantID()
	case meetingschedule.FieldArchiveTime:
		return m.ArchiveTime()
	case meetingschedule.FieldName:
		return m.Name()
	case meetingschedule.FieldDescription:
		return m.Description()
	case meetingschedule.FieldBeginMinute:
		return m.BeginMinute()
	case meetingschedule.FieldDurationMinutes:
		return m.DurationMinutes()
	case meetingschedule.FieldStartDate:
		return m.StartDate()
	case meetingschedule.FieldRepeats:
		return m.Repeats()
	case meetingschedule.FieldRepetitionStep:
		return m.RepetitionStep()
	case meetingschedule.FieldWeekDays:
		return m.WeekDays()
	case meetingschedule.FieldMonthlyOn:
		return m.MonthlyOn()
	case meetingschedule.FieldUntilDate:
		return m.UntilDate()
	case meetingschedule.FieldNumRepetitions:
		return m.NumRepetitions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MeetingScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case meetingschedule.FieldTenantID:
		return m.OldTenantID(ctx)
	case meetingschedule.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case meetingschedule.FieldName:
		return m.OldName(ctx)
	case meetingschedule.FieldDescription:
		return m.OldDescription(ctx)
	case meetingschedule.FieldBeginMinute:
		return m.OldBeginMinute(ctx)
	case meetingschedule.FieldDurationMinutes:
		return m.OldDurationMinutes(ctx)
	case meetingschedule.FieldStartDate:
		return m.OldStartDate(ctx)
	case meetingschedule.FieldRepeats:
		return m.OldRepeats(ctx)
	case meetingschedule.FieldRepetitionStep:
		return m.OldRepetitionStep(ctx)
	case meetingschedule.FieldWeekDays:
		return m.OldWeekDays(ctx)
	case meetingschedule.FieldMonthlyOn:
		return m.OldMonthlyOn(ctx)
	case meetingschedule.FieldUntilDate:
		return m.OldUntilDate(ctx)
	case meetingschedule.FieldNumRepetitions:
		return m.OldNumRepetitions(ctx)
	}
	return nil, fmt.Errorf("unknown MeetingSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case meetingschedule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case meetingschedule.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case meetingschedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case meetingschedule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case meetingschedule.FieldBeginMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginMinute(v)
		return nil
	case meetingschedule.FieldDurationMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMinutes(v)
		return nil
	case meetingschedule.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case meetingschedule.FieldRepeats:
		v, ok := value.(meetingschedule.Repeats)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeats(v)
		return nil
	case meetingschedule.FieldRepetitionStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepetitionStep(v)
		return nil
	case meetingschedule.FieldWeekDays:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekDays(v)
		return nil
	case meetingschedule.FieldMonthlyOn:
		v, ok := value.(meetingschedule.MonthlyOn)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyOn(v)
		return nil
	case meetingschedule.FieldUntilDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUntilDate(v)
		return nil
	case meetingschedule.FieldNumRepetitions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumRepetitions(v)
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MeetingScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addbegin_minute != nil {
		fields = append(fields, meetingschedule.FieldBeginMinute)
	}
	if m.addduration_minutes != nil {
		fields = append(fields, meetingschedule.FieldDurationMinutes)
	}
	if m.addrepetition_step != nil {
		fields = append(fields, meetingschedule.FieldRepetitionStep)
	}
	if m.addnum_repetitions != nil {
		fields = append(fields, meetingschedule.FieldNumRepetitions)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MeetingScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case meetingschedule.FieldBeginMinute:
		return m.AddedBeginMinute()
	case meetingschedule.FieldDurationMinutes:
		return m.AddedDurationMinutes()
	case meetingschedule.FieldRepetitionStep:
		return m.AddedRepetitionStep()
	case meetingschedule.FieldNumRepetitions:
		return m.AddedNumRepetitions()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case meetingschedule.FieldBeginMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeginMinute(v)
		return nil
	case meetingschedule.FieldDurationMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMinutes(v)
		return nil
	case meetingschedule.FieldRepetitionStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepetitionStep(v)
		return nil
	case meetingschedule.FieldNumRepetitions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumRepetitions(v)
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MeetingScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(meetingschedule.FieldArchiveTime) {
		fields = append(fields, meetingschedule.FieldArchiveTime)
	}
	if m.FieldCleared(meetingschedule.FieldDescription) {
		fields = append(fields, meetingschedule.FieldDescription)
	}
	if m.FieldCleared(meetingschedule.FieldWeekDays) {
		fields = append(fields, meetingschedule.FieldWeekDays)
	}
	if m.FieldCleared(meetingschedule.FieldMonthlyOn) {
		fields = append(fields, meetingschedule.FieldMonthlyOn)
	}
	if m.FieldCleared(meetingschedule.FieldUntilDate) {
		fields = append(fields, meetingschedule.FieldUntilDate)
	}
	if m.FieldCleared(meetingschedule.FieldNumRepetitions) {
		fields = append(fields, meetingschedule.FieldNumRepetitions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MeetingScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MeetingScheduleMutation) ClearField(name string) error {
	switch name {
	case meetingschedule.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case meetingschedule.FieldDescription:
		m.ClearDescription()
		return nil
	case meetingschedule.FieldWeekDays:
		m.ClearWeekDays()
		return nil
	case meetingschedule.FieldMonthlyOn:
		m.ClearMonthlyOn()
		return nil
	case meetingschedule.FieldUntilDate:
		m.ClearUntilDate()
		return nil
	case meetingschedule.FieldNumRepetitions:
		m.ClearNumRepetitions()
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MeetingScheduleMutation) ResetField(name string) error {
	switch name {
	case meetingschedule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case meetingschedule.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case meetingschedule.FieldName:
		m.ResetName()
		return nil
	case meetingschedule.FieldDescription:
		m.ResetDescription()
		return nil
	case meetingschedule.FieldBeginMinute:
		m.ResetBeginMinute()
		return nil
	case meetingschedule.FieldDurationMinutes:
		m.ResetDurationMinutes()
		return nil
	case meetingschedule.FieldStartDate:
		m.ResetStartDate()
		return nil
	case meetingschedule.FieldRepeats:
		m.ResetRepeats()
		return nil
	case meetingschedule.FieldRepetitionStep:
		m.ResetRepetitionStep()
		return nil
	case meetingschedule.FieldWeekDays:
		m.ResetWeekDays()
		return nil
	case meetingschedule.FieldMonthlyOn:
		m.ResetMonthlyOn()
		return nil
	case meetingschedule.FieldUntilDate:
		m.ResetUntilDate()
		return nil
	case meetingschedule.FieldNumRepetitions:
		m.ResetNumRepetitions()
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MeetingScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, meetingschedule.EdgeTenant)
	}
	if m.owning_team != nil {
		edges = append(edges, meetingschedule.EdgeOwningTeam)
	}
	if m.sessions != nil {
		edges = append(edges, meetingschedule.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MeetingScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case meetingschedule.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case meetingschedule.EdgeOwningTeam:
		ids := make([]ent.Value, 0, len(m.owning_team))
		for id := range m.owning_team {
			ids = append(ids, id)
		}
		return ids
	case meetingschedule.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MeetingScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedowning_team != nil {
		edges = append(edges, meetingschedule.EdgeOwningTeam)
	}
	if m.removedsessions != nil {
		edges = append(edges, meetingschedule.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MeetingScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case meetingschedule.EdgeOwningTeam:
		ids := make([]ent.Value, 0, len(m.removedowning_team))
		for id := range m.removedowning_team {
			ids = append(ids, id)
		}
		return ids
	case meetingschedule.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MeetingScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, meetingschedule.EdgeTenant)
	}
	if m.clearedowning_team {
		edges = append(edges, meetingschedule.EdgeOwningTeam)
	}
	if m.clearedsessions {
		edges = append(edges, meetingschedule.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MeetingScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case meetingschedule.EdgeTenant:
		return m.clearedtenant
	case meetingschedule.EdgeOwningTeam:
		return m.clearedowning_team
	case meetingschedule.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MeetingScheduleMutation) ClearEdge(name string) error {
	switch name {
	case meetingschedule.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MeetingScheduleMutation) ResetEdge(name string) error {
	switch name {
	case meetingschedule.EdgeTenant:
		m.ResetTenant()
		return nil
	case meetingschedule.EdgeOwningTeam:
		m.ResetOwningTeam()
		return nil
	case meetingschedule.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown MeetingSchedule edge %s", name)
}

// MeetingSessionMutation represents an operation that mutates the MeetingSession nodes in the graph.
type MeetingSessionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	title            *string
	started_at       *time.Time
	ended_at         *time.Time
	document_name    *string
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	incidents        map[uuid.UUID]struct{}
	removedincidents map[uuid.UUID]struct{}
	clearedincidents bool
	schedule         *uuid.UUID
	clearedschedule  bool
	done             bool
	oldValue         func(context.Context) (*MeetingSession, error)
	predicates       []predicate.MeetingSession
}

var _ ent.Mutation = (*MeetingSessionMutation)(nil)

// meetingsessionOption allows management of the mutation configuration using functional options.
type meetingsessionOption func(*MeetingSessionMutation)

// newMeetingSessionMutation creates new mutation for the MeetingSession entity.
func newMeetingSessionMutation(c config, op Op, opts ...meetingsessionOption) *MeetingSessionMutation {
	m := &MeetingSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeMeetingSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMeetingSessionID sets the ID field of the mutation.
func withMeetingSessionID(id uuid.UUID) meetingsessionOption {
	return func(m *MeetingSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *MeetingSession
		)
		m.oldValue = func(ctx context.Context) (*MeetingSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MeetingSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeetingSession sets the old MeetingSession of the mutation.
func withMeetingSession(node *MeetingSession) meetingsessionOption {
	return func(m *MeetingSessionMutation) {
		m.oldValue = func(context.Context) (*MeetingSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MeetingSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MeetingSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MeetingSession entities.
func (m *MeetingSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MeetingSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MeetingSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MeetingSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *MeetingSessionMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MeetingSessionMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MeetingSessionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetTitle sets the "title" field.
func (m *MeetingSessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MeetingSessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *MeetingSessionMutation) ResetTitle() {
	m.title = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MeetingSessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MeetingSessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MeetingSessionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *MeetingSessionMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *MeetingSessionMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *MeetingSessionMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[meetingsession.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *MeetingSessionMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[meetingsession.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *MeetingSessionMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, meetingsession.FieldEndedAt)
}

// SetDocumentName sets the "document_name" field.
func (m *MeetingSessionMutation) SetDocumentName(s string) {
	m.document_name = &s
}

// DocumentName returns the value of the "document_name" field in the mutation.
func (m *MeetingSessionMutation) DocumentName() (r string, exists bool) {
	v := m.document_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentName returns the old "document_name" field's value of the MeetingSession entity.
// If the MeetingSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MeetingSessionMutation) OldDocumentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentName: %w", err)
	}
	return oldValue.DocumentName, nil
}

// ResetDocumentName resets all changes to the "document_name" field.
func (m *MeetingSessionMutation) ResetDocumentName() {
	m.document_name = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *MeetingSessionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[meetingsession.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *MeetingSessionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *MeetingSessionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *MeetingSessionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *MeetingSessionMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *MeetingSessionMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *MeetingSessionMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *MeetingSessionMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *MeetingSessionMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *MeetingSessionMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *MeetingSessionMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// SetScheduleID sets the "schedule" edge to the MeetingSchedule entity by id.
func (m *MeetingSessionMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the MeetingSchedule entity.
func (m *MeetingSessionMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the MeetingSchedule entity was cleared.
func (m *MeetingSessionMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *MeetingSessionMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *MeetingSessionMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *MeetingSessionMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the MeetingSessionMutation builder.
func (m *MeetingSessionMutation) Where(ps ...predicate.MeetingSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MeetingSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MeetingSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MeetingSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MeetingSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MeetingSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MeetingSession).
func (m *MeetingSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MeetingSessionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, meetingsession.FieldTenantID)
	}
	if m.title != nil {
		fields = append(fields, meetingsession.FieldTitle)
	}
	if m.started_at != nil {
		fields = append(fields, meetingsession.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, meetingsession.FieldEndedAt)
	}
	if m.document_name != nil {
		fields = append(fields, meetingsession.FieldDocumentName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MeetingSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case meetingsession.FieldTenantID:
		return m.TenantID()
	case meetingsession.FieldTitle:
		return m.Title()
	case meetingsession.FieldStartedAt:
		return m.StartedAt()
	case meetingsession.FieldEndedAt:
		return m.EndedAt()
	case meetingsession.FieldDocumentName:
		return m.DocumentName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MeetingSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case meetingsession.FieldTenantID:
		return m.OldTenantID(ctx)
	case meetingsession.FieldTitle:
		return m.OldTitle(ctx)
	case meetingsession.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case meetingsession.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case meetingsession.FieldDocumentName:
		return m.OldDocumentName(ctx)
	}
	return nil, fmt.Errorf("unknown MeetingSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case meetingsession.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case meetingsession.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case meetingsession.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case meetingsession.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case meetingsession.FieldDocumentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentName(v)
		return nil
	}
	return fmt.Errorf("unknown MeetingSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MeetingSessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MeetingSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeetingSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MeetingSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MeetingSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(meetingsession.FieldEndedAt) {
		fields = append(fields, meetingsession.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MeetingSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MeetingSessionMutation) ClearField(name string) error {
	switch name {
	case meetingsession.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown MeetingSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MeetingSessionMutation) ResetField(name string) error {
	switch name {
	case meetingsession.FieldTenantID:
		m.ResetTenantID()
		return nil
	case meetingsession.FieldTitle:
		m.ResetTitle()
		return nil
	case meetingsession.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case meetingsession.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case meetingsession.FieldDocumentName:
		m.ResetDocumentName()
		return nil
	}
	return fmt.Errorf("unknown MeetingSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MeetingSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, meetingsession.EdgeTenant)
	}
	if m.incidents != nil {
		edges = append(edges, meetingsession.EdgeIncidents)
	}
	if m.schedule != nil {
		edges = append(edges, meetingsession.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MeetingSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case meetingsession.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case meetingsession.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case meetingsession.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MeetingSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedincidents != nil {
		edges = append(edges, meetingsession.EdgeIncidents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MeetingSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case meetingsession.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MeetingSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, meetingsession.EdgeTenant)
	}
	if m.clearedincidents {
		edges = append(edges, meetingsession.EdgeIncidents)
	}
	if m.clearedschedule {
		edges = append(edges, meetingsession.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MeetingSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case meetingsession.EdgeTenant:
		return m.clearedtenant
	case meetingsession.EdgeIncidents:
		return m.clearedincidents
	case meetingsession.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MeetingSessionMutation) ClearEdge(name string) error {
	switch name {
	case meetingsession.EdgeTenant:
		m.ClearTenant()
		return nil
	case meetingsession.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown MeetingSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MeetingSessionMutation) ResetEdge(name string) error {
	switch name {
	case meetingsession.EdgeTenant:
		m.ResetTenant()
		return nil
	case meetingsession.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case meetingsession.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown MeetingSession edge %s", name)
}

// OncallHandoverTemplateMutation represents an operation that mutates the OncallHandoverTemplate nodes in the graph.
type OncallHandoverTemplateMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	contents      *[]byte
	is_default    *bool
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	roster        map[uuid.UUID]struct{}
	removedroster map[uuid.UUID]struct{}
	clearedroster bool
	done          bool
	oldValue      func(context.Context) (*OncallHandoverTemplate, error)
	predicates    []predicate.OncallHandoverTemplate
}

var _ ent.Mutation = (*OncallHandoverTemplateMutation)(nil)

// oncallhandovertemplateOption allows management of the mutation configuration using functional options.
type oncallhandovertemplateOption func(*OncallHandoverTemplateMutation)

// newOncallHandoverTemplateMutation creates new mutation for the OncallHandoverTemplate entity.
func newOncallHandoverTemplateMutation(c config, op Op, opts ...oncallhandovertemplateOption) *OncallHandoverTemplateMutation {
	m := &OncallHandoverTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallHandoverTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallHandoverTemplateID sets the ID field of the mutation.
func withOncallHandoverTemplateID(id uuid.UUID) oncallhandovertemplateOption {
	return func(m *OncallHandoverTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallHandoverTemplate
		)
		m.oldValue = func(ctx context.Context) (*OncallHandoverTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallHandoverTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallHandoverTemplate sets the old OncallHandoverTemplate of the mutation.
func withOncallHandoverTemplate(node *OncallHandoverTemplate) oncallhandovertemplateOption {
	return func(m *OncallHandoverTemplateMutation) {
		m.oldValue = func(context.Context) (*OncallHandoverTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallHandoverTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallHandoverTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallHandoverTemplate entities.
func (m *OncallHandoverTemplateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallHandoverTemplateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallHandoverTemplateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallHandoverTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallHandoverTemplateMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallHandoverTemplateMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallHandoverTemplateMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OncallHandoverTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OncallHandoverTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OncallHandoverTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OncallHandoverTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OncallHandoverTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OncallHandoverTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContents sets the "contents" field.
func (m *OncallHandoverTemplateMutation) SetContents(b []byte) {
	m.contents = &b
}

// Contents returns the value of the "contents" field in the mutation.
func (m *OncallHandoverTemplateMutation) Contents() (r []byte, exists bool) {
	v := m.contents
	if v == nil {
		return
	}
	return *v, true
}

// OldContents returns the old "contents" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldContents(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContents: %w", err)
	}
	return oldValue.Contents, nil
}

// ResetContents resets all changes to the "contents" field.
func (m *OncallHandoverTemplateMutation) ResetContents() {
	m.contents = nil
}

// SetIsDefault sets the "is_default" field.
func (m *OncallHandoverTemplateMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *OncallHandoverTemplateMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the OncallHandoverTemplate entity.
// If the OncallHandoverTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallHandoverTemplateMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *OncallHandoverTemplateMutation) ResetIsDefault() {
	m.is_default = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallHandoverTemplateMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallhandovertemplate.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallHandoverTemplateMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallHandoverTemplateMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallHandoverTemplateMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRosterIDs adds the "roster" edge to the OncallRoster entity by ids.
func (m *OncallHandoverTemplateMutation) AddRosterIDs(ids ...uuid.UUID) {
	if m.roster == nil {
		m.roster = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roster[ids[i]] = struct{}{}
	}
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallHandoverTemplateMutation) ClearRoster() {
	m.clearedroster = true
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallHandoverTemplateMutation) RosterCleared() bool {
	return m.clearedroster
}

// RemoveRosterIDs removes the "roster" edge to the OncallRoster entity by IDs.
func (m *OncallHandoverTemplateMutation) RemoveRosterIDs(ids ...uuid.UUID) {
	if m.removedroster == nil {
		m.removedroster = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roster, ids[i])
		m.removedroster[ids[i]] = struct{}{}
	}
}

// RemovedRoster returns the removed IDs of the "roster" edge to the OncallRoster entity.
func (m *OncallHandoverTemplateMutation) RemovedRosterIDs() (ids []uuid.UUID) {
	for id := range m.removedroster {
		ids = append(ids, id)
	}
	return
}

// RosterIDs returns the "roster" edge IDs in the mutation.
func (m *OncallHandoverTemplateMutation) RosterIDs() (ids []uuid.UUID) {
	for id := range m.roster {
		ids = append(ids, id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallHandoverTemplateMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
	m.removedroster = nil
}

// Where appends a list predicates to the OncallHandoverTemplateMutation builder.
func (m *OncallHandoverTemplateMutation) Where(ps ...predicate.OncallHandoverTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallHandoverTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallHandoverTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallHandoverTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallHandoverTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallHandoverTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallHandoverTemplate).
func (m *OncallHandoverTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallHandoverTemplateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, oncallhandovertemplate.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, oncallhandovertemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oncallhandovertemplate.FieldUpdatedAt)
	}
	if m.contents != nil {
		fields = append(fields, oncallhandovertemplate.FieldContents)
	}
	if m.is_default != nil {
		fields = append(fields, oncallhandovertemplate.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallHandoverTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallhandovertemplate.FieldTenantID:
		return m.TenantID()
	case oncallhandovertemplate.FieldCreatedAt:
		return m.CreatedAt()
	case oncallhandovertemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case oncallhandovertemplate.FieldContents:
		return m.Contents()
	case oncallhandovertemplate.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallHandoverTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallhandovertemplate.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallhandovertemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oncallhandovertemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oncallhandovertemplate.FieldContents:
		return m.OldContents(ctx)
	case oncallhandovertemplate.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown OncallHandoverTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallHandoverTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallhandovertemplate.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallhandovertemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oncallhandovertemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oncallhandovertemplate.FieldContents:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContents(v)
		return nil
	case oncallhandovertemplate.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown OncallHandoverTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallHandoverTemplateMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallHandoverTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallHandoverTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallHandoverTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallHandoverTemplateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallHandoverTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallHandoverTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ResetField(name string) error {
	switch name {
	case oncallhandovertemplate.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallhandovertemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oncallhandovertemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oncallhandovertemplate.FieldContents:
		m.ResetContents()
		return nil
	case oncallhandovertemplate.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown OncallHandoverTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallHandoverTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, oncallhandovertemplate.EdgeTenant)
	}
	if m.roster != nil {
		edges = append(edges, oncallhandovertemplate.EdgeRoster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallHandoverTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallhandovertemplate.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallhandovertemplate.EdgeRoster:
		ids := make([]ent.Value, 0, len(m.roster))
		for id := range m.roster {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallHandoverTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroster != nil {
		edges = append(edges, oncallhandovertemplate.EdgeRoster)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallHandoverTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallhandovertemplate.EdgeRoster:
		ids := make([]ent.Value, 0, len(m.removedroster))
		for id := range m.removedroster {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallHandoverTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, oncallhandovertemplate.EdgeTenant)
	}
	if m.clearedroster {
		edges = append(edges, oncallhandovertemplate.EdgeRoster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallHandoverTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallhandovertemplate.EdgeTenant:
		return m.clearedtenant
	case oncallhandovertemplate.EdgeRoster:
		return m.clearedroster
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ClearEdge(name string) error {
	switch name {
	case oncallhandovertemplate.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown OncallHandoverTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallHandoverTemplateMutation) ResetEdge(name string) error {
	switch name {
	case oncallhandovertemplate.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallhandovertemplate.EdgeRoster:
		m.ResetRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallHandoverTemplate edge %s", name)
}

// OncallRosterMutation represents an operation that mutates the OncallRoster nodes in the graph.
type OncallRosterMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	archive_time             *time.Time
	external_id              *string
	name                     *string
	slug                     *string
	timezone                 *string
	chat_handle              *string
	chat_channel_id          *string
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	schedules                map[uuid.UUID]struct{}
	removedschedules         map[uuid.UUID]struct{}
	clearedschedules         bool
	handover_template        *uuid.UUID
	clearedhandover_template bool
	alerts                   map[uuid.UUID]struct{}
	removedalerts            map[uuid.UUID]struct{}
	clearedalerts            bool
	teams                    map[uuid.UUID]struct{}
	removedteams             map[uuid.UUID]struct{}
	clearedteams             bool
	shifts                   map[uuid.UUID]struct{}
	removedshifts            map[uuid.UUID]struct{}
	clearedshifts            bool
	user_watchers            map[uuid.UUID]struct{}
	removeduser_watchers     map[uuid.UUID]struct{}
	cleareduser_watchers     bool
	metrics                  map[uuid.UUID]struct{}
	removedmetrics           map[uuid.UUID]struct{}
	clearedmetrics           bool
	done                     bool
	oldValue                 func(context.Context) (*OncallRoster, error)
	predicates               []predicate.OncallRoster
}

var _ ent.Mutation = (*OncallRosterMutation)(nil)

// oncallrosterOption allows management of the mutation configuration using functional options.
type oncallrosterOption func(*OncallRosterMutation)

// newOncallRosterMutation creates new mutation for the OncallRoster entity.
func newOncallRosterMutation(c config, op Op, opts ...oncallrosterOption) *OncallRosterMutation {
	m := &OncallRosterMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallRoster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallRosterID sets the ID field of the mutation.
func withOncallRosterID(id uuid.UUID) oncallrosterOption {
	return func(m *OncallRosterMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallRoster
		)
		m.oldValue = func(ctx context.Context) (*OncallRoster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallRoster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallRoster sets the old OncallRoster of the mutation.
func withOncallRoster(node *OncallRoster) oncallrosterOption {
	return func(m *OncallRosterMutation) {
		m.oldValue = func(context.Context) (*OncallRoster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallRosterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallRosterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallRoster entities.
func (m *OncallRosterMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallRosterMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallRosterMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallRoster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallRosterMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallRosterMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallRosterMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *OncallRosterMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *OncallRosterMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *OncallRosterMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[oncallroster.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *OncallRosterMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *OncallRosterMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, oncallroster.FieldArchiveTime)
}

// SetExternalID sets the "external_id" field.
func (m *OncallRosterMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OncallRosterMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OncallRosterMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[oncallroster.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OncallRosterMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OncallRosterMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, oncallroster.FieldExternalID)
}

// SetName sets the "name" field.
func (m *OncallRosterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OncallRosterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OncallRosterMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OncallRosterMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OncallRosterMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OncallRosterMutation) ResetSlug() {
	m.slug = nil
}

// SetTimezone sets the "timezone" field.
func (m *OncallRosterMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OncallRosterMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OncallRosterMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[oncallroster.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OncallRosterMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OncallRosterMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, oncallroster.FieldTimezone)
}

// SetChatHandle sets the "chat_handle" field.
func (m *OncallRosterMutation) SetChatHandle(s string) {
	m.chat_handle = &s
}

// ChatHandle returns the value of the "chat_handle" field in the mutation.
func (m *OncallRosterMutation) ChatHandle() (r string, exists bool) {
	v := m.chat_handle
	if v == nil {
		return
	}
	return *v, true
}

// OldChatHandle returns the old "chat_handle" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldChatHandle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatHandle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatHandle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatHandle: %w", err)
	}
	return oldValue.ChatHandle, nil
}

// ClearChatHandle clears the value of the "chat_handle" field.
func (m *OncallRosterMutation) ClearChatHandle() {
	m.chat_handle = nil
	m.clearedFields[oncallroster.FieldChatHandle] = struct{}{}
}

// ChatHandleCleared returns if the "chat_handle" field was cleared in this mutation.
func (m *OncallRosterMutation) ChatHandleCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldChatHandle]
	return ok
}

// ResetChatHandle resets all changes to the "chat_handle" field.
func (m *OncallRosterMutation) ResetChatHandle() {
	m.chat_handle = nil
	delete(m.clearedFields, oncallroster.FieldChatHandle)
}

// SetChatChannelID sets the "chat_channel_id" field.
func (m *OncallRosterMutation) SetChatChannelID(s string) {
	m.chat_channel_id = &s
}

// ChatChannelID returns the value of the "chat_channel_id" field in the mutation.
func (m *OncallRosterMutation) ChatChannelID() (r string, exists bool) {
	v := m.chat_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatChannelID returns the old "chat_channel_id" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldChatChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatChannelID: %w", err)
	}
	return oldValue.ChatChannelID, nil
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (m *OncallRosterMutation) ClearChatChannelID() {
	m.chat_channel_id = nil
	m.clearedFields[oncallroster.FieldChatChannelID] = struct{}{}
}

// ChatChannelIDCleared returns if the "chat_channel_id" field was cleared in this mutation.
func (m *OncallRosterMutation) ChatChannelIDCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldChatChannelID]
	return ok
}

// ResetChatChannelID resets all changes to the "chat_channel_id" field.
func (m *OncallRosterMutation) ResetChatChannelID() {
	m.chat_channel_id = nil
	delete(m.clearedFields, oncallroster.FieldChatChannelID)
}

// SetHandoverTemplateID sets the "handover_template_id" field.
func (m *OncallRosterMutation) SetHandoverTemplateID(u uuid.UUID) {
	m.handover_template = &u
}

// HandoverTemplateID returns the value of the "handover_template_id" field in the mutation.
func (m *OncallRosterMutation) HandoverTemplateID() (r uuid.UUID, exists bool) {
	v := m.handover_template
	if v == nil {
		return
	}
	return *v, true
}

// OldHandoverTemplateID returns the old "handover_template_id" field's value of the OncallRoster entity.
// If the OncallRoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMutation) OldHandoverTemplateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandoverTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandoverTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandoverTemplateID: %w", err)
	}
	return oldValue.HandoverTemplateID, nil
}

// ClearHandoverTemplateID clears the value of the "handover_template_id" field.
func (m *OncallRosterMutation) ClearHandoverTemplateID() {
	m.handover_template = nil
	m.clearedFields[oncallroster.FieldHandoverTemplateID] = struct{}{}
}

// HandoverTemplateIDCleared returns if the "handover_template_id" field was cleared in this mutation.
func (m *OncallRosterMutation) HandoverTemplateIDCleared() bool {
	_, ok := m.clearedFields[oncallroster.FieldHandoverTemplateID]
	return ok
}

// ResetHandoverTemplateID resets all changes to the "handover_template_id" field.
func (m *OncallRosterMutation) ResetHandoverTemplateID() {
	m.handover_template = nil
	delete(m.clearedFields, oncallroster.FieldHandoverTemplateID)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallRosterMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallroster.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallRosterMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallRosterMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallRosterMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddScheduleIDs adds the "schedules" edge to the OncallSchedule entity by ids.
func (m *OncallRosterMutation) AddScheduleIDs(ids ...uuid.UUID) {
	if m.schedules == nil {
		m.schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the OncallSchedule entity.
func (m *OncallRosterMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the OncallSchedule entity was cleared.
func (m *OncallRosterMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the OncallSchedule entity by IDs.
func (m *OncallRosterMutation) RemoveScheduleIDs(ids ...uuid.UUID) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the OncallSchedule entity.
func (m *OncallRosterMutation) RemovedSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *OncallRosterMutation) SchedulesIDs() (ids []uuid.UUID) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *OncallRosterMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// ClearHandoverTemplate clears the "handover_template" edge to the OncallHandoverTemplate entity.
func (m *OncallRosterMutation) ClearHandoverTemplate() {
	m.clearedhandover_template = true
	m.clearedFields[oncallroster.FieldHandoverTemplateID] = struct{}{}
}

// HandoverTemplateCleared reports if the "handover_template" edge to the OncallHandoverTemplate entity was cleared.
func (m *OncallRosterMutation) HandoverTemplateCleared() bool {
	return m.HandoverTemplateIDCleared() || m.clearedhandover_template
}

// HandoverTemplateIDs returns the "handover_template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HandoverTemplateID instead. It exists only for internal usage by the builders.
func (m *OncallRosterMutation) HandoverTemplateIDs() (ids []uuid.UUID) {
	if id := m.handover_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHandoverTemplate resets all changes to the "handover_template" edge.
func (m *OncallRosterMutation) ResetHandoverTemplate() {
	m.handover_template = nil
	m.clearedhandover_template = false
}

// AddAlertIDs adds the "alerts" edge to the Alert entity by ids.
func (m *OncallRosterMutation) AddAlertIDs(ids ...uuid.UUID) {
	if m.alerts == nil {
		m.alerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// ClearAlerts clears the "alerts" edge to the Alert entity.
func (m *OncallRosterMutation) ClearAlerts() {
	m.clearedalerts = true
}

// AlertsCleared reports if the "alerts" edge to the Alert entity was cleared.
func (m *OncallRosterMutation) AlertsCleared() bool {
	return m.clearedalerts
}

// RemoveAlertIDs removes the "alerts" edge to the Alert entity by IDs.
func (m *OncallRosterMutation) RemoveAlertIDs(ids ...uuid.UUID) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.alerts, ids[i])
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed IDs of the "alerts" edge to the Alert entity.
func (m *OncallRosterMutation) RemovedAlertsIDs() (ids []uuid.UUID) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the "alerts" edge IDs in the mutation.
func (m *OncallRosterMutation) AlertsIDs() (ids []uuid.UUID) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts resets all changes to the "alerts" edge.
func (m *OncallRosterMutation) ResetAlerts() {
	m.alerts = nil
	m.clearedalerts = false
	m.removedalerts = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *OncallRosterMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m.teams == nil {
		m.teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *OncallRosterMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *OncallRosterMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *OncallRosterMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removedteams == nil {
		m.removedteams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *OncallRosterMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *OncallRosterMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *OncallRosterMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddShiftIDs adds the "shifts" edge to the OncallShift entity by ids.
func (m *OncallRosterMutation) AddShiftIDs(ids ...uuid.UUID) {
	if m.shifts == nil {
		m.shifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shifts[ids[i]] = struct{}{}
	}
}

// ClearShifts clears the "shifts" edge to the OncallShift entity.
func (m *OncallRosterMutation) ClearShifts() {
	m.clearedshifts = true
}

// ShiftsCleared reports if the "shifts" edge to the OncallShift entity was cleared.
func (m *OncallRosterMutation) ShiftsCleared() bool {
	return m.clearedshifts
}

// RemoveShiftIDs removes the "shifts" edge to the OncallShift entity by IDs.
func (m *OncallRosterMutation) RemoveShiftIDs(ids ...uuid.UUID) {
	if m.removedshifts == nil {
		m.removedshifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shifts, ids[i])
		m.removedshifts[ids[i]] = struct{}{}
	}
}

// RemovedShifts returns the removed IDs of the "shifts" edge to the OncallShift entity.
func (m *OncallRosterMutation) RemovedShiftsIDs() (ids []uuid.UUID) {
	for id := range m.removedshifts {
		ids = append(ids, id)
	}
	return
}

// ShiftsIDs returns the "shifts" edge IDs in the mutation.
func (m *OncallRosterMutation) ShiftsIDs() (ids []uuid.UUID) {
	for id := range m.shifts {
		ids = append(ids, id)
	}
	return
}

// ResetShifts resets all changes to the "shifts" edge.
func (m *OncallRosterMutation) ResetShifts() {
	m.shifts = nil
	m.clearedshifts = false
	m.removedshifts = nil
}

// AddUserWatcherIDs adds the "user_watchers" edge to the User entity by ids.
func (m *OncallRosterMutation) AddUserWatcherIDs(ids ...uuid.UUID) {
	if m.user_watchers == nil {
		m.user_watchers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_watchers[ids[i]] = struct{}{}
	}
}

// ClearUserWatchers clears the "user_watchers" edge to the User entity.
func (m *OncallRosterMutation) ClearUserWatchers() {
	m.cleareduser_watchers = true
}

// UserWatchersCleared reports if the "user_watchers" edge to the User entity was cleared.
func (m *OncallRosterMutation) UserWatchersCleared() bool {
	return m.cleareduser_watchers
}

// RemoveUserWatcherIDs removes the "user_watchers" edge to the User entity by IDs.
func (m *OncallRosterMutation) RemoveUserWatcherIDs(ids ...uuid.UUID) {
	if m.removeduser_watchers == nil {
		m.removeduser_watchers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_watchers, ids[i])
		m.removeduser_watchers[ids[i]] = struct{}{}
	}
}

// RemovedUserWatchers returns the removed IDs of the "user_watchers" edge to the User entity.
func (m *OncallRosterMutation) RemovedUserWatchersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_watchers {
		ids = append(ids, id)
	}
	return
}

// UserWatchersIDs returns the "user_watchers" edge IDs in the mutation.
func (m *OncallRosterMutation) UserWatchersIDs() (ids []uuid.UUID) {
	for id := range m.user_watchers {
		ids = append(ids, id)
	}
	return
}

// ResetUserWatchers resets all changes to the "user_watchers" edge.
func (m *OncallRosterMutation) ResetUserWatchers() {
	m.user_watchers = nil
	m.cleareduser_watchers = false
	m.removeduser_watchers = nil
}

// AddMetricIDs adds the "metrics" edge to the OncallRosterMetrics entity by ids.
func (m *OncallRosterMutation) AddMetricIDs(ids ...uuid.UUID) {
	if m.metrics == nil {
		m.metrics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metrics[ids[i]] = struct{}{}
	}
}

// ClearMetrics clears the "metrics" edge to the OncallRosterMetrics entity.
func (m *OncallRosterMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the OncallRosterMetrics entity was cleared.
func (m *OncallRosterMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// RemoveMetricIDs removes the "metrics" edge to the OncallRosterMetrics entity by IDs.
func (m *OncallRosterMutation) RemoveMetricIDs(ids ...uuid.UUID) {
	if m.removedmetrics == nil {
		m.removedmetrics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metrics, ids[i])
		m.removedmetrics[ids[i]] = struct{}{}
	}
}

// RemovedMetrics returns the removed IDs of the "metrics" edge to the OncallRosterMetrics entity.
func (m *OncallRosterMutation) RemovedMetricsIDs() (ids []uuid.UUID) {
	for id := range m.removedmetrics {
		ids = append(ids, id)
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
func (m *OncallRosterMutation) MetricsIDs() (ids []uuid.UUID) {
	for id := range m.metrics {
		ids = append(ids, id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *OncallRosterMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
	m.removedmetrics = nil
}

// Where appends a list predicates to the OncallRosterMutation builder.
func (m *OncallRosterMutation) Where(ps ...predicate.OncallRoster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallRosterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallRosterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallRoster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallRosterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallRosterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallRoster).
func (m *OncallRosterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallRosterMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenant != nil {
		fields = append(fields, oncallroster.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, oncallroster.FieldArchiveTime)
	}
	if m.external_id != nil {
		fields = append(fields, oncallroster.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, oncallroster.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, oncallroster.FieldSlug)
	}
	if m.timezone != nil {
		fields = append(fields, oncallroster.FieldTimezone)
	}
	if m.chat_handle != nil {
		fields = append(fields, oncallroster.FieldChatHandle)
	}
	if m.chat_channel_id != nil {
		fields = append(fields, oncallroster.FieldChatChannelID)
	}
	if m.handover_template != nil {
		fields = append(fields, oncallroster.FieldHandoverTemplateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallRosterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallroster.FieldTenantID:
		return m.TenantID()
	case oncallroster.FieldArchiveTime:
		return m.ArchiveTime()
	case oncallroster.FieldExternalID:
		return m.ExternalID()
	case oncallroster.FieldName:
		return m.Name()
	case oncallroster.FieldSlug:
		return m.Slug()
	case oncallroster.FieldTimezone:
		return m.Timezone()
	case oncallroster.FieldChatHandle:
		return m.ChatHandle()
	case oncallroster.FieldChatChannelID:
		return m.ChatChannelID()
	case oncallroster.FieldHandoverTemplateID:
		return m.HandoverTemplateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallRosterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallroster.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallroster.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case oncallroster.FieldExternalID:
		return m.OldExternalID(ctx)
	case oncallroster.FieldName:
		return m.OldName(ctx)
	case oncallroster.FieldSlug:
		return m.OldSlug(ctx)
	case oncallroster.FieldTimezone:
		return m.OldTimezone(ctx)
	case oncallroster.FieldChatHandle:
		return m.OldChatHandle(ctx)
	case oncallroster.FieldChatChannelID:
		return m.OldChatChannelID(ctx)
	case oncallroster.FieldHandoverTemplateID:
		return m.OldHandoverTemplateID(ctx)
	}
	return nil, fmt.Errorf("unknown OncallRoster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallRosterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallroster.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallroster.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case oncallroster.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case oncallroster.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oncallroster.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case oncallroster.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case oncallroster.FieldChatHandle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatHandle(v)
		return nil
	case oncallroster.FieldChatChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatChannelID(v)
		return nil
	case oncallroster.FieldHandoverTemplateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandoverTemplateID(v)
		return nil
	}
	return fmt.Errorf("unknown OncallRoster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallRosterMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallRosterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallRosterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallRoster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallRosterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallroster.FieldArchiveTime) {
		fields = append(fields, oncallroster.FieldArchiveTime)
	}
	if m.FieldCleared(oncallroster.FieldExternalID) {
		fields = append(fields, oncallroster.FieldExternalID)
	}
	if m.FieldCleared(oncallroster.FieldTimezone) {
		fields = append(fields, oncallroster.FieldTimezone)
	}
	if m.FieldCleared(oncallroster.FieldChatHandle) {
		fields = append(fields, oncallroster.FieldChatHandle)
	}
	if m.FieldCleared(oncallroster.FieldChatChannelID) {
		fields = append(fields, oncallroster.FieldChatChannelID)
	}
	if m.FieldCleared(oncallroster.FieldHandoverTemplateID) {
		fields = append(fields, oncallroster.FieldHandoverTemplateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallRosterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallRosterMutation) ClearField(name string) error {
	switch name {
	case oncallroster.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case oncallroster.FieldExternalID:
		m.ClearExternalID()
		return nil
	case oncallroster.FieldTimezone:
		m.ClearTimezone()
		return nil
	case oncallroster.FieldChatHandle:
		m.ClearChatHandle()
		return nil
	case oncallroster.FieldChatChannelID:
		m.ClearChatChannelID()
		return nil
	case oncallroster.FieldHandoverTemplateID:
		m.ClearHandoverTemplateID()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallRosterMutation) ResetField(name string) error {
	switch name {
	case oncallroster.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallroster.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case oncallroster.FieldExternalID:
		m.ResetExternalID()
		return nil
	case oncallroster.FieldName:
		m.ResetName()
		return nil
	case oncallroster.FieldSlug:
		m.ResetSlug()
		return nil
	case oncallroster.FieldTimezone:
		m.ResetTimezone()
		return nil
	case oncallroster.FieldChatHandle:
		m.ResetChatHandle()
		return nil
	case oncallroster.FieldChatChannelID:
		m.ResetChatChannelID()
		return nil
	case oncallroster.FieldHandoverTemplateID:
		m.ResetHandoverTemplateID()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallRosterMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tenant != nil {
		edges = append(edges, oncallroster.EdgeTenant)
	}
	if m.schedules != nil {
		edges = append(edges, oncallroster.EdgeSchedules)
	}
	if m.handover_template != nil {
		edges = append(edges, oncallroster.EdgeHandoverTemplate)
	}
	if m.alerts != nil {
		edges = append(edges, oncallroster.EdgeAlerts)
	}
	if m.teams != nil {
		edges = append(edges, oncallroster.EdgeTeams)
	}
	if m.shifts != nil {
		edges = append(edges, oncallroster.EdgeShifts)
	}
	if m.user_watchers != nil {
		edges = append(edges, oncallroster.EdgeUserWatchers)
	}
	if m.metrics != nil {
		edges = append(edges, oncallroster.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallRosterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallroster.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallroster.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeHandoverTemplate:
		if id := m.handover_template; id != nil {
			return []ent.Value{*id}
		}
	case oncallroster.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeShifts:
		ids := make([]ent.Value, 0, len(m.shifts))
		for id := range m.shifts {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeUserWatchers:
		ids := make([]ent.Value, 0, len(m.user_watchers))
		for id := range m.user_watchers {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.metrics))
		for id := range m.metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallRosterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedschedules != nil {
		edges = append(edges, oncallroster.EdgeSchedules)
	}
	if m.removedalerts != nil {
		edges = append(edges, oncallroster.EdgeAlerts)
	}
	if m.removedteams != nil {
		edges = append(edges, oncallroster.EdgeTeams)
	}
	if m.removedshifts != nil {
		edges = append(edges, oncallroster.EdgeShifts)
	}
	if m.removeduser_watchers != nil {
		edges = append(edges, oncallroster.EdgeUserWatchers)
	}
	if m.removedmetrics != nil {
		edges = append(edges, oncallroster.EdgeMetrics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallRosterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallroster.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeShifts:
		ids := make([]ent.Value, 0, len(m.removedshifts))
		for id := range m.removedshifts {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeUserWatchers:
		ids := make([]ent.Value, 0, len(m.removeduser_watchers))
		for id := range m.removeduser_watchers {
			ids = append(ids, id)
		}
		return ids
	case oncallroster.EdgeMetrics:
		ids := make([]ent.Value, 0, len(m.removedmetrics))
		for id := range m.removedmetrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallRosterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtenant {
		edges = append(edges, oncallroster.EdgeTenant)
	}
	if m.clearedschedules {
		edges = append(edges, oncallroster.EdgeSchedules)
	}
	if m.clearedhandover_template {
		edges = append(edges, oncallroster.EdgeHandoverTemplate)
	}
	if m.clearedalerts {
		edges = append(edges, oncallroster.EdgeAlerts)
	}
	if m.clearedteams {
		edges = append(edges, oncallroster.EdgeTeams)
	}
	if m.clearedshifts {
		edges = append(edges, oncallroster.EdgeShifts)
	}
	if m.cleareduser_watchers {
		edges = append(edges, oncallroster.EdgeUserWatchers)
	}
	if m.clearedmetrics {
		edges = append(edges, oncallroster.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallRosterMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallroster.EdgeTenant:
		return m.clearedtenant
	case oncallroster.EdgeSchedules:
		return m.clearedschedules
	case oncallroster.EdgeHandoverTemplate:
		return m.clearedhandover_template
	case oncallroster.EdgeAlerts:
		return m.clearedalerts
	case oncallroster.EdgeTeams:
		return m.clearedteams
	case oncallroster.EdgeShifts:
		return m.clearedshifts
	case oncallroster.EdgeUserWatchers:
		return m.cleareduser_watchers
	case oncallroster.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallRosterMutation) ClearEdge(name string) error {
	switch name {
	case oncallroster.EdgeTenant:
		m.ClearTenant()
		return nil
	case oncallroster.EdgeHandoverTemplate:
		m.ClearHandoverTemplate()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallRosterMutation) ResetEdge(name string) error {
	switch name {
	case oncallroster.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallroster.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case oncallroster.EdgeHandoverTemplate:
		m.ResetHandoverTemplate()
		return nil
	case oncallroster.EdgeAlerts:
		m.ResetAlerts()
		return nil
	case oncallroster.EdgeTeams:
		m.ResetTeams()
		return nil
	case oncallroster.EdgeShifts:
		m.ResetShifts()
		return nil
	case oncallroster.EdgeUserWatchers:
		m.ResetUserWatchers()
		return nil
	case oncallroster.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown OncallRoster edge %s", name)
}

// OncallRosterMetricsMutation represents an operation that mutates the OncallRosterMetrics nodes in the graph.
type OncallRosterMetricsMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	roster        *uuid.UUID
	clearedroster bool
	done          bool
	oldValue      func(context.Context) (*OncallRosterMetrics, error)
	predicates    []predicate.OncallRosterMetrics
}

var _ ent.Mutation = (*OncallRosterMetricsMutation)(nil)

// oncallrostermetricsOption allows management of the mutation configuration using functional options.
type oncallrostermetricsOption func(*OncallRosterMetricsMutation)

// newOncallRosterMetricsMutation creates new mutation for the OncallRosterMetrics entity.
func newOncallRosterMetricsMutation(c config, op Op, opts ...oncallrostermetricsOption) *OncallRosterMetricsMutation {
	m := &OncallRosterMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallRosterMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallRosterMetricsID sets the ID field of the mutation.
func withOncallRosterMetricsID(id uuid.UUID) oncallrostermetricsOption {
	return func(m *OncallRosterMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallRosterMetrics
		)
		m.oldValue = func(ctx context.Context) (*OncallRosterMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallRosterMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallRosterMetrics sets the old OncallRosterMetrics of the mutation.
func withOncallRosterMetrics(node *OncallRosterMetrics) oncallrostermetricsOption {
	return func(m *OncallRosterMetricsMutation) {
		m.oldValue = func(context.Context) (*OncallRosterMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallRosterMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallRosterMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallRosterMetrics entities.
func (m *OncallRosterMetricsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallRosterMetricsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallRosterMetricsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallRosterMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallRosterMetricsMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallRosterMetricsMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallRosterMetrics entity.
// If the OncallRosterMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMetricsMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallRosterMetricsMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRosterID sets the "roster_id" field.
func (m *OncallRosterMetricsMutation) SetRosterID(u uuid.UUID) {
	m.roster = &u
}

// RosterID returns the value of the "roster_id" field in the mutation.
func (m *OncallRosterMetricsMutation) RosterID() (r uuid.UUID, exists bool) {
	v := m.roster
	if v == nil {
		return
	}
	return *v, true
}

// OldRosterID returns the old "roster_id" field's value of the OncallRosterMetrics entity.
// If the OncallRosterMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallRosterMetricsMutation) OldRosterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosterID: %w", err)
	}
	return oldValue.RosterID, nil
}

// ResetRosterID resets all changes to the "roster_id" field.
func (m *OncallRosterMetricsMutation) ResetRosterID() {
	m.roster = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallRosterMetricsMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallrostermetrics.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallRosterMetricsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallRosterMetricsMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallRosterMetricsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallRosterMetricsMutation) ClearRoster() {
	m.clearedroster = true
	m.clearedFields[oncallrostermetrics.FieldRosterID] = struct{}{}
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallRosterMetricsMutation) RosterCleared() bool {
	return m.clearedroster
}

// RosterIDs returns the "roster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RosterID instead. It exists only for internal usage by the builders.
func (m *OncallRosterMetricsMutation) RosterIDs() (ids []uuid.UUID) {
	if id := m.roster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallRosterMetricsMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
}

// Where appends a list predicates to the OncallRosterMetricsMutation builder.
func (m *OncallRosterMetricsMutation) Where(ps ...predicate.OncallRosterMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallRosterMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallRosterMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallRosterMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallRosterMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallRosterMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallRosterMetrics).
func (m *OncallRosterMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallRosterMetricsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, oncallrostermetrics.FieldTenantID)
	}
	if m.roster != nil {
		fields = append(fields, oncallrostermetrics.FieldRosterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallRosterMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallrostermetrics.FieldTenantID:
		return m.TenantID()
	case oncallrostermetrics.FieldRosterID:
		return m.RosterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallRosterMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallrostermetrics.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallrostermetrics.FieldRosterID:
		return m.OldRosterID(ctx)
	}
	return nil, fmt.Errorf("unknown OncallRosterMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallRosterMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallrostermetrics.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallrostermetrics.FieldRosterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosterID(v)
		return nil
	}
	return fmt.Errorf("unknown OncallRosterMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallRosterMetricsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallRosterMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallRosterMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallRosterMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallRosterMetricsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallRosterMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallRosterMetricsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallRosterMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallRosterMetricsMutation) ResetField(name string) error {
	switch name {
	case oncallrostermetrics.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallrostermetrics.FieldRosterID:
		m.ResetRosterID()
		return nil
	}
	return fmt.Errorf("unknown OncallRosterMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallRosterMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, oncallrostermetrics.EdgeTenant)
	}
	if m.roster != nil {
		edges = append(edges, oncallrostermetrics.EdgeRoster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallRosterMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallrostermetrics.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallrostermetrics.EdgeRoster:
		if id := m.roster; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallRosterMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallRosterMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallRosterMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, oncallrostermetrics.EdgeTenant)
	}
	if m.clearedroster {
		edges = append(edges, oncallrostermetrics.EdgeRoster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallRosterMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallrostermetrics.EdgeTenant:
		return m.clearedtenant
	case oncallrostermetrics.EdgeRoster:
		return m.clearedroster
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallRosterMetricsMutation) ClearEdge(name string) error {
	switch name {
	case oncallrostermetrics.EdgeTenant:
		m.ClearTenant()
		return nil
	case oncallrostermetrics.EdgeRoster:
		m.ClearRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallRosterMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallRosterMetricsMutation) ResetEdge(name string) error {
	switch name {
	case oncallrostermetrics.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallrostermetrics.EdgeRoster:
		m.ResetRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallRosterMetrics edge %s", name)
}

// OncallScheduleMutation represents an operation that mutates the OncallSchedule nodes in the graph.
type OncallScheduleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	archive_time        *time.Time
	external_id         *string
	name                *string
	timezone            *string
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	participants        map[uuid.UUID]struct{}
	removedparticipants map[uuid.UUID]struct{}
	clearedparticipants bool
	roster              *uuid.UUID
	clearedroster       bool
	done                bool
	oldValue            func(context.Context) (*OncallSchedule, error)
	predicates          []predicate.OncallSchedule
}

var _ ent.Mutation = (*OncallScheduleMutation)(nil)

// oncallscheduleOption allows management of the mutation configuration using functional options.
type oncallscheduleOption func(*OncallScheduleMutation)

// newOncallScheduleMutation creates new mutation for the OncallSchedule entity.
func newOncallScheduleMutation(c config, op Op, opts ...oncallscheduleOption) *OncallScheduleMutation {
	m := &OncallScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallScheduleID sets the ID field of the mutation.
func withOncallScheduleID(id uuid.UUID) oncallscheduleOption {
	return func(m *OncallScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallSchedule
		)
		m.oldValue = func(ctx context.Context) (*OncallSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallSchedule sets the old OncallSchedule of the mutation.
func withOncallSchedule(node *OncallSchedule) oncallscheduleOption {
	return func(m *OncallScheduleMutation) {
		m.oldValue = func(context.Context) (*OncallSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallSchedule entities.
func (m *OncallScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallScheduleMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallScheduleMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallScheduleMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchiveTime sets the "archive_time" field.
func (m *OncallScheduleMutation) SetArchiveTime(t time.Time) {
	m.archive_time = &t
}

// ArchiveTime returns the value of the "archive_time" field in the mutation.
func (m *OncallScheduleMutation) ArchiveTime() (r time.Time, exists bool) {
	v := m.archive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveTime returns the old "archive_time" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldArchiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveTime: %w", err)
	}
	return oldValue.ArchiveTime, nil
}

// ClearArchiveTime clears the value of the "archive_time" field.
func (m *OncallScheduleMutation) ClearArchiveTime() {
	m.archive_time = nil
	m.clearedFields[oncallschedule.FieldArchiveTime] = struct{}{}
}

// ArchiveTimeCleared returns if the "archive_time" field was cleared in this mutation.
func (m *OncallScheduleMutation) ArchiveTimeCleared() bool {
	_, ok := m.clearedFields[oncallschedule.FieldArchiveTime]
	return ok
}

// ResetArchiveTime resets all changes to the "archive_time" field.
func (m *OncallScheduleMutation) ResetArchiveTime() {
	m.archive_time = nil
	delete(m.clearedFields, oncallschedule.FieldArchiveTime)
}

// SetExternalID sets the "external_id" field.
func (m *OncallScheduleMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OncallScheduleMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OncallScheduleMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[oncallschedule.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OncallScheduleMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[oncallschedule.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OncallScheduleMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, oncallschedule.FieldExternalID)
}

// SetName sets the "name" field.
func (m *OncallScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OncallScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OncallScheduleMutation) ResetName() {
	m.name = nil
}

// SetRosterID sets the "roster_id" field.
func (m *OncallScheduleMutation) SetRosterID(u uuid.UUID) {
	m.roster = &u
}

// RosterID returns the value of the "roster_id" field in the mutation.
func (m *OncallScheduleMutation) RosterID() (r uuid.UUID, exists bool) {
	v := m.roster
	if v == nil {
		return
	}
	return *v, true
}

// OldRosterID returns the old "roster_id" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldRosterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosterID: %w", err)
	}
	return oldValue.RosterID, nil
}

// ResetRosterID resets all changes to the "roster_id" field.
func (m *OncallScheduleMutation) ResetRosterID() {
	m.roster = nil
}

// SetTimezone sets the "timezone" field.
func (m *OncallScheduleMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OncallScheduleMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the OncallSchedule entity.
// If the OncallSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OncallScheduleMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[oncallschedule.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OncallScheduleMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[oncallschedule.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OncallScheduleMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, oncallschedule.FieldTimezone)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallScheduleMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallschedule.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallScheduleMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallScheduleMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddParticipantIDs adds the "participants" edge to the OncallScheduleParticipant entity by ids.
func (m *OncallScheduleMutation) AddParticipantIDs(ids ...uuid.UUID) {
	if m.participants == nil {
		m.participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the OncallScheduleParticipant entity.
func (m *OncallScheduleMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the OncallScheduleParticipant entity was cleared.
func (m *OncallScheduleMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the OncallScheduleParticipant entity by IDs.
func (m *OncallScheduleMutation) RemoveParticipantIDs(ids ...uuid.UUID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the OncallScheduleParticipant entity.
func (m *OncallScheduleMutation) RemovedParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *OncallScheduleMutation) ParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *OncallScheduleMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallScheduleMutation) ClearRoster() {
	m.clearedroster = true
	m.clearedFields[oncallschedule.FieldRosterID] = struct{}{}
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallScheduleMutation) RosterCleared() bool {
	return m.clearedroster
}

// RosterIDs returns the "roster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RosterID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleMutation) RosterIDs() (ids []uuid.UUID) {
	if id := m.roster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallScheduleMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
}

// Where appends a list predicates to the OncallScheduleMutation builder.
func (m *OncallScheduleMutation) Where(ps ...predicate.OncallSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallSchedule).
func (m *OncallScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallScheduleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, oncallschedule.FieldTenantID)
	}
	if m.archive_time != nil {
		fields = append(fields, oncallschedule.FieldArchiveTime)
	}
	if m.external_id != nil {
		fields = append(fields, oncallschedule.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, oncallschedule.FieldName)
	}
	if m.roster != nil {
		fields = append(fields, oncallschedule.FieldRosterID)
	}
	if m.timezone != nil {
		fields = append(fields, oncallschedule.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallschedule.FieldTenantID:
		return m.TenantID()
	case oncallschedule.FieldArchiveTime:
		return m.ArchiveTime()
	case oncallschedule.FieldExternalID:
		return m.ExternalID()
	case oncallschedule.FieldName:
		return m.Name()
	case oncallschedule.FieldRosterID:
		return m.RosterID()
	case oncallschedule.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallschedule.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallschedule.FieldArchiveTime:
		return m.OldArchiveTime(ctx)
	case oncallschedule.FieldExternalID:
		return m.OldExternalID(ctx)
	case oncallschedule.FieldName:
		return m.OldName(ctx)
	case oncallschedule.FieldRosterID:
		return m.OldRosterID(ctx)
	case oncallschedule.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown OncallSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallschedule.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallschedule.FieldArchiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveTime(v)
		return nil
	case oncallschedule.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case oncallschedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oncallschedule.FieldRosterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosterID(v)
		return nil
	case oncallschedule.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallScheduleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallschedule.FieldArchiveTime) {
		fields = append(fields, oncallschedule.FieldArchiveTime)
	}
	if m.FieldCleared(oncallschedule.FieldExternalID) {
		fields = append(fields, oncallschedule.FieldExternalID)
	}
	if m.FieldCleared(oncallschedule.FieldTimezone) {
		fields = append(fields, oncallschedule.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallScheduleMutation) ClearField(name string) error {
	switch name {
	case oncallschedule.FieldArchiveTime:
		m.ClearArchiveTime()
		return nil
	case oncallschedule.FieldExternalID:
		m.ClearExternalID()
		return nil
	case oncallschedule.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallScheduleMutation) ResetField(name string) error {
	switch name {
	case oncallschedule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallschedule.FieldArchiveTime:
		m.ResetArchiveTime()
		return nil
	case oncallschedule.FieldExternalID:
		m.ResetExternalID()
		return nil
	case oncallschedule.FieldName:
		m.ResetName()
		return nil
	case oncallschedule.FieldRosterID:
		m.ResetRosterID()
		return nil
	case oncallschedule.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, oncallschedule.EdgeTenant)
	}
	if m.participants != nil {
		edges = append(edges, oncallschedule.EdgeParticipants)
	}
	if m.roster != nil {
		edges = append(edges, oncallschedule.EdgeRoster)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallschedule.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallschedule.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case oncallschedule.EdgeRoster:
		if id := m.roster; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparticipants != nil {
		edges = append(edges, oncallschedule.EdgeParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallschedule.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, oncallschedule.EdgeTenant)
	}
	if m.clearedparticipants {
		edges = append(edges, oncallschedule.EdgeParticipants)
	}
	if m.clearedroster {
		edges = append(edges, oncallschedule.EdgeRoster)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallschedule.EdgeTenant:
		return m.clearedtenant
	case oncallschedule.EdgeParticipants:
		return m.clearedparticipants
	case oncallschedule.EdgeRoster:
		return m.clearedroster
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallScheduleMutation) ClearEdge(name string) error {
	switch name {
	case oncallschedule.EdgeTenant:
		m.ClearTenant()
		return nil
	case oncallschedule.EdgeRoster:
		m.ClearRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallScheduleMutation) ResetEdge(name string) error {
	switch name {
	case oncallschedule.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallschedule.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case oncallschedule.EdgeRoster:
		m.ResetRoster()
		return nil
	}
	return fmt.Errorf("unknown OncallSchedule edge %s", name)
}

// OncallScheduleParticipantMutation represents an operation that mutates the OncallScheduleParticipant nodes in the graph.
type OncallScheduleParticipantMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	index           *int
	addindex        *int
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	schedule        *uuid.UUID
	clearedschedule bool
	user            *uuid.UUID
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*OncallScheduleParticipant, error)
	predicates      []predicate.OncallScheduleParticipant
}

var _ ent.Mutation = (*OncallScheduleParticipantMutation)(nil)

// oncallscheduleparticipantOption allows management of the mutation configuration using functional options.
type oncallscheduleparticipantOption func(*OncallScheduleParticipantMutation)

// newOncallScheduleParticipantMutation creates new mutation for the OncallScheduleParticipant entity.
func newOncallScheduleParticipantMutation(c config, op Op, opts ...oncallscheduleparticipantOption) *OncallScheduleParticipantMutation {
	m := &OncallScheduleParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallScheduleParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallScheduleParticipantID sets the ID field of the mutation.
func withOncallScheduleParticipantID(id uuid.UUID) oncallscheduleparticipantOption {
	return func(m *OncallScheduleParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallScheduleParticipant
		)
		m.oldValue = func(ctx context.Context) (*OncallScheduleParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallScheduleParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallScheduleParticipant sets the old OncallScheduleParticipant of the mutation.
func withOncallScheduleParticipant(node *OncallScheduleParticipant) oncallscheduleparticipantOption {
	return func(m *OncallScheduleParticipantMutation) {
		m.oldValue = func(context.Context) (*OncallScheduleParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallScheduleParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallScheduleParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallScheduleParticipant entities.
func (m *OncallScheduleParticipantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallScheduleParticipantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallScheduleParticipantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallScheduleParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallScheduleParticipantMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallScheduleParticipantMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallScheduleParticipant entity.
// If the OncallScheduleParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleParticipantMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallScheduleParticipantMutation) ResetTenantID() {
	m.tenant = nil
}

// SetScheduleID sets the "schedule_id" field.
func (m *OncallScheduleParticipantMutation) SetScheduleID(u uuid.UUID) {
	m.schedule = &u
}

// ScheduleID returns the value of the "schedule_id" field in the mutation.
func (m *OncallScheduleParticipantMutation) ScheduleID() (r uuid.UUID, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleID returns the old "schedule_id" field's value of the OncallScheduleParticipant entity.
// If the OncallScheduleParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleParticipantMutation) OldScheduleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleID: %w", err)
	}
	return oldValue.ScheduleID, nil
}

// ResetScheduleID resets all changes to the "schedule_id" field.
func (m *OncallScheduleParticipantMutation) ResetScheduleID() {
	m.schedule = nil
}

// SetUserID sets the "user_id" field.
func (m *OncallScheduleParticipantMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OncallScheduleParticipantMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OncallScheduleParticipant entity.
// If the OncallScheduleParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleParticipantMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OncallScheduleParticipantMutation) ResetUserID() {
	m.user = nil
}

// SetIndex sets the "index" field.
func (m *OncallScheduleParticipantMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *OncallScheduleParticipantMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the OncallScheduleParticipant entity.
// If the OncallScheduleParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallScheduleParticipantMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *OncallScheduleParticipantMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *OncallScheduleParticipantMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *OncallScheduleParticipantMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallScheduleParticipantMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallscheduleparticipant.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallScheduleParticipantMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleParticipantMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallScheduleParticipantMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearSchedule clears the "schedule" edge to the OncallSchedule entity.
func (m *OncallScheduleParticipantMutation) ClearSchedule() {
	m.clearedschedule = true
	m.clearedFields[oncallscheduleparticipant.FieldScheduleID] = struct{}{}
}

// ScheduleCleared reports if the "schedule" edge to the OncallSchedule entity was cleared.
func (m *OncallScheduleParticipantMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleParticipantMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *OncallScheduleParticipantMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OncallScheduleParticipantMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oncallscheduleparticipant.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OncallScheduleParticipantMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OncallScheduleParticipantMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OncallScheduleParticipantMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OncallScheduleParticipantMutation builder.
func (m *OncallScheduleParticipantMutation) Where(ps ...predicate.OncallScheduleParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallScheduleParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallScheduleParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallScheduleParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallScheduleParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallScheduleParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallScheduleParticipant).
func (m *OncallScheduleParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallScheduleParticipantMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, oncallscheduleparticipant.FieldTenantID)
	}
	if m.schedule != nil {
		fields = append(fields, oncallscheduleparticipant.FieldScheduleID)
	}
	if m.user != nil {
		fields = append(fields, oncallscheduleparticipant.FieldUserID)
	}
	if m.index != nil {
		fields = append(fields, oncallscheduleparticipant.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallScheduleParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallscheduleparticipant.FieldTenantID:
		return m.TenantID()
	case oncallscheduleparticipant.FieldScheduleID:
		return m.ScheduleID()
	case oncallscheduleparticipant.FieldUserID:
		return m.UserID()
	case oncallscheduleparticipant.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallScheduleParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallscheduleparticipant.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallscheduleparticipant.FieldScheduleID:
		return m.OldScheduleID(ctx)
	case oncallscheduleparticipant.FieldUserID:
		return m.OldUserID(ctx)
	case oncallscheduleparticipant.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown OncallScheduleParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallscheduleparticipant.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallscheduleparticipant.FieldScheduleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleID(v)
		return nil
	case oncallscheduleparticipant.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oncallscheduleparticipant.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallScheduleParticipantMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, oncallscheduleparticipant.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallScheduleParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oncallscheduleparticipant.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallScheduleParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oncallscheduleparticipant.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallScheduleParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallScheduleParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallScheduleParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ResetField(name string) error {
	switch name {
	case oncallscheduleparticipant.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallscheduleparticipant.FieldScheduleID:
		m.ResetScheduleID()
		return nil
	case oncallscheduleparticipant.FieldUserID:
		m.ResetUserID()
		return nil
	case oncallscheduleparticipant.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallScheduleParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, oncallscheduleparticipant.EdgeTenant)
	}
	if m.schedule != nil {
		edges = append(edges, oncallscheduleparticipant.EdgeSchedule)
	}
	if m.user != nil {
		edges = append(edges, oncallscheduleparticipant.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallScheduleParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallscheduleparticipant.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallscheduleparticipant.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	case oncallscheduleparticipant.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallScheduleParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallScheduleParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallScheduleParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, oncallscheduleparticipant.EdgeTenant)
	}
	if m.clearedschedule {
		edges = append(edges, oncallscheduleparticipant.EdgeSchedule)
	}
	if m.cleareduser {
		edges = append(edges, oncallscheduleparticipant.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallScheduleParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallscheduleparticipant.EdgeTenant:
		return m.clearedtenant
	case oncallscheduleparticipant.EdgeSchedule:
		return m.clearedschedule
	case oncallscheduleparticipant.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ClearEdge(name string) error {
	switch name {
	case oncallscheduleparticipant.EdgeTenant:
		m.ClearTenant()
		return nil
	case oncallscheduleparticipant.EdgeSchedule:
		m.ClearSchedule()
		return nil
	case oncallscheduleparticipant.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallScheduleParticipantMutation) ResetEdge(name string) error {
	switch name {
	case oncallscheduleparticipant.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallscheduleparticipant.EdgeSchedule:
		m.ResetSchedule()
		return nil
	case oncallscheduleparticipant.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OncallScheduleParticipant edge %s", name)
}

// OncallShiftMutation represents an operation that mutates the OncallShift nodes in the graph.
type OncallShiftMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	external_id          *string
	role                 *oncallshift.Role
	start_at             *time.Time
	end_at               *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	user                 *uuid.UUID
	cleareduser          bool
	roster               *uuid.UUID
	clearedroster        bool
	primary_shift        *uuid.UUID
	clearedprimary_shift bool
	handover             *uuid.UUID
	clearedhandover      bool
	metrics              *uuid.UUID
	clearedmetrics       bool
	done                 bool
	oldValue             func(context.Context) (*OncallShift, error)
	predicates           []predicate.OncallShift
}

var _ ent.Mutation = (*OncallShiftMutation)(nil)

// oncallshiftOption allows management of the mutation configuration using functional options.
type oncallshiftOption func(*OncallShiftMutation)

// newOncallShiftMutation creates new mutation for the OncallShift entity.
func newOncallShiftMutation(c config, op Op, opts ...oncallshiftOption) *OncallShiftMutation {
	m := &OncallShiftMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallShift,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallShiftID sets the ID field of the mutation.
func withOncallShiftID(id uuid.UUID) oncallshiftOption {
	return func(m *OncallShiftMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallShift
		)
		m.oldValue = func(ctx context.Context) (*OncallShift, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallShift.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallShift sets the old OncallShift of the mutation.
func withOncallShift(node *OncallShift) oncallshiftOption {
	return func(m *OncallShiftMutation) {
		m.oldValue = func(context.Context) (*OncallShift, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallShiftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallShiftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallShift entities.
func (m *OncallShiftMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallShiftMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallShiftMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallShift.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallShiftMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallShiftMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallShiftMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *OncallShiftMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OncallShiftMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OncallShiftMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[oncallshift.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OncallShiftMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[oncallshift.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OncallShiftMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, oncallshift.FieldExternalID)
}

// SetUserID sets the "user_id" field.
func (m *OncallShiftMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OncallShiftMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OncallShiftMutation) ResetUserID() {
	m.user = nil
}

// SetRosterID sets the "roster_id" field.
func (m *OncallShiftMutation) SetRosterID(u uuid.UUID) {
	m.roster = &u
}

// RosterID returns the value of the "roster_id" field in the mutation.
func (m *OncallShiftMutation) RosterID() (r uuid.UUID, exists bool) {
	v := m.roster
	if v == nil {
		return
	}
	return *v, true
}

// OldRosterID returns the old "roster_id" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldRosterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRosterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRosterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRosterID: %w", err)
	}
	return oldValue.RosterID, nil
}

// ResetRosterID resets all changes to the "roster_id" field.
func (m *OncallShiftMutation) ResetRosterID() {
	m.roster = nil
}

// SetRole sets the "role" field.
func (m *OncallShiftMutation) SetRole(o oncallshift.Role) {
	m.role = &o
}

// Role returns the value of the "role" field in the mutation.
func (m *OncallShiftMutation) Role() (r oncallshift.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldRole(ctx context.Context) (v oncallshift.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *OncallShiftMutation) ClearRole() {
	m.role = nil
	m.clearedFields[oncallshift.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *OncallShiftMutation) RoleCleared() bool {
	_, ok := m.clearedFields[oncallshift.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *OncallShiftMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, oncallshift.FieldRole)
}

// SetPrimaryShiftID sets the "primary_shift_id" field.
func (m *OncallShiftMutation) SetPrimaryShiftID(u uuid.UUID) {
	m.primary_shift = &u
}

// PrimaryShiftID returns the value of the "primary_shift_id" field in the mutation.
func (m *OncallShiftMutation) PrimaryShiftID() (r uuid.UUID, exists bool) {
	v := m.primary_shift
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryShiftID returns the old "primary_shift_id" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldPrimaryShiftID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryShiftID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryShiftID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryShiftID: %w", err)
	}
	return oldValue.PrimaryShiftID, nil
}

// ClearPrimaryShiftID clears the value of the "primary_shift_id" field.
func (m *OncallShiftMutation) ClearPrimaryShiftID() {
	m.primary_shift = nil
	m.clearedFields[oncallshift.FieldPrimaryShiftID] = struct{}{}
}

// PrimaryShiftIDCleared returns if the "primary_shift_id" field was cleared in this mutation.
func (m *OncallShiftMutation) PrimaryShiftIDCleared() bool {
	_, ok := m.clearedFields[oncallshift.FieldPrimaryShiftID]
	return ok
}

// ResetPrimaryShiftID resets all changes to the "primary_shift_id" field.
func (m *OncallShiftMutation) ResetPrimaryShiftID() {
	m.primary_shift = nil
	delete(m.clearedFields, oncallshift.FieldPrimaryShiftID)
}

// SetStartAt sets the "start_at" field.
func (m *OncallShiftMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *OncallShiftMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *OncallShiftMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *OncallShiftMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *OncallShiftMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the OncallShift entity.
// If the OncallShift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *OncallShiftMutation) ResetEndAt() {
	m.end_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallShiftMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallshift.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallShiftMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallShiftMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OncallShiftMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oncallshift.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OncallShiftMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OncallShiftMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRoster clears the "roster" edge to the OncallRoster entity.
func (m *OncallShiftMutation) ClearRoster() {
	m.clearedroster = true
	m.clearedFields[oncallshift.FieldRosterID] = struct{}{}
}

// RosterCleared reports if the "roster" edge to the OncallRoster entity was cleared.
func (m *OncallShiftMutation) RosterCleared() bool {
	return m.clearedroster
}

// RosterIDs returns the "roster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RosterID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMutation) RosterIDs() (ids []uuid.UUID) {
	if id := m.roster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoster resets all changes to the "roster" edge.
func (m *OncallShiftMutation) ResetRoster() {
	m.roster = nil
	m.clearedroster = false
}

// ClearPrimaryShift clears the "primary_shift" edge to the OncallShift entity.
func (m *OncallShiftMutation) ClearPrimaryShift() {
	m.clearedprimary_shift = true
	m.clearedFields[oncallshift.FieldPrimaryShiftID] = struct{}{}
}

// PrimaryShiftCleared reports if the "primary_shift" edge to the OncallShift entity was cleared.
func (m *OncallShiftMutation) PrimaryShiftCleared() bool {
	return m.PrimaryShiftIDCleared() || m.clearedprimary_shift
}

// PrimaryShiftIDs returns the "primary_shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryShiftID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMutation) PrimaryShiftIDs() (ids []uuid.UUID) {
	if id := m.primary_shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryShift resets all changes to the "primary_shift" edge.
func (m *OncallShiftMutation) ResetPrimaryShift() {
	m.primary_shift = nil
	m.clearedprimary_shift = false
}

// SetHandoverID sets the "handover" edge to the OncallShiftHandover entity by id.
func (m *OncallShiftMutation) SetHandoverID(id uuid.UUID) {
	m.handover = &id
}

// ClearHandover clears the "handover" edge to the OncallShiftHandover entity.
func (m *OncallShiftMutation) ClearHandover() {
	m.clearedhandover = true
}

// HandoverCleared reports if the "handover" edge to the OncallShiftHandover entity was cleared.
func (m *OncallShiftMutation) HandoverCleared() bool {
	return m.clearedhandover
}

// HandoverID returns the "handover" edge ID in the mutation.
func (m *OncallShiftMutation) HandoverID() (id uuid.UUID, exists bool) {
	if m.handover != nil {
		return *m.handover, true
	}
	return
}

// HandoverIDs returns the "handover" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HandoverID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMutation) HandoverIDs() (ids []uuid.UUID) {
	if id := m.handover; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHandover resets all changes to the "handover" edge.
func (m *OncallShiftMutation) ResetHandover() {
	m.handover = nil
	m.clearedhandover = false
}

// SetMetricsID sets the "metrics" edge to the OncallShiftMetrics entity by id.
func (m *OncallShiftMutation) SetMetricsID(id uuid.UUID) {
	m.metrics = &id
}

// ClearMetrics clears the "metrics" edge to the OncallShiftMetrics entity.
func (m *OncallShiftMutation) ClearMetrics() {
	m.clearedmetrics = true
}

// MetricsCleared reports if the "metrics" edge to the OncallShiftMetrics entity was cleared.
func (m *OncallShiftMutation) MetricsCleared() bool {
	return m.clearedmetrics
}

// MetricsID returns the "metrics" edge ID in the mutation.
func (m *OncallShiftMutation) MetricsID() (id uuid.UUID, exists bool) {
	if m.metrics != nil {
		return *m.metrics, true
	}
	return
}

// MetricsIDs returns the "metrics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricsID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMutation) MetricsIDs() (ids []uuid.UUID) {
	if id := m.metrics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetrics resets all changes to the "metrics" edge.
func (m *OncallShiftMutation) ResetMetrics() {
	m.metrics = nil
	m.clearedmetrics = false
}

// Where appends a list predicates to the OncallShiftMutation builder.
func (m *OncallShiftMutation) Where(ps ...predicate.OncallShift) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallShiftMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallShiftMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallShift, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallShiftMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallShiftMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallShift).
func (m *OncallShiftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallShiftMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant != nil {
		fields = append(fields, oncallshift.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, oncallshift.FieldExternalID)
	}
	if m.user != nil {
		fields = append(fields, oncallshift.FieldUserID)
	}
	if m.roster != nil {
		fields = append(fields, oncallshift.FieldRosterID)
	}
	if m.role != nil {
		fields = append(fields, oncallshift.FieldRole)
	}
	if m.primary_shift != nil {
		fields = append(fields, oncallshift.FieldPrimaryShiftID)
	}
	if m.start_at != nil {
		fields = append(fields, oncallshift.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, oncallshift.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallShiftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallshift.FieldTenantID:
		return m.TenantID()
	case oncallshift.FieldExternalID:
		return m.ExternalID()
	case oncallshift.FieldUserID:
		return m.UserID()
	case oncallshift.FieldRosterID:
		return m.RosterID()
	case oncallshift.FieldRole:
		return m.Role()
	case oncallshift.FieldPrimaryShiftID:
		return m.PrimaryShiftID()
	case oncallshift.FieldStartAt:
		return m.StartAt()
	case oncallshift.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallShiftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallshift.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallshift.FieldExternalID:
		return m.OldExternalID(ctx)
	case oncallshift.FieldUserID:
		return m.OldUserID(ctx)
	case oncallshift.FieldRosterID:
		return m.OldRosterID(ctx)
	case oncallshift.FieldRole:
		return m.OldRole(ctx)
	case oncallshift.FieldPrimaryShiftID:
		return m.OldPrimaryShiftID(ctx)
	case oncallshift.FieldStartAt:
		return m.OldStartAt(ctx)
	case oncallshift.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown OncallShift field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallShiftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallshift.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallshift.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case oncallshift.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oncallshift.FieldRosterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRosterID(v)
		return nil
	case oncallshift.FieldRole:
		v, ok := value.(oncallshift.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case oncallshift.FieldPrimaryShiftID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryShiftID(v)
		return nil
	case oncallshift.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case oncallshift.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown OncallShift field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallShiftMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallShiftMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallShiftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallShift numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallShiftMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallshift.FieldExternalID) {
		fields = append(fields, oncallshift.FieldExternalID)
	}
	if m.FieldCleared(oncallshift.FieldRole) {
		fields = append(fields, oncallshift.FieldRole)
	}
	if m.FieldCleared(oncallshift.FieldPrimaryShiftID) {
		fields = append(fields, oncallshift.FieldPrimaryShiftID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallShiftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallShiftMutation) ClearField(name string) error {
	switch name {
	case oncallshift.FieldExternalID:
		m.ClearExternalID()
		return nil
	case oncallshift.FieldRole:
		m.ClearRole()
		return nil
	case oncallshift.FieldPrimaryShiftID:
		m.ClearPrimaryShiftID()
		return nil
	}
	return fmt.Errorf("unknown OncallShift nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallShiftMutation) ResetField(name string) error {
	switch name {
	case oncallshift.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallshift.FieldExternalID:
		m.ResetExternalID()
		return nil
	case oncallshift.FieldUserID:
		m.ResetUserID()
		return nil
	case oncallshift.FieldRosterID:
		m.ResetRosterID()
		return nil
	case oncallshift.FieldRole:
		m.ResetRole()
		return nil
	case oncallshift.FieldPrimaryShiftID:
		m.ResetPrimaryShiftID()
		return nil
	case oncallshift.FieldStartAt:
		m.ResetStartAt()
		return nil
	case oncallshift.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown OncallShift field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallShiftMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tenant != nil {
		edges = append(edges, oncallshift.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, oncallshift.EdgeUser)
	}
	if m.roster != nil {
		edges = append(edges, oncallshift.EdgeRoster)
	}
	if m.primary_shift != nil {
		edges = append(edges, oncallshift.EdgePrimaryShift)
	}
	if m.handover != nil {
		edges = append(edges, oncallshift.EdgeHandover)
	}
	if m.metrics != nil {
		edges = append(edges, oncallshift.EdgeMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallShiftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallshift.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallshift.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oncallshift.EdgeRoster:
		if id := m.roster; id != nil {
			return []ent.Value{*id}
		}
	case oncallshift.EdgePrimaryShift:
		if id := m.primary_shift; id != nil {
			return []ent.Value{*id}
		}
	case oncallshift.EdgeHandover:
		if id := m.handover; id != nil {
			return []ent.Value{*id}
		}
	case oncallshift.EdgeMetrics:
		if id := m.metrics; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallShiftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallShiftMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallShiftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtenant {
		edges = append(edges, oncallshift.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, oncallshift.EdgeUser)
	}
	if m.clearedroster {
		edges = append(edges, oncallshift.EdgeRoster)
	}
	if m.clearedprimary_shift {
		edges = append(edges, oncallshift.EdgePrimaryShift)
	}
	if m.clearedhandover {
		edges = append(edges, oncallshift.EdgeHandover)
	}
	if m.clearedmetrics {
		edges = append(edges, oncallshift.EdgeMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallShiftMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallshift.EdgeTenant:
		return m.clearedtenant
	case oncallshift.EdgeUser:
		return m.cleareduser
	case oncallshift.EdgeRoster:
		return m.clearedroster
	case oncallshift.EdgePrimaryShift:
		return m.clearedprimary_shift
	case oncallshift.EdgeHandover:
		return m.clearedhandover
	case oncallshift.EdgeMetrics:
		return m.clearedmetrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallShiftMutation) ClearEdge(name string) error {
	switch name {
	case oncallshift.EdgeTenant:
		m.ClearTenant()
		return nil
	case oncallshift.EdgeUser:
		m.ClearUser()
		return nil
	case oncallshift.EdgeRoster:
		m.ClearRoster()
		return nil
	case oncallshift.EdgePrimaryShift:
		m.ClearPrimaryShift()
		return nil
	case oncallshift.EdgeHandover:
		m.ClearHandover()
		return nil
	case oncallshift.EdgeMetrics:
		m.ClearMetrics()
		return nil
	}
	return fmt.Errorf("unknown OncallShift unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallShiftMutation) ResetEdge(name string) error {
	switch name {
	case oncallshift.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallshift.EdgeUser:
		m.ResetUser()
		return nil
	case oncallshift.EdgeRoster:
		m.ResetRoster()
		return nil
	case oncallshift.EdgePrimaryShift:
		m.ResetPrimaryShift()
		return nil
	case oncallshift.EdgeHandover:
		m.ResetHandover()
		return nil
	case oncallshift.EdgeMetrics:
		m.ResetMetrics()
		return nil
	}
	return fmt.Errorf("unknown OncallShift edge %s", name)
}

// OncallShiftHandoverMutation represents an operation that mutates the OncallShiftHandover nodes in the graph.
type OncallShiftHandoverMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	reminder_sent             *bool
	updated_at                *time.Time
	sent_at                   *time.Time
	contents                  *[]byte
	clearedFields             map[string]struct{}
	tenant                    *int
	clearedtenant             bool
	shift                     *uuid.UUID
	clearedshift              bool
	pinned_annotations        map[uuid.UUID]struct{}
	removedpinned_annotations map[uuid.UUID]struct{}
	clearedpinned_annotations bool
	done                      bool
	oldValue                  func(context.Context) (*OncallShiftHandover, error)
	predicates                []predicate.OncallShiftHandover
}

var _ ent.Mutation = (*OncallShiftHandoverMutation)(nil)

// oncallshifthandoverOption allows management of the mutation configuration using functional options.
type oncallshifthandoverOption func(*OncallShiftHandoverMutation)

// newOncallShiftHandoverMutation creates new mutation for the OncallShiftHandover entity.
func newOncallShiftHandoverMutation(c config, op Op, opts ...oncallshifthandoverOption) *OncallShiftHandoverMutation {
	m := &OncallShiftHandoverMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallShiftHandover,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallShiftHandoverID sets the ID field of the mutation.
func withOncallShiftHandoverID(id uuid.UUID) oncallshifthandoverOption {
	return func(m *OncallShiftHandoverMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallShiftHandover
		)
		m.oldValue = func(ctx context.Context) (*OncallShiftHandover, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallShiftHandover.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallShiftHandover sets the old OncallShiftHandover of the mutation.
func withOncallShiftHandover(node *OncallShiftHandover) oncallshifthandoverOption {
	return func(m *OncallShiftHandoverMutation) {
		m.oldValue = func(context.Context) (*OncallShiftHandover, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallShiftHandoverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallShiftHandoverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallShiftHandover entities.
func (m *OncallShiftHandoverMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallShiftHandoverMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallShiftHandoverMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallShiftHandover.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallShiftHandoverMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallShiftHandoverMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallShiftHandover entity.
// If the OncallShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftHandoverMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallShiftHandoverMutation) ResetTenantID() {
	m.tenant = nil
}

// SetShiftID sets the "shift_id" field.
func (m *OncallShiftHandoverMutation) SetShiftID(u uuid.UUID) {
	m.shift = &u
}

// ShiftID returns the value of the "shift_id" field in the mutation.
func (m *OncallShiftHandoverMutation) ShiftID() (r uuid.UUID, exists bool) {
	v := m.shift
	if v == nil {
		return
	}
	return *v, true
}

// OldShiftID returns the old "shift_id" field's value of the OncallShiftHandover entity.
// If the OncallShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftHandoverMutation) OldShiftID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShiftID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShiftID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShiftID: %w", err)
	}
	return oldValue.ShiftID, nil
}

// ResetShiftID resets all changes to the "shift_id" field.
func (m *OncallShiftHandoverMutation) ResetShiftID() {
	m.shift = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OncallShiftHandoverMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OncallShiftHandoverMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OncallShiftHandover entity.
// If the OncallShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftHandoverMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OncallShiftHandoverMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReminderSent sets the "reminder_sent" field.
func (m *OncallShiftHandoverMutation) SetReminderSent(b bool) {
	m.reminder_sent = &b
}

// ReminderSent returns the value of the "reminder_sent" field in the mutation.
func (m *OncallShiftHandoverMutation) ReminderSent() (r bool, exists bool) {
	v := m.reminder_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderSent returns the old "reminder_sent" field's value of the OncallShiftHandover entity.
// If the OncallShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftHandoverMutation) OldReminderSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderSent: %w", err)
	}
	return oldValue.ReminderSent, nil
}

// ResetReminderSent resets all changes to the "reminder_sent" field.
func (m *OncallShiftHandoverMutation) ResetReminderSent() {
	m.reminder_sent = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OncallShiftHandoverMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OncallShiftHandoverMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OncallShiftHandover entity.
// If the OncallShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftHandoverMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OncallShiftHandoverMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSentAt sets the "sent_at" field.
func (m *OncallShiftHandoverMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *OncallShiftHandoverMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the OncallShiftHandover entity.
// If the OncallShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftHandoverMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *OncallShiftHandoverMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[oncallshifthandover.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *OncallShiftHandoverMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[oncallshifthandover.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *OncallShiftHandoverMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, oncallshifthandover.FieldSentAt)
}

// SetContents sets the "contents" field.
func (m *OncallShiftHandoverMutation) SetContents(b []byte) {
	m.contents = &b
}

// Contents returns the value of the "contents" field in the mutation.
func (m *OncallShiftHandoverMutation) Contents() (r []byte, exists bool) {
	v := m.contents
	if v == nil {
		return
	}
	return *v, true
}

// OldContents returns the old "contents" field's value of the OncallShiftHandover entity.
// If the OncallShiftHandover object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftHandoverMutation) OldContents(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContents: %w", err)
	}
	return oldValue.Contents, nil
}

// ResetContents resets all changes to the "contents" field.
func (m *OncallShiftHandoverMutation) ResetContents() {
	m.contents = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallShiftHandoverMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallshifthandover.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallShiftHandoverMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallShiftHandoverMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallShiftHandoverMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearShift clears the "shift" edge to the OncallShift entity.
func (m *OncallShiftHandoverMutation) ClearShift() {
	m.clearedshift = true
	m.clearedFields[oncallshifthandover.FieldShiftID] = struct{}{}
}

// ShiftCleared reports if the "shift" edge to the OncallShift entity was cleared.
func (m *OncallShiftHandoverMutation) ShiftCleared() bool {
	return m.clearedshift
}

// ShiftIDs returns the "shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShiftID instead. It exists only for internal usage by the builders.
func (m *OncallShiftHandoverMutation) ShiftIDs() (ids []uuid.UUID) {
	if id := m.shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShift resets all changes to the "shift" edge.
func (m *OncallShiftHandoverMutation) ResetShift() {
	m.shift = nil
	m.clearedshift = false
}

// AddPinnedAnnotationIDs adds the "pinned_annotations" edge to the EventAnnotation entity by ids.
func (m *OncallShiftHandoverMutation) AddPinnedAnnotationIDs(ids ...uuid.UUID) {
	if m.pinned_annotations == nil {
		m.pinned_annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pinned_annotations[ids[i]] = struct{}{}
	}
}

// ClearPinnedAnnotations clears the "pinned_annotations" edge to the EventAnnotation entity.
func (m *OncallShiftHandoverMutation) ClearPinnedAnnotations() {
	m.clearedpinned_annotations = true
}

// PinnedAnnotationsCleared reports if the "pinned_annotations" edge to the EventAnnotation entity was cleared.
func (m *OncallShiftHandoverMutation) PinnedAnnotationsCleared() bool {
	return m.clearedpinned_annotations
}

// RemovePinnedAnnotationIDs removes the "pinned_annotations" edge to the EventAnnotation entity by IDs.
func (m *OncallShiftHandoverMutation) RemovePinnedAnnotationIDs(ids ...uuid.UUID) {
	if m.removedpinned_annotations == nil {
		m.removedpinned_annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pinned_annotations, ids[i])
		m.removedpinned_annotations[ids[i]] = struct{}{}
	}
}

// RemovedPinnedAnnotations returns the removed IDs of the "pinned_annotations" edge to the EventAnnotation entity.
func (m *OncallShiftHandoverMutation) RemovedPinnedAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.removedpinned_annotations {
		ids = append(ids, id)
	}
	return
}

// PinnedAnnotationsIDs returns the "pinned_annotations" edge IDs in the mutation.
func (m *OncallShiftHandoverMutation) PinnedAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.pinned_annotations {
		ids = append(ids, id)
	}
	return
}

// ResetPinnedAnnotations resets all changes to the "pinned_annotations" edge.
func (m *OncallShiftHandoverMutation) ResetPinnedAnnotations() {
	m.pinned_annotations = nil
	m.clearedpinned_annotations = false
	m.removedpinned_annotations = nil
}

// Where appends a list predicates to the OncallShiftHandoverMutation builder.
func (m *OncallShiftHandoverMutation) Where(ps ...predicate.OncallShiftHandover) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallShiftHandoverMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallShiftHandoverMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallShiftHandover, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallShiftHandoverMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallShiftHandoverMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallShiftHandover).
func (m *OncallShiftHandoverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallShiftHandoverMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, oncallshifthandover.FieldTenantID)
	}
	if m.shift != nil {
		fields = append(fields, oncallshifthandover.FieldShiftID)
	}
	if m.created_at != nil {
		fields = append(fields, oncallshifthandover.FieldCreatedAt)
	}
	if m.reminder_sent != nil {
		fields = append(fields, oncallshifthandover.FieldReminderSent)
	}
	if m.updated_at != nil {
		fields = append(fields, oncallshifthandover.FieldUpdatedAt)
	}
	if m.sent_at != nil {
		fields = append(fields, oncallshifthandover.FieldSentAt)
	}
	if m.contents != nil {
		fields = append(fields, oncallshifthandover.FieldContents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallShiftHandoverMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallshifthandover.FieldTenantID:
		return m.TenantID()
	case oncallshifthandover.FieldShiftID:
		return m.ShiftID()
	case oncallshifthandover.FieldCreatedAt:
		return m.CreatedAt()
	case oncallshifthandover.FieldReminderSent:
		return m.ReminderSent()
	case oncallshifthandover.FieldUpdatedAt:
		return m.UpdatedAt()
	case oncallshifthandover.FieldSentAt:
		return m.SentAt()
	case oncallshifthandover.FieldContents:
		return m.Contents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallShiftHandoverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallshifthandover.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallshifthandover.FieldShiftID:
		return m.OldShiftID(ctx)
	case oncallshifthandover.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oncallshifthandover.FieldReminderSent:
		return m.OldReminderSent(ctx)
	case oncallshifthandover.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oncallshifthandover.FieldSentAt:
		return m.OldSentAt(ctx)
	case oncallshifthandover.FieldContents:
		return m.OldContents(ctx)
	}
	return nil, fmt.Errorf("unknown OncallShiftHandover field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallShiftHandoverMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallshifthandover.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallshifthandover.FieldShiftID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShiftID(v)
		return nil
	case oncallshifthandover.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oncallshifthandover.FieldReminderSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderSent(v)
		return nil
	case oncallshifthandover.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oncallshifthandover.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case oncallshifthandover.FieldContents:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContents(v)
		return nil
	}
	return fmt.Errorf("unknown OncallShiftHandover field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallShiftHandoverMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallShiftHandoverMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallShiftHandoverMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OncallShiftHandover numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallShiftHandoverMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oncallshifthandover.FieldSentAt) {
		fields = append(fields, oncallshifthandover.FieldSentAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallShiftHandoverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallShiftHandoverMutation) ClearField(name string) error {
	switch name {
	case oncallshifthandover.FieldSentAt:
		m.ClearSentAt()
		return nil
	}
	return fmt.Errorf("unknown OncallShiftHandover nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallShiftHandoverMutation) ResetField(name string) error {
	switch name {
	case oncallshifthandover.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallshifthandover.FieldShiftID:
		m.ResetShiftID()
		return nil
	case oncallshifthandover.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oncallshifthandover.FieldReminderSent:
		m.ResetReminderSent()
		return nil
	case oncallshifthandover.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oncallshifthandover.FieldSentAt:
		m.ResetSentAt()
		return nil
	case oncallshifthandover.FieldContents:
		m.ResetContents()
		return nil
	}
	return fmt.Errorf("unknown OncallShiftHandover field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallShiftHandoverMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, oncallshifthandover.EdgeTenant)
	}
	if m.shift != nil {
		edges = append(edges, oncallshifthandover.EdgeShift)
	}
	if m.pinned_annotations != nil {
		edges = append(edges, oncallshifthandover.EdgePinnedAnnotations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallShiftHandoverMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallshifthandover.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallshifthandover.EdgeShift:
		if id := m.shift; id != nil {
			return []ent.Value{*id}
		}
	case oncallshifthandover.EdgePinnedAnnotations:
		ids := make([]ent.Value, 0, len(m.pinned_annotations))
		for id := range m.pinned_annotations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallShiftHandoverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpinned_annotations != nil {
		edges = append(edges, oncallshifthandover.EdgePinnedAnnotations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallShiftHandoverMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oncallshifthandover.EdgePinnedAnnotations:
		ids := make([]ent.Value, 0, len(m.removedpinned_annotations))
		for id := range m.removedpinned_annotations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallShiftHandoverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, oncallshifthandover.EdgeTenant)
	}
	if m.clearedshift {
		edges = append(edges, oncallshifthandover.EdgeShift)
	}
	if m.clearedpinned_annotations {
		edges = append(edges, oncallshifthandover.EdgePinnedAnnotations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallShiftHandoverMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallshifthandover.EdgeTenant:
		return m.clearedtenant
	case oncallshifthandover.EdgeShift:
		return m.clearedshift
	case oncallshifthandover.EdgePinnedAnnotations:
		return m.clearedpinned_annotations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallShiftHandoverMutation) ClearEdge(name string) error {
	switch name {
	case oncallshifthandover.EdgeTenant:
		m.ClearTenant()
		return nil
	case oncallshifthandover.EdgeShift:
		m.ClearShift()
		return nil
	}
	return fmt.Errorf("unknown OncallShiftHandover unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallShiftHandoverMutation) ResetEdge(name string) error {
	switch name {
	case oncallshifthandover.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallshifthandover.EdgeShift:
		m.ResetShift()
		return nil
	case oncallshifthandover.EdgePinnedAnnotations:
		m.ResetPinnedAnnotations()
		return nil
	}
	return fmt.Errorf("unknown OncallShiftHandover edge %s", name)
}

// OncallShiftMetricsMutation represents an operation that mutates the OncallShiftMetrics nodes in the graph.
type OncallShiftMetricsMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	updated_at                   *time.Time
	burden_score                 *float32
	addburden_score              *float32
	event_frequency              *float32
	addevent_frequency           *float32
	life_impact                  *float32
	addlife_impact               *float32
	time_impact                  *float32
	addtime_impact               *float32
	response_requirements        *float32
	addresponse_requirements     *float32
	isolation                    *float32
	addisolation                 *float32
	incidents_total              *float32
	addincidents_total           *float32
	incident_response_time       *float32
	addincident_response_time    *float32
	events_total                 *float32
	addevents_total              *float32
	alerts_total                 *float32
	addalerts_total              *float32
	interrupts_total             *float32
	addinterrupts_total          *float32
	interrupts_night             *float32
	addinterrupts_night          *float32
	interrupts_business_hours    *float32
	addinterrupts_business_hours *float32
	clearedFields                map[string]struct{}
	tenant                       *int
	clearedtenant                bool
	shift                        *uuid.UUID
	clearedshift                 bool
	done                         bool
	oldValue                     func(context.Context) (*OncallShiftMetrics, error)
	predicates                   []predicate.OncallShiftMetrics
}

var _ ent.Mutation = (*OncallShiftMetricsMutation)(nil)

// oncallshiftmetricsOption allows management of the mutation configuration using functional options.
type oncallshiftmetricsOption func(*OncallShiftMetricsMutation)

// newOncallShiftMetricsMutation creates new mutation for the OncallShiftMetrics entity.
func newOncallShiftMetricsMutation(c config, op Op, opts ...oncallshiftmetricsOption) *OncallShiftMetricsMutation {
	m := &OncallShiftMetricsMutation{
		config:        c,
		op:            op,
		typ:           TypeOncallShiftMetrics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOncallShiftMetricsID sets the ID field of the mutation.
func withOncallShiftMetricsID(id uuid.UUID) oncallshiftmetricsOption {
	return func(m *OncallShiftMetricsMutation) {
		var (
			err   error
			once  sync.Once
			value *OncallShiftMetrics
		)
		m.oldValue = func(ctx context.Context) (*OncallShiftMetrics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OncallShiftMetrics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOncallShiftMetrics sets the old OncallShiftMetrics of the mutation.
func withOncallShiftMetrics(node *OncallShiftMetrics) oncallshiftmetricsOption {
	return func(m *OncallShiftMetricsMutation) {
		m.oldValue = func(context.Context) (*OncallShiftMetrics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OncallShiftMetricsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OncallShiftMetricsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OncallShiftMetrics entities.
func (m *OncallShiftMetricsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OncallShiftMetricsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OncallShiftMetricsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OncallShiftMetrics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OncallShiftMetricsMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OncallShiftMetricsMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OncallShiftMetricsMutation) ResetTenantID() {
	m.tenant = nil
}

// SetShiftID sets the "shift_id" field.
func (m *OncallShiftMetricsMutation) SetShiftID(u uuid.UUID) {
	m.shift = &u
}

// ShiftID returns the value of the "shift_id" field in the mutation.
func (m *OncallShiftMetricsMutation) ShiftID() (r uuid.UUID, exists bool) {
	v := m.shift
	if v == nil {
		return
	}
	return *v, true
}

// OldShiftID returns the old "shift_id" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldShiftID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShiftID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShiftID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShiftID: %w", err)
	}
	return oldValue.ShiftID, nil
}

// ResetShiftID resets all changes to the "shift_id" field.
func (m *OncallShiftMetricsMutation) ResetShiftID() {
	m.shift = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OncallShiftMetricsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OncallShiftMetricsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OncallShiftMetricsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBurdenScore sets the "burden_score" field.
func (m *OncallShiftMetricsMutation) SetBurdenScore(f float32) {
	m.burden_score = &f
	m.addburden_score = nil
}

// BurdenScore returns the value of the "burden_score" field in the mutation.
func (m *OncallShiftMetricsMutation) BurdenScore() (r float32, exists bool) {
	v := m.burden_score
	if v == nil {
		return
	}
	return *v, true
}

// OldBurdenScore returns the old "burden_score" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldBurdenScore(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBurdenScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBurdenScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBurdenScore: %w", err)
	}
	return oldValue.BurdenScore, nil
}

// AddBurdenScore adds f to the "burden_score" field.
func (m *OncallShiftMetricsMutation) AddBurdenScore(f float32) {
	if m.addburden_score != nil {
		*m.addburden_score += f
	} else {
		m.addburden_score = &f
	}
}

// AddedBurdenScore returns the value that was added to the "burden_score" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedBurdenScore() (r float32, exists bool) {
	v := m.addburden_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetBurdenScore resets all changes to the "burden_score" field.
func (m *OncallShiftMetricsMutation) ResetBurdenScore() {
	m.burden_score = nil
	m.addburden_score = nil
}

// SetEventFrequency sets the "event_frequency" field.
func (m *OncallShiftMetricsMutation) SetEventFrequency(f float32) {
	m.event_frequency = &f
	m.addevent_frequency = nil
}

// EventFrequency returns the value of the "event_frequency" field in the mutation.
func (m *OncallShiftMetricsMutation) EventFrequency() (r float32, exists bool) {
	v := m.event_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldEventFrequency returns the old "event_frequency" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldEventFrequency(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventFrequency: %w", err)
	}
	return oldValue.EventFrequency, nil
}

// AddEventFrequency adds f to the "event_frequency" field.
func (m *OncallShiftMetricsMutation) AddEventFrequency(f float32) {
	if m.addevent_frequency != nil {
		*m.addevent_frequency += f
	} else {
		m.addevent_frequency = &f
	}
}

// AddedEventFrequency returns the value that was added to the "event_frequency" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedEventFrequency() (r float32, exists bool) {
	v := m.addevent_frequency
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventFrequency resets all changes to the "event_frequency" field.
func (m *OncallShiftMetricsMutation) ResetEventFrequency() {
	m.event_frequency = nil
	m.addevent_frequency = nil
}

// SetLifeImpact sets the "life_impact" field.
func (m *OncallShiftMetricsMutation) SetLifeImpact(f float32) {
	m.life_impact = &f
	m.addlife_impact = nil
}

// LifeImpact returns the value of the "life_impact" field in the mutation.
func (m *OncallShiftMetricsMutation) LifeImpact() (r float32, exists bool) {
	v := m.life_impact
	if v == nil {
		return
	}
	return *v, true
}

// OldLifeImpact returns the old "life_impact" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldLifeImpact(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifeImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifeImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifeImpact: %w", err)
	}
	return oldValue.LifeImpact, nil
}

// AddLifeImpact adds f to the "life_impact" field.
func (m *OncallShiftMetricsMutation) AddLifeImpact(f float32) {
	if m.addlife_impact != nil {
		*m.addlife_impact += f
	} else {
		m.addlife_impact = &f
	}
}

// AddedLifeImpact returns the value that was added to the "life_impact" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedLifeImpact() (r float32, exists bool) {
	v := m.addlife_impact
	if v == nil {
		return
	}
	return *v, true
}

// ResetLifeImpact resets all changes to the "life_impact" field.
func (m *OncallShiftMetricsMutation) ResetLifeImpact() {
	m.life_impact = nil
	m.addlife_impact = nil
}

// SetTimeImpact sets the "time_impact" field.
func (m *OncallShiftMetricsMutation) SetTimeImpact(f float32) {
	m.time_impact = &f
	m.addtime_impact = nil
}

// TimeImpact returns the value of the "time_impact" field in the mutation.
func (m *OncallShiftMetricsMutation) TimeImpact() (r float32, exists bool) {
	v := m.time_impact
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeImpact returns the old "time_impact" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldTimeImpact(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeImpact: %w", err)
	}
	return oldValue.TimeImpact, nil
}

// AddTimeImpact adds f to the "time_impact" field.
func (m *OncallShiftMetricsMutation) AddTimeImpact(f float32) {
	if m.addtime_impact != nil {
		*m.addtime_impact += f
	} else {
		m.addtime_impact = &f
	}
}

// AddedTimeImpact returns the value that was added to the "time_impact" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedTimeImpact() (r float32, exists bool) {
	v := m.addtime_impact
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeImpact resets all changes to the "time_impact" field.
func (m *OncallShiftMetricsMutation) ResetTimeImpact() {
	m.time_impact = nil
	m.addtime_impact = nil
}

// SetResponseRequirements sets the "response_requirements" field.
func (m *OncallShiftMetricsMutation) SetResponseRequirements(f float32) {
	m.response_requirements = &f
	m.addresponse_requirements = nil
}

// ResponseRequirements returns the value of the "response_requirements" field in the mutation.
func (m *OncallShiftMetricsMutation) ResponseRequirements() (r float32, exists bool) {
	v := m.response_requirements
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseRequirements returns the old "response_requirements" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldResponseRequirements(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseRequirements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseRequirements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseRequirements: %w", err)
	}
	return oldValue.ResponseRequirements, nil
}

// AddResponseRequirements adds f to the "response_requirements" field.
func (m *OncallShiftMetricsMutation) AddResponseRequirements(f float32) {
	if m.addresponse_requirements != nil {
		*m.addresponse_requirements += f
	} else {
		m.addresponse_requirements = &f
	}
}

// AddedResponseRequirements returns the value that was added to the "response_requirements" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedResponseRequirements() (r float32, exists bool) {
	v := m.addresponse_requirements
	if v == nil {
		return
	}
	return *v, true
}

// ResetResponseRequirements resets all changes to the "response_requirements" field.
func (m *OncallShiftMetricsMutation) ResetResponseRequirements() {
	m.response_requirements = nil
	m.addresponse_requirements = nil
}

// SetIsolation sets the "isolation" field.
func (m *OncallShiftMetricsMutation) SetIsolation(f float32) {
	m.isolation = &f
	m.addisolation = nil
}

// Isolation returns the value of the "isolation" field in the mutation.
func (m *OncallShiftMetricsMutation) Isolation() (r float32, exists bool) {
	v := m.isolation
	if v == nil {
		return
	}
	return *v, true
}

// OldIsolation returns the old "isolation" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldIsolation(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsolation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsolation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsolation: %w", err)
	}
	return oldValue.Isolation, nil
}

// AddIsolation adds f to the "isolation" field.
func (m *OncallShiftMetricsMutation) AddIsolation(f float32) {
	if m.addisolation != nil {
		*m.addisolation += f
	} else {
		m.addisolation = &f
	}
}

// AddedIsolation returns the value that was added to the "isolation" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedIsolation() (r float32, exists bool) {
	v := m.addisolation
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsolation resets all changes to the "isolation" field.
func (m *OncallShiftMetricsMutation) ResetIsolation() {
	m.isolation = nil
	m.addisolation = nil
}

// SetIncidentsTotal sets the "incidents_total" field.
func (m *OncallShiftMetricsMutation) SetIncidentsTotal(f float32) {
	m.incidents_total = &f
	m.addincidents_total = nil
}

// IncidentsTotal returns the value of the "incidents_total" field in the mutation.
func (m *OncallShiftMetricsMutation) IncidentsTotal() (r float32, exists bool) {
	v := m.incidents_total
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentsTotal returns the old "incidents_total" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldIncidentsTotal(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentsTotal: %w", err)
	}
	return oldValue.IncidentsTotal, nil
}

// AddIncidentsTotal adds f to the "incidents_total" field.
func (m *OncallShiftMetricsMutation) AddIncidentsTotal(f float32) {
	if m.addincidents_total != nil {
		*m.addincidents_total += f
	} else {
		m.addincidents_total = &f
	}
}

// AddedIncidentsTotal returns the value that was added to the "incidents_total" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedIncidentsTotal() (r float32, exists bool) {
	v := m.addincidents_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetIncidentsTotal resets all changes to the "incidents_total" field.
func (m *OncallShiftMetricsMutation) ResetIncidentsTotal() {
	m.incidents_total = nil
	m.addincidents_total = nil
}

// SetIncidentResponseTime sets the "incident_response_time" field.
func (m *OncallShiftMetricsMutation) SetIncidentResponseTime(f float32) {
	m.incident_response_time = &f
	m.addincident_response_time = nil
}

// IncidentResponseTime returns the value of the "incident_response_time" field in the mutation.
func (m *OncallShiftMetricsMutation) IncidentResponseTime() (r float32, exists bool) {
	v := m.incident_response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentResponseTime returns the old "incident_response_time" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldIncidentResponseTime(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentResponseTime: %w", err)
	}
	return oldValue.IncidentResponseTime, nil
}

// AddIncidentResponseTime adds f to the "incident_response_time" field.
func (m *OncallShiftMetricsMutation) AddIncidentResponseTime(f float32) {
	if m.addincident_response_time != nil {
		*m.addincident_response_time += f
	} else {
		m.addincident_response_time = &f
	}
}

// AddedIncidentResponseTime returns the value that was added to the "incident_response_time" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedIncidentResponseTime() (r float32, exists bool) {
	v := m.addincident_response_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetIncidentResponseTime resets all changes to the "incident_response_time" field.
func (m *OncallShiftMetricsMutation) ResetIncidentResponseTime() {
	m.incident_response_time = nil
	m.addincident_response_time = nil
}

// SetEventsTotal sets the "events_total" field.
func (m *OncallShiftMetricsMutation) SetEventsTotal(f float32) {
	m.events_total = &f
	m.addevents_total = nil
}

// EventsTotal returns the value of the "events_total" field in the mutation.
func (m *OncallShiftMetricsMutation) EventsTotal() (r float32, exists bool) {
	v := m.events_total
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsTotal returns the old "events_total" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldEventsTotal(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsTotal: %w", err)
	}
	return oldValue.EventsTotal, nil
}

// AddEventsTotal adds f to the "events_total" field.
func (m *OncallShiftMetricsMutation) AddEventsTotal(f float32) {
	if m.addevents_total != nil {
		*m.addevents_total += f
	} else {
		m.addevents_total = &f
	}
}

// AddedEventsTotal returns the value that was added to the "events_total" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedEventsTotal() (r float32, exists bool) {
	v := m.addevents_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventsTotal resets all changes to the "events_total" field.
func (m *OncallShiftMetricsMutation) ResetEventsTotal() {
	m.events_total = nil
	m.addevents_total = nil
}

// SetAlertsTotal sets the "alerts_total" field.
func (m *OncallShiftMetricsMutation) SetAlertsTotal(f float32) {
	m.alerts_total = &f
	m.addalerts_total = nil
}

// AlertsTotal returns the value of the "alerts_total" field in the mutation.
func (m *OncallShiftMetricsMutation) AlertsTotal() (r float32, exists bool) {
	v := m.alerts_total
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertsTotal returns the old "alerts_total" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldAlertsTotal(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertsTotal: %w", err)
	}
	return oldValue.AlertsTotal, nil
}

// AddAlertsTotal adds f to the "alerts_total" field.
func (m *OncallShiftMetricsMutation) AddAlertsTotal(f float32) {
	if m.addalerts_total != nil {
		*m.addalerts_total += f
	} else {
		m.addalerts_total = &f
	}
}

// AddedAlertsTotal returns the value that was added to the "alerts_total" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedAlertsTotal() (r float32, exists bool) {
	v := m.addalerts_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlertsTotal resets all changes to the "alerts_total" field.
func (m *OncallShiftMetricsMutation) ResetAlertsTotal() {
	m.alerts_total = nil
	m.addalerts_total = nil
}

// SetInterruptsTotal sets the "interrupts_total" field.
func (m *OncallShiftMetricsMutation) SetInterruptsTotal(f float32) {
	m.interrupts_total = &f
	m.addinterrupts_total = nil
}

// InterruptsTotal returns the value of the "interrupts_total" field in the mutation.
func (m *OncallShiftMetricsMutation) InterruptsTotal() (r float32, exists bool) {
	v := m.interrupts_total
	if v == nil {
		return
	}
	return *v, true
}

// OldInterruptsTotal returns the old "interrupts_total" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldInterruptsTotal(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterruptsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterruptsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterruptsTotal: %w", err)
	}
	return oldValue.InterruptsTotal, nil
}

// AddInterruptsTotal adds f to the "interrupts_total" field.
func (m *OncallShiftMetricsMutation) AddInterruptsTotal(f float32) {
	if m.addinterrupts_total != nil {
		*m.addinterrupts_total += f
	} else {
		m.addinterrupts_total = &f
	}
}

// AddedInterruptsTotal returns the value that was added to the "interrupts_total" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedInterruptsTotal() (r float32, exists bool) {
	v := m.addinterrupts_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetInterruptsTotal resets all changes to the "interrupts_total" field.
func (m *OncallShiftMetricsMutation) ResetInterruptsTotal() {
	m.interrupts_total = nil
	m.addinterrupts_total = nil
}

// SetInterruptsNight sets the "interrupts_night" field.
func (m *OncallShiftMetricsMutation) SetInterruptsNight(f float32) {
	m.interrupts_night = &f
	m.addinterrupts_night = nil
}

// InterruptsNight returns the value of the "interrupts_night" field in the mutation.
func (m *OncallShiftMetricsMutation) InterruptsNight() (r float32, exists bool) {
	v := m.interrupts_night
	if v == nil {
		return
	}
	return *v, true
}

// OldInterruptsNight returns the old "interrupts_night" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldInterruptsNight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterruptsNight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterruptsNight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterruptsNight: %w", err)
	}
	return oldValue.InterruptsNight, nil
}

// AddInterruptsNight adds f to the "interrupts_night" field.
func (m *OncallShiftMetricsMutation) AddInterruptsNight(f float32) {
	if m.addinterrupts_night != nil {
		*m.addinterrupts_night += f
	} else {
		m.addinterrupts_night = &f
	}
}

// AddedInterruptsNight returns the value that was added to the "interrupts_night" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedInterruptsNight() (r float32, exists bool) {
	v := m.addinterrupts_night
	if v == nil {
		return
	}
	return *v, true
}

// ResetInterruptsNight resets all changes to the "interrupts_night" field.
func (m *OncallShiftMetricsMutation) ResetInterruptsNight() {
	m.interrupts_night = nil
	m.addinterrupts_night = nil
}

// SetInterruptsBusinessHours sets the "interrupts_business_hours" field.
func (m *OncallShiftMetricsMutation) SetInterruptsBusinessHours(f float32) {
	m.interrupts_business_hours = &f
	m.addinterrupts_business_hours = nil
}

// InterruptsBusinessHours returns the value of the "interrupts_business_hours" field in the mutation.
func (m *OncallShiftMetricsMutation) InterruptsBusinessHours() (r float32, exists bool) {
	v := m.interrupts_business_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldInterruptsBusinessHours returns the old "interrupts_business_hours" field's value of the OncallShiftMetrics entity.
// If the OncallShiftMetrics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OncallShiftMetricsMutation) OldInterruptsBusinessHours(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterruptsBusinessHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterruptsBusinessHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterruptsBusinessHours: %w", err)
	}
	return oldValue.InterruptsBusinessHours, nil
}

// AddInterruptsBusinessHours adds f to the "interrupts_business_hours" field.
func (m *OncallShiftMetricsMutation) AddInterruptsBusinessHours(f float32) {
	if m.addinterrupts_business_hours != nil {
		*m.addinterrupts_business_hours += f
	} else {
		m.addinterrupts_business_hours = &f
	}
}

// AddedInterruptsBusinessHours returns the value that was added to the "interrupts_business_hours" field in this mutation.
func (m *OncallShiftMetricsMutation) AddedInterruptsBusinessHours() (r float32, exists bool) {
	v := m.addinterrupts_business_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetInterruptsBusinessHours resets all changes to the "interrupts_business_hours" field.
func (m *OncallShiftMetricsMutation) ResetInterruptsBusinessHours() {
	m.interrupts_business_hours = nil
	m.addinterrupts_business_hours = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OncallShiftMetricsMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[oncallshiftmetrics.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OncallShiftMetricsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMetricsMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OncallShiftMetricsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearShift clears the "shift" edge to the OncallShift entity.
func (m *OncallShiftMetricsMutation) ClearShift() {
	m.clearedshift = true
	m.clearedFields[oncallshiftmetrics.FieldShiftID] = struct{}{}
}

// ShiftCleared reports if the "shift" edge to the OncallShift entity was cleared.
func (m *OncallShiftMetricsMutation) ShiftCleared() bool {
	return m.clearedshift
}

// ShiftIDs returns the "shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShiftID instead. It exists only for internal usage by the builders.
func (m *OncallShiftMetricsMutation) ShiftIDs() (ids []uuid.UUID) {
	if id := m.shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShift resets all changes to the "shift" edge.
func (m *OncallShiftMetricsMutation) ResetShift() {
	m.shift = nil
	m.clearedshift = false
}

// Where appends a list predicates to the OncallShiftMetricsMutation builder.
func (m *OncallShiftMetricsMutation) Where(ps ...predicate.OncallShiftMetrics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OncallShiftMetricsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OncallShiftMetricsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OncallShiftMetrics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OncallShiftMetricsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OncallShiftMetricsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OncallShiftMetrics).
func (m *OncallShiftMetricsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OncallShiftMetricsMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.tenant != nil {
		fields = append(fields, oncallshiftmetrics.FieldTenantID)
	}
	if m.shift != nil {
		fields = append(fields, oncallshiftmetrics.FieldShiftID)
	}
	if m.updated_at != nil {
		fields = append(fields, oncallshiftmetrics.FieldUpdatedAt)
	}
	if m.burden_score != nil {
		fields = append(fields, oncallshiftmetrics.FieldBurdenScore)
	}
	if m.event_frequency != nil {
		fields = append(fields, oncallshiftmetrics.FieldEventFrequency)
	}
	if m.life_impact != nil {
		fields = append(fields, oncallshiftmetrics.FieldLifeImpact)
	}
	if m.time_impact != nil {
		fields = append(fields, oncallshiftmetrics.FieldTimeImpact)
	}
	if m.response_requirements != nil {
		fields = append(fields, oncallshiftmetrics.FieldResponseRequirements)
	}
	if m.isolation != nil {
		fields = append(fields, oncallshiftmetrics.FieldIsolation)
	}
	if m.incidents_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldIncidentsTotal)
	}
	if m.incident_response_time != nil {
		fields = append(fields, oncallshiftmetrics.FieldIncidentResponseTime)
	}
	if m.events_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldEventsTotal)
	}
	if m.alerts_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldAlertsTotal)
	}
	if m.interrupts_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldInterruptsTotal)
	}
	if m.interrupts_night != nil {
		fields = append(fields, oncallshiftmetrics.FieldInterruptsNight)
	}
	if m.interrupts_business_hours != nil {
		fields = append(fields, oncallshiftmetrics.FieldInterruptsBusinessHours)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OncallShiftMetricsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oncallshiftmetrics.FieldTenantID:
		return m.TenantID()
	case oncallshiftmetrics.FieldShiftID:
		return m.ShiftID()
	case oncallshiftmetrics.FieldUpdatedAt:
		return m.UpdatedAt()
	case oncallshiftmetrics.FieldBurdenScore:
		return m.BurdenScore()
	case oncallshiftmetrics.FieldEventFrequency:
		return m.EventFrequency()
	case oncallshiftmetrics.FieldLifeImpact:
		return m.LifeImpact()
	case oncallshiftmetrics.FieldTimeImpact:
		return m.TimeImpact()
	case oncallshiftmetrics.FieldResponseRequirements:
		return m.ResponseRequirements()
	case oncallshiftmetrics.FieldIsolation:
		return m.Isolation()
	case oncallshiftmetrics.FieldIncidentsTotal:
		return m.IncidentsTotal()
	case oncallshiftmetrics.FieldIncidentResponseTime:
		return m.IncidentResponseTime()
	case oncallshiftmetrics.FieldEventsTotal:
		return m.EventsTotal()
	case oncallshiftmetrics.FieldAlertsTotal:
		return m.AlertsTotal()
	case oncallshiftmetrics.FieldInterruptsTotal:
		return m.InterruptsTotal()
	case oncallshiftmetrics.FieldInterruptsNight:
		return m.InterruptsNight()
	case oncallshiftmetrics.FieldInterruptsBusinessHours:
		return m.InterruptsBusinessHours()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OncallShiftMetricsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oncallshiftmetrics.FieldTenantID:
		return m.OldTenantID(ctx)
	case oncallshiftmetrics.FieldShiftID:
		return m.OldShiftID(ctx)
	case oncallshiftmetrics.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oncallshiftmetrics.FieldBurdenScore:
		return m.OldBurdenScore(ctx)
	case oncallshiftmetrics.FieldEventFrequency:
		return m.OldEventFrequency(ctx)
	case oncallshiftmetrics.FieldLifeImpact:
		return m.OldLifeImpact(ctx)
	case oncallshiftmetrics.FieldTimeImpact:
		return m.OldTimeImpact(ctx)
	case oncallshiftmetrics.FieldResponseRequirements:
		return m.OldResponseRequirements(ctx)
	case oncallshiftmetrics.FieldIsolation:
		return m.OldIsolation(ctx)
	case oncallshiftmetrics.FieldIncidentsTotal:
		return m.OldIncidentsTotal(ctx)
	case oncallshiftmetrics.FieldIncidentResponseTime:
		return m.OldIncidentResponseTime(ctx)
	case oncallshiftmetrics.FieldEventsTotal:
		return m.OldEventsTotal(ctx)
	case oncallshiftmetrics.FieldAlertsTotal:
		return m.OldAlertsTotal(ctx)
	case oncallshiftmetrics.FieldInterruptsTotal:
		return m.OldInterruptsTotal(ctx)
	case oncallshiftmetrics.FieldInterruptsNight:
		return m.OldInterruptsNight(ctx)
	case oncallshiftmetrics.FieldInterruptsBusinessHours:
		return m.OldInterruptsBusinessHours(ctx)
	}
	return nil, fmt.Errorf("unknown OncallShiftMetrics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallShiftMetricsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oncallshiftmetrics.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oncallshiftmetrics.FieldShiftID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShiftID(v)
		return nil
	case oncallshiftmetrics.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oncallshiftmetrics.FieldBurdenScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBurdenScore(v)
		return nil
	case oncallshiftmetrics.FieldEventFrequency:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventFrequency(v)
		return nil
	case oncallshiftmetrics.FieldLifeImpact:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifeImpact(v)
		return nil
	case oncallshiftmetrics.FieldTimeImpact:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeImpact(v)
		return nil
	case oncallshiftmetrics.FieldResponseRequirements:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseRequirements(v)
		return nil
	case oncallshiftmetrics.FieldIsolation:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsolation(v)
		return nil
	case oncallshiftmetrics.FieldIncidentsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentsTotal(v)
		return nil
	case oncallshiftmetrics.FieldIncidentResponseTime:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentResponseTime(v)
		return nil
	case oncallshiftmetrics.FieldEventsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsTotal(v)
		return nil
	case oncallshiftmetrics.FieldAlertsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertsTotal(v)
		return nil
	case oncallshiftmetrics.FieldInterruptsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterruptsTotal(v)
		return nil
	case oncallshiftmetrics.FieldInterruptsNight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterruptsNight(v)
		return nil
	case oncallshiftmetrics.FieldInterruptsBusinessHours:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterruptsBusinessHours(v)
		return nil
	}
	return fmt.Errorf("unknown OncallShiftMetrics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OncallShiftMetricsMutation) AddedFields() []string {
	var fields []string
	if m.addburden_score != nil {
		fields = append(fields, oncallshiftmetrics.FieldBurdenScore)
	}
	if m.addevent_frequency != nil {
		fields = append(fields, oncallshiftmetrics.FieldEventFrequency)
	}
	if m.addlife_impact != nil {
		fields = append(fields, oncallshiftmetrics.FieldLifeImpact)
	}
	if m.addtime_impact != nil {
		fields = append(fields, oncallshiftmetrics.FieldTimeImpact)
	}
	if m.addresponse_requirements != nil {
		fields = append(fields, oncallshiftmetrics.FieldResponseRequirements)
	}
	if m.addisolation != nil {
		fields = append(fields, oncallshiftmetrics.FieldIsolation)
	}
	if m.addincidents_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldIncidentsTotal)
	}
	if m.addincident_response_time != nil {
		fields = append(fields, oncallshiftmetrics.FieldIncidentResponseTime)
	}
	if m.addevents_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldEventsTotal)
	}
	if m.addalerts_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldAlertsTotal)
	}
	if m.addinterrupts_total != nil {
		fields = append(fields, oncallshiftmetrics.FieldInterruptsTotal)
	}
	if m.addinterrupts_night != nil {
		fields = append(fields, oncallshiftmetrics.FieldInterruptsNight)
	}
	if m.addinterrupts_business_hours != nil {
		fields = append(fields, oncallshiftmetrics.FieldInterruptsBusinessHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OncallShiftMetricsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oncallshiftmetrics.FieldBurdenScore:
		return m.AddedBurdenScore()
	case oncallshiftmetrics.FieldEventFrequency:
		return m.AddedEventFrequency()
	case oncallshiftmetrics.FieldLifeImpact:
		return m.AddedLifeImpact()
	case oncallshiftmetrics.FieldTimeImpact:
		return m.AddedTimeImpact()
	case oncallshiftmetrics.FieldResponseRequirements:
		return m.AddedResponseRequirements()
	case oncallshiftmetrics.FieldIsolation:
		return m.AddedIsolation()
	case oncallshiftmetrics.FieldIncidentsTotal:
		return m.AddedIncidentsTotal()
	case oncallshiftmetrics.FieldIncidentResponseTime:
		return m.AddedIncidentResponseTime()
	case oncallshiftmetrics.FieldEventsTotal:
		return m.AddedEventsTotal()
	case oncallshiftmetrics.FieldAlertsTotal:
		return m.AddedAlertsTotal()
	case oncallshiftmetrics.FieldInterruptsTotal:
		return m.AddedInterruptsTotal()
	case oncallshiftmetrics.FieldInterruptsNight:
		return m.AddedInterruptsNight()
	case oncallshiftmetrics.FieldInterruptsBusinessHours:
		return m.AddedInterruptsBusinessHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OncallShiftMetricsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oncallshiftmetrics.FieldBurdenScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBurdenScore(v)
		return nil
	case oncallshiftmetrics.FieldEventFrequency:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventFrequency(v)
		return nil
	case oncallshiftmetrics.FieldLifeImpact:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLifeImpact(v)
		return nil
	case oncallshiftmetrics.FieldTimeImpact:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeImpact(v)
		return nil
	case oncallshiftmetrics.FieldResponseRequirements:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseRequirements(v)
		return nil
	case oncallshiftmetrics.FieldIsolation:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsolation(v)
		return nil
	case oncallshiftmetrics.FieldIncidentsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncidentsTotal(v)
		return nil
	case oncallshiftmetrics.FieldIncidentResponseTime:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncidentResponseTime(v)
		return nil
	case oncallshiftmetrics.FieldEventsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventsTotal(v)
		return nil
	case oncallshiftmetrics.FieldAlertsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlertsTotal(v)
		return nil
	case oncallshiftmetrics.FieldInterruptsTotal:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterruptsTotal(v)
		return nil
	case oncallshiftmetrics.FieldInterruptsNight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterruptsNight(v)
		return nil
	case oncallshiftmetrics.FieldInterruptsBusinessHours:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterruptsBusinessHours(v)
		return nil
	}
	return fmt.Errorf("unknown OncallShiftMetrics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OncallShiftMetricsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OncallShiftMetricsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OncallShiftMetricsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OncallShiftMetrics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OncallShiftMetricsMutation) ResetField(name string) error {
	switch name {
	case oncallshiftmetrics.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oncallshiftmetrics.FieldShiftID:
		m.ResetShiftID()
		return nil
	case oncallshiftmetrics.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oncallshiftmetrics.FieldBurdenScore:
		m.ResetBurdenScore()
		return nil
	case oncallshiftmetrics.FieldEventFrequency:
		m.ResetEventFrequency()
		return nil
	case oncallshiftmetrics.FieldLifeImpact:
		m.ResetLifeImpact()
		return nil
	case oncallshiftmetrics.FieldTimeImpact:
		m.ResetTimeImpact()
		return nil
	case oncallshiftmetrics.FieldResponseRequirements:
		m.ResetResponseRequirements()
		return nil
	case oncallshiftmetrics.FieldIsolation:
		m.ResetIsolation()
		return nil
	case oncallshiftmetrics.FieldIncidentsTotal:
		m.ResetIncidentsTotal()
		return nil
	case oncallshiftmetrics.FieldIncidentResponseTime:
		m.ResetIncidentResponseTime()
		return nil
	case oncallshiftmetrics.FieldEventsTotal:
		m.ResetEventsTotal()
		return nil
	case oncallshiftmetrics.FieldAlertsTotal:
		m.ResetAlertsTotal()
		return nil
	case oncallshiftmetrics.FieldInterruptsTotal:
		m.ResetInterruptsTotal()
		return nil
	case oncallshiftmetrics.FieldInterruptsNight:
		m.ResetInterruptsNight()
		return nil
	case oncallshiftmetrics.FieldInterruptsBusinessHours:
		m.ResetInterruptsBusinessHours()
		return nil
	}
	return fmt.Errorf("unknown OncallShiftMetrics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OncallShiftMetricsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, oncallshiftmetrics.EdgeTenant)
	}
	if m.shift != nil {
		edges = append(edges, oncallshiftmetrics.EdgeShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OncallShiftMetricsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oncallshiftmetrics.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case oncallshiftmetrics.EdgeShift:
		if id := m.shift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OncallShiftMetricsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OncallShiftMetricsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OncallShiftMetricsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, oncallshiftmetrics.EdgeTenant)
	}
	if m.clearedshift {
		edges = append(edges, oncallshiftmetrics.EdgeShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OncallShiftMetricsMutation) EdgeCleared(name string) bool {
	switch name {
	case oncallshiftmetrics.EdgeTenant:
		return m.clearedtenant
	case oncallshiftmetrics.EdgeShift:
		return m.clearedshift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OncallShiftMetricsMutation) ClearEdge(name string) error {
	switch name {
	case oncallshiftmetrics.EdgeTenant:
		m.ClearTenant()
		return nil
	case oncallshiftmetrics.EdgeShift:
		m.ClearShift()
		return nil
	}
	return fmt.Errorf("unknown OncallShiftMetrics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OncallShiftMetricsMutation) ResetEdge(name string) error {
	switch name {
	case oncallshiftmetrics.EdgeTenant:
		m.ResetTenant()
		return nil
	case oncallshiftmetrics.EdgeShift:
		m.ResetShift()
		return nil
	}
	return fmt.Errorf("unknown OncallShiftMetrics edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	external_id      *string
	name             *string
	initial_setup_at *time.Time
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	done             bool
	oldValue         func(context.Context) (*Organization, error)
	predicates       []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OrganizationMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OrganizationMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OrganizationMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *OrganizationMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OrganizationMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OrganizationMutation) ResetExternalID() {
	m.external_id = nil
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetInitialSetupAt sets the "initial_setup_at" field.
func (m *OrganizationMutation) SetInitialSetupAt(t time.Time) {
	m.initial_setup_at = &t
}

// InitialSetupAt returns the value of the "initial_setup_at" field in the mutation.
func (m *OrganizationMutation) InitialSetupAt() (r time.Time, exists bool) {
	v := m.initial_setup_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialSetupAt returns the old "initial_setup_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldInitialSetupAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialSetupAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialSetupAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialSetupAt: %w", err)
	}
	return oldValue.InitialSetupAt, nil
}

// ClearInitialSetupAt clears the value of the "initial_setup_at" field.
func (m *OrganizationMutation) ClearInitialSetupAt() {
	m.initial_setup_at = nil
	m.clearedFields[organization.FieldInitialSetupAt] = struct{}{}
}

// InitialSetupAtCleared returns if the "initial_setup_at" field was cleared in this mutation.
func (m *OrganizationMutation) InitialSetupAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldInitialSetupAt]
	return ok
}

// ResetInitialSetupAt resets all changes to the "initial_setup_at" field.
func (m *OrganizationMutation) ResetInitialSetupAt() {
	m.initial_setup_at = nil
	delete(m.clearedFields, organization.FieldInitialSetupAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrganizationMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[organization.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrganizationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrganizationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, organization.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, organization.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.initial_setup_at != nil {
		fields = append(fields, organization.FieldInitialSetupAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldTenantID:
		return m.TenantID()
	case organization.FieldExternalID:
		return m.ExternalID()
	case organization.FieldName:
		return m.Name()
	case organization.FieldInitialSetupAt:
		return m.InitialSetupAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldTenantID:
		return m.OldTenantID(ctx)
	case organization.FieldExternalID:
		return m.OldExternalID(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldInitialSetupAt:
		return m.OldInitialSetupAt(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case organization.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldInitialSetupAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialSetupAt(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldInitialSetupAt) {
		fields = append(fields, organization.FieldInitialSetupAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldInitialSetupAt:
		m.ClearInitialSetupAt()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldTenantID:
		m.ResetTenantID()
		return nil
	case organization.FieldExternalID:
		m.ResetExternalID()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldInitialSetupAt:
		m.ResetInitialSetupAt()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, organization.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, organization.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// PlaybookMutation represents an operation that mutates the Playbook nodes in the graph.
type PlaybookMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	external_id   *string
	title         *string
	content       *[]byte
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	alerts        map[uuid.UUID]struct{}
	removedalerts map[uuid.UUID]struct{}
	clearedalerts bool
	done          bool
	oldValue      func(context.Context) (*Playbook, error)
	predicates    []predicate.Playbook
}

var _ ent.Mutation = (*PlaybookMutation)(nil)

// playbookOption allows management of the mutation configuration using functional options.
type playbookOption func(*PlaybookMutation)

// newPlaybookMutation creates new mutation for the Playbook entity.
func newPlaybookMutation(c config, op Op, opts ...playbookOption) *PlaybookMutation {
	m := &PlaybookMutation{
		config:        c,
		op:            op,
		typ:           TypePlaybook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaybookID sets the ID field of the mutation.
func withPlaybookID(id uuid.UUID) playbookOption {
	return func(m *PlaybookMutation) {
		var (
			err   error
			once  sync.Once
			value *Playbook
		)
		m.oldValue = func(ctx context.Context) (*Playbook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Playbook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaybook sets the old Playbook of the mutation.
func withPlaybook(node *Playbook) playbookOption {
	return func(m *PlaybookMutation) {
		m.oldValue = func(context.Context) (*Playbook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaybookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaybookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Playbook entities.
func (m *PlaybookMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaybookMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaybookMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Playbook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PlaybookMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PlaybookMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Playbook entity.
// If the Playbook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybookMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PlaybookMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *PlaybookMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *PlaybookMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Playbook entity.
// If the Playbook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybookMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *PlaybookMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[playbook.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *PlaybookMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[playbook.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *PlaybookMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, playbook.FieldExternalID)
}

// SetTitle sets the "title" field.
func (m *PlaybookMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PlaybookMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Playbook entity.
// If the Playbook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybookMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PlaybookMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *PlaybookMutation) SetContent(b []byte) {
	m.content = &b
}

// Content returns the value of the "content" field in the mutation.
func (m *PlaybookMutation) Content() (r []byte, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Playbook entity.
// If the Playbook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybookMutation) OldContent(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PlaybookMutation) ResetContent() {
	m.content = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PlaybookMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[playbook.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PlaybookMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PlaybookMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PlaybookMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddAlertIDs adds the "alerts" edge to the Alert entity by ids.
func (m *PlaybookMutation) AddAlertIDs(ids ...uuid.UUID) {
	if m.alerts == nil {
		m.alerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// ClearAlerts clears the "alerts" edge to the Alert entity.
func (m *PlaybookMutation) ClearAlerts() {
	m.clearedalerts = true
}

// AlertsCleared reports if the "alerts" edge to the Alert entity was cleared.
func (m *PlaybookMutation) AlertsCleared() bool {
	return m.clearedalerts
}

// RemoveAlertIDs removes the "alerts" edge to the Alert entity by IDs.
func (m *PlaybookMutation) RemoveAlertIDs(ids ...uuid.UUID) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.alerts, ids[i])
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed IDs of the "alerts" edge to the Alert entity.
func (m *PlaybookMutation) RemovedAlertsIDs() (ids []uuid.UUID) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the "alerts" edge IDs in the mutation.
func (m *PlaybookMutation) AlertsIDs() (ids []uuid.UUID) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts resets all changes to the "alerts" edge.
func (m *PlaybookMutation) ResetAlerts() {
	m.alerts = nil
	m.clearedalerts = false
	m.removedalerts = nil
}

// Where appends a list predicates to the PlaybookMutation builder.
func (m *PlaybookMutation) Where(ps ...predicate.Playbook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaybookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaybookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Playbook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaybookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaybookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Playbook).
func (m *PlaybookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaybookMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, playbook.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, playbook.FieldExternalID)
	}
	if m.title != nil {
		fields = append(fields, playbook.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, playbook.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaybookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playbook.FieldTenantID:
		return m.TenantID()
	case playbook.FieldExternalID:
		return m.ExternalID()
	case playbook.FieldTitle:
		return m.Title()
	case playbook.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaybookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playbook.FieldTenantID:
		return m.OldTenantID(ctx)
	case playbook.FieldExternalID:
		return m.OldExternalID(ctx)
	case playbook.FieldTitle:
		return m.OldTitle(ctx)
	case playbook.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Playbook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaybookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playbook.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case playbook.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case playbook.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case playbook.FieldContent:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Playbook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaybookMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaybookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaybookMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Playbook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaybookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(playbook.FieldExternalID) {
		fields = append(fields, playbook.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaybookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaybookMutation) ClearField(name string) error {
	switch name {
	case playbook.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Playbook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaybookMutation) ResetField(name string) error {
	switch name {
	case playbook.FieldTenantID:
		m.ResetTenantID()
		return nil
	case playbook.FieldExternalID:
		m.ResetExternalID()
		return nil
	case playbook.FieldTitle:
		m.ResetTitle()
		return nil
	case playbook.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Playbook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaybookMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, playbook.EdgeTenant)
	}
	if m.alerts != nil {
		edges = append(edges, playbook.EdgeAlerts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaybookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playbook.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case playbook.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaybookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedalerts != nil {
		edges = append(edges, playbook.EdgeAlerts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaybookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case playbook.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaybookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, playbook.EdgeTenant)
	}
	if m.clearedalerts {
		edges = append(edges, playbook.EdgeAlerts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaybookMutation) EdgeCleared(name string) bool {
	switch name {
	case playbook.EdgeTenant:
		return m.clearedtenant
	case playbook.EdgeAlerts:
		return m.clearedalerts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaybookMutation) ClearEdge(name string) error {
	switch name {
	case playbook.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Playbook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaybookMutation) ResetEdge(name string) error {
	switch name {
	case playbook.EdgeTenant:
		m.ResetTenant()
		return nil
	case playbook.EdgeAlerts:
		m.ResetAlerts()
		return nil
	}
	return fmt.Errorf("unknown Playbook edge %s", name)
}

// ProviderSyncHistoryMutation represents an operation that mutates the ProviderSyncHistory nodes in the graph.
type ProviderSyncHistoryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	data_type        *string
	started_at       *time.Time
	finished_at      *time.Time
	num_mutations    *int
	addnum_mutations *int
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	done             bool
	oldValue         func(context.Context) (*ProviderSyncHistory, error)
	predicates       []predicate.ProviderSyncHistory
}

var _ ent.Mutation = (*ProviderSyncHistoryMutation)(nil)

// providersynchistoryOption allows management of the mutation configuration using functional options.
type providersynchistoryOption func(*ProviderSyncHistoryMutation)

// newProviderSyncHistoryMutation creates new mutation for the ProviderSyncHistory entity.
func newProviderSyncHistoryMutation(c config, op Op, opts ...providersynchistoryOption) *ProviderSyncHistoryMutation {
	m := &ProviderSyncHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProviderSyncHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderSyncHistoryID sets the ID field of the mutation.
func withProviderSyncHistoryID(id uuid.UUID) providersynchistoryOption {
	return func(m *ProviderSyncHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProviderSyncHistory
		)
		m.oldValue = func(ctx context.Context) (*ProviderSyncHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProviderSyncHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProviderSyncHistory sets the old ProviderSyncHistory of the mutation.
func withProviderSyncHistory(node *ProviderSyncHistory) providersynchistoryOption {
	return func(m *ProviderSyncHistoryMutation) {
		m.oldValue = func(context.Context) (*ProviderSyncHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderSyncHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderSyncHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProviderSyncHistory entities.
func (m *ProviderSyncHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderSyncHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderSyncHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProviderSyncHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ProviderSyncHistoryMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProviderSyncHistoryMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProviderSyncHistoryMutation) ResetTenantID() {
	m.tenant = nil
}

// SetDataType sets the "data_type" field.
func (m *ProviderSyncHistoryMutation) SetDataType(s string) {
	m.data_type = &s
}

// DataType returns the value of the "data_type" field in the mutation.
func (m *ProviderSyncHistoryMutation) DataType() (r string, exists bool) {
	v := m.data_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "data_type" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldDataType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ResetDataType resets all changes to the "data_type" field.
func (m *ProviderSyncHistoryMutation) ResetDataType() {
	m.data_type = nil
}

// SetStartedAt sets the "started_at" field.
func (m *ProviderSyncHistoryMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ProviderSyncHistoryMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ProviderSyncHistoryMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *ProviderSyncHistoryMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ProviderSyncHistoryMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ProviderSyncHistoryMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetNumMutations sets the "num_mutations" field.
func (m *ProviderSyncHistoryMutation) SetNumMutations(i int) {
	m.num_mutations = &i
	m.addnum_mutations = nil
}

// NumMutations returns the value of the "num_mutations" field in the mutation.
func (m *ProviderSyncHistoryMutation) NumMutations() (r int, exists bool) {
	v := m.num_mutations
	if v == nil {
		return
	}
	return *v, true
}

// OldNumMutations returns the old "num_mutations" field's value of the ProviderSyncHistory entity.
// If the ProviderSyncHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderSyncHistoryMutation) OldNumMutations(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumMutations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumMutations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumMutations: %w", err)
	}
	return oldValue.NumMutations, nil
}

// AddNumMutations adds i to the "num_mutations" field.
func (m *ProviderSyncHistoryMutation) AddNumMutations(i int) {
	if m.addnum_mutations != nil {
		*m.addnum_mutations += i
	} else {
		m.addnum_mutations = &i
	}
}

// AddedNumMutations returns the value that was added to the "num_mutations" field in this mutation.
func (m *ProviderSyncHistoryMutation) AddedNumMutations() (r int, exists bool) {
	v := m.addnum_mutations
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumMutations resets all changes to the "num_mutations" field.
func (m *ProviderSyncHistoryMutation) ResetNumMutations() {
	m.num_mutations = nil
	m.addnum_mutations = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProviderSyncHistoryMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[providersynchistory.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProviderSyncHistoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProviderSyncHistoryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProviderSyncHistoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the ProviderSyncHistoryMutation builder.
func (m *ProviderSyncHistoryMutation) Where(ps ...predicate.ProviderSyncHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderSyncHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderSyncHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProviderSyncHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderSyncHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderSyncHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProviderSyncHistory).
func (m *ProviderSyncHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderSyncHistoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, providersynchistory.FieldTenantID)
	}
	if m.data_type != nil {
		fields = append(fields, providersynchistory.FieldDataType)
	}
	if m.started_at != nil {
		fields = append(fields, providersynchistory.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, providersynchistory.FieldFinishedAt)
	}
	if m.num_mutations != nil {
		fields = append(fields, providersynchistory.FieldNumMutations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderSyncHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case providersynchistory.FieldTenantID:
		return m.TenantID()
	case providersynchistory.FieldDataType:
		return m.DataType()
	case providersynchistory.FieldStartedAt:
		return m.StartedAt()
	case providersynchistory.FieldFinishedAt:
		return m.FinishedAt()
	case providersynchistory.FieldNumMutations:
		return m.NumMutations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderSyncHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case providersynchistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case providersynchistory.FieldDataType:
		return m.OldDataType(ctx)
	case providersynchistory.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case providersynchistory.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case providersynchistory.FieldNumMutations:
		return m.OldNumMutations(ctx)
	}
	return nil, fmt.Errorf("unknown ProviderSyncHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderSyncHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case providersynchistory.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case providersynchistory.FieldDataType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	case providersynchistory.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case providersynchistory.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case providersynchistory.FieldNumMutations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumMutations(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderSyncHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addnum_mutations != nil {
		fields = append(fields, providersynchistory.FieldNumMutations)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderSyncHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case providersynchistory.FieldNumMutations:
		return m.AddedNumMutations()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderSyncHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case providersynchistory.FieldNumMutations:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumMutations(v)
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderSyncHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderSyncHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProviderSyncHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ResetField(name string) error {
	switch name {
	case providersynchistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case providersynchistory.FieldDataType:
		m.ResetDataType()
		return nil
	case providersynchistory.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case providersynchistory.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case providersynchistory.FieldNumMutations:
		m.ResetNumMutations()
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderSyncHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, providersynchistory.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderSyncHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case providersynchistory.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderSyncHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderSyncHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderSyncHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, providersynchistory.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderSyncHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case providersynchistory.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ClearEdge(name string) error {
	switch name {
	case providersynchistory.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderSyncHistoryMutation) ResetEdge(name string) error {
	switch name {
	case providersynchistory.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown ProviderSyncHistory edge %s", name)
}

// RetrospectiveMutation represents an operation that mutates the Retrospective nodes in the graph.
type RetrospectiveMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	_type                  *retrospective.Type
	state                  *retrospective.State
	clearedFields          map[string]struct{}
	tenant                 *int
	clearedtenant          bool
	incident               *uuid.UUID
	clearedincident        bool
	document               *uuid.UUID
	cleareddocument        bool
	comments               map[uuid.UUID]struct{}
	removedcomments        map[uuid.UUID]struct{}
	clearedcomments        bool
	system_analysis        *uuid.UUID
	clearedsystem_analysis bool
	done                   bool
	oldValue               func(context.Context) (*Retrospective, error)
	predicates             []predicate.Retrospective
}

var _ ent.Mutation = (*RetrospectiveMutation)(nil)

// retrospectiveOption allows management of the mutation configuration using functional options.
type retrospectiveOption func(*RetrospectiveMutation)

// newRetrospectiveMutation creates new mutation for the Retrospective entity.
func newRetrospectiveMutation(c config, op Op, opts ...retrospectiveOption) *RetrospectiveMutation {
	m := &RetrospectiveMutation{
		config:        c,
		op:            op,
		typ:           TypeRetrospective,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetrospectiveID sets the ID field of the mutation.
func withRetrospectiveID(id uuid.UUID) retrospectiveOption {
	return func(m *RetrospectiveMutation) {
		var (
			err   error
			once  sync.Once
			value *Retrospective
		)
		m.oldValue = func(ctx context.Context) (*Retrospective, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Retrospective.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetrospective sets the old Retrospective of the mutation.
func withRetrospective(node *Retrospective) retrospectiveOption {
	return func(m *RetrospectiveMutation) {
		m.oldValue = func(context.Context) (*Retrospective, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetrospectiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetrospectiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Retrospective entities.
func (m *RetrospectiveMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetrospectiveMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetrospectiveMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Retrospective.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *RetrospectiveMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RetrospectiveMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RetrospectiveMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *RetrospectiveMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *RetrospectiveMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *RetrospectiveMutation) ResetIncidentID() {
	m.incident = nil
}

// SetDocumentID sets the "document_id" field.
func (m *RetrospectiveMutation) SetDocumentID(u uuid.UUID) {
	m.document = &u
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *RetrospectiveMutation) DocumentID() (r uuid.UUID, exists bool) {
	v := m.document
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldDocumentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *RetrospectiveMutation) ResetDocumentID() {
	m.document = nil
}

// SetSystemAnalysisID sets the "system_analysis_id" field.
func (m *RetrospectiveMutation) SetSystemAnalysisID(u uuid.UUID) {
	m.system_analysis = &u
}

// SystemAnalysisID returns the value of the "system_analysis_id" field in the mutation.
func (m *RetrospectiveMutation) SystemAnalysisID() (r uuid.UUID, exists bool) {
	v := m.system_analysis
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemAnalysisID returns the old "system_analysis_id" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldSystemAnalysisID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemAnalysisID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemAnalysisID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemAnalysisID: %w", err)
	}
	return oldValue.SystemAnalysisID, nil
}

// ClearSystemAnalysisID clears the value of the "system_analysis_id" field.
func (m *RetrospectiveMutation) ClearSystemAnalysisID() {
	m.system_analysis = nil
	m.clearedFields[retrospective.FieldSystemAnalysisID] = struct{}{}
}

// SystemAnalysisIDCleared returns if the "system_analysis_id" field was cleared in this mutation.
func (m *RetrospectiveMutation) SystemAnalysisIDCleared() bool {
	_, ok := m.clearedFields[retrospective.FieldSystemAnalysisID]
	return ok
}

// ResetSystemAnalysisID resets all changes to the "system_analysis_id" field.
func (m *RetrospectiveMutation) ResetSystemAnalysisID() {
	m.system_analysis = nil
	delete(m.clearedFields, retrospective.FieldSystemAnalysisID)
}

// SetType sets the "type" field.
func (m *RetrospectiveMutation) SetType(r retrospective.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RetrospectiveMutation) GetType() (r retrospective.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldType(ctx context.Context) (v retrospective.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RetrospectiveMutation) ResetType() {
	m._type = nil
}

// SetState sets the "state" field.
func (m *RetrospectiveMutation) SetState(r retrospective.State) {
	m.state = &r
}

// State returns the value of the "state" field in the mutation.
func (m *RetrospectiveMutation) State() (r retrospective.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Retrospective entity.
// If the Retrospective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveMutation) OldState(ctx context.Context) (v retrospective.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *RetrospectiveMutation) ResetState() {
	m.state = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RetrospectiveMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[retrospective.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RetrospectiveMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RetrospectiveMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *RetrospectiveMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[retrospective.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *RetrospectiveMutation) IncidentCleared() bool {
	return m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *RetrospectiveMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearDocument clears the "document" edge to the Document entity.
func (m *RetrospectiveMutation) ClearDocument() {
	m.cleareddocument = true
	m.clearedFields[retrospective.FieldDocumentID] = struct{}{}
}

// DocumentCleared reports if the "document" edge to the Document entity was cleared.
func (m *RetrospectiveMutation) DocumentCleared() bool {
	return m.cleareddocument
}

// DocumentIDs returns the "document" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocumentID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveMutation) DocumentIDs() (ids []uuid.UUID) {
	if id := m.document; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocument resets all changes to the "document" edge.
func (m *RetrospectiveMutation) ResetDocument() {
	m.document = nil
	m.cleareddocument = false
}

// AddCommentIDs adds the "comments" edge to the RetrospectiveComment entity by ids.
func (m *RetrospectiveMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the RetrospectiveComment entity.
func (m *RetrospectiveMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the RetrospectiveComment entity was cleared.
func (m *RetrospectiveMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the RetrospectiveComment entity by IDs.
func (m *RetrospectiveMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the RetrospectiveComment entity.
func (m *RetrospectiveMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *RetrospectiveMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *RetrospectiveMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// ClearSystemAnalysis clears the "system_analysis" edge to the SystemAnalysis entity.
func (m *RetrospectiveMutation) ClearSystemAnalysis() {
	m.clearedsystem_analysis = true
	m.clearedFields[retrospective.FieldSystemAnalysisID] = struct{}{}
}

// SystemAnalysisCleared reports if the "system_analysis" edge to the SystemAnalysis entity was cleared.
func (m *RetrospectiveMutation) SystemAnalysisCleared() bool {
	return m.SystemAnalysisIDCleared() || m.clearedsystem_analysis
}

// SystemAnalysisIDs returns the "system_analysis" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SystemAnalysisID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveMutation) SystemAnalysisIDs() (ids []uuid.UUID) {
	if id := m.system_analysis; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSystemAnalysis resets all changes to the "system_analysis" edge.
func (m *RetrospectiveMutation) ResetSystemAnalysis() {
	m.system_analysis = nil
	m.clearedsystem_analysis = false
}

// Where appends a list predicates to the RetrospectiveMutation builder.
func (m *RetrospectiveMutation) Where(ps ...predicate.Retrospective) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetrospectiveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetrospectiveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Retrospective, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetrospectiveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetrospectiveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Retrospective).
func (m *RetrospectiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetrospectiveMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, retrospective.FieldTenantID)
	}
	if m.incident != nil {
		fields = append(fields, retrospective.FieldIncidentID)
	}
	if m.document != nil {
		fields = append(fields, retrospective.FieldDocumentID)
	}
	if m.system_analysis != nil {
		fields = append(fields, retrospective.FieldSystemAnalysisID)
	}
	if m._type != nil {
		fields = append(fields, retrospective.FieldType)
	}
	if m.state != nil {
		fields = append(fields, retrospective.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetrospectiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retrospective.FieldTenantID:
		return m.TenantID()
	case retrospective.FieldIncidentID:
		return m.IncidentID()
	case retrospective.FieldDocumentID:
		return m.DocumentID()
	case retrospective.FieldSystemAnalysisID:
		return m.SystemAnalysisID()
	case retrospective.FieldType:
		return m.GetType()
	case retrospective.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetrospectiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retrospective.FieldTenantID:
		return m.OldTenantID(ctx)
	case retrospective.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case retrospective.FieldDocumentID:
		return m.OldDocumentID(ctx)
	case retrospective.FieldSystemAnalysisID:
		return m.OldSystemAnalysisID(ctx)
	case retrospective.FieldType:
		return m.OldType(ctx)
	case retrospective.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Retrospective field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retrospective.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case retrospective.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case retrospective.FieldDocumentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	case retrospective.FieldSystemAnalysisID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemAnalysisID(v)
		return nil
	case retrospective.FieldType:
		v, ok := value.(retrospective.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case retrospective.FieldState:
		v, ok := value.(retrospective.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Retrospective field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetrospectiveMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetrospectiveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Retrospective numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetrospectiveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(retrospective.FieldSystemAnalysisID) {
		fields = append(fields, retrospective.FieldSystemAnalysisID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetrospectiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetrospectiveMutation) ClearField(name string) error {
	switch name {
	case retrospective.FieldSystemAnalysisID:
		m.ClearSystemAnalysisID()
		return nil
	}
	return fmt.Errorf("unknown Retrospective nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetrospectiveMutation) ResetField(name string) error {
	switch name {
	case retrospective.FieldTenantID:
		m.ResetTenantID()
		return nil
	case retrospective.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case retrospective.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	case retrospective.FieldSystemAnalysisID:
		m.ResetSystemAnalysisID()
		return nil
	case retrospective.FieldType:
		m.ResetType()
		return nil
	case retrospective.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Retrospective field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetrospectiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, retrospective.EdgeTenant)
	}
	if m.incident != nil {
		edges = append(edges, retrospective.EdgeIncident)
	}
	if m.document != nil {
		edges = append(edges, retrospective.EdgeDocument)
	}
	if m.comments != nil {
		edges = append(edges, retrospective.EdgeComments)
	}
	if m.system_analysis != nil {
		edges = append(edges, retrospective.EdgeSystemAnalysis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetrospectiveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retrospective.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case retrospective.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case retrospective.EdgeDocument:
		if id := m.document; id != nil {
			return []ent.Value{*id}
		}
	case retrospective.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case retrospective.EdgeSystemAnalysis:
		if id := m.system_analysis; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetrospectiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcomments != nil {
		edges = append(edges, retrospective.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetrospectiveMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case retrospective.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetrospectiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, retrospective.EdgeTenant)
	}
	if m.clearedincident {
		edges = append(edges, retrospective.EdgeIncident)
	}
	if m.cleareddocument {
		edges = append(edges, retrospective.EdgeDocument)
	}
	if m.clearedcomments {
		edges = append(edges, retrospective.EdgeComments)
	}
	if m.clearedsystem_analysis {
		edges = append(edges, retrospective.EdgeSystemAnalysis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetrospectiveMutation) EdgeCleared(name string) bool {
	switch name {
	case retrospective.EdgeTenant:
		return m.clearedtenant
	case retrospective.EdgeIncident:
		return m.clearedincident
	case retrospective.EdgeDocument:
		return m.cleareddocument
	case retrospective.EdgeComments:
		return m.clearedcomments
	case retrospective.EdgeSystemAnalysis:
		return m.clearedsystem_analysis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetrospectiveMutation) ClearEdge(name string) error {
	switch name {
	case retrospective.EdgeTenant:
		m.ClearTenant()
		return nil
	case retrospective.EdgeIncident:
		m.ClearIncident()
		return nil
	case retrospective.EdgeDocument:
		m.ClearDocument()
		return nil
	case retrospective.EdgeSystemAnalysis:
		m.ClearSystemAnalysis()
		return nil
	}
	return fmt.Errorf("unknown Retrospective unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetrospectiveMutation) ResetEdge(name string) error {
	switch name {
	case retrospective.EdgeTenant:
		m.ResetTenant()
		return nil
	case retrospective.EdgeIncident:
		m.ResetIncident()
		return nil
	case retrospective.EdgeDocument:
		m.ResetDocument()
		return nil
	case retrospective.EdgeComments:
		m.ResetComments()
		return nil
	case retrospective.EdgeSystemAnalysis:
		m.ResetSystemAnalysis()
		return nil
	}
	return fmt.Errorf("unknown Retrospective edge %s", name)
}

// RetrospectiveCommentMutation represents an operation that mutates the RetrospectiveComment nodes in the graph.
type RetrospectiveCommentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	content              *[]byte
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	retrospective        *uuid.UUID
	clearedretrospective bool
	user                 *uuid.UUID
	cleareduser          bool
	review               *uuid.UUID
	clearedreview        bool
	parent               *uuid.UUID
	clearedparent        bool
	replies              map[uuid.UUID]struct{}
	removedreplies       map[uuid.UUID]struct{}
	clearedreplies       bool
	done                 bool
	oldValue             func(context.Context) (*RetrospectiveComment, error)
	predicates           []predicate.RetrospectiveComment
}

var _ ent.Mutation = (*RetrospectiveCommentMutation)(nil)

// retrospectivecommentOption allows management of the mutation configuration using functional options.
type retrospectivecommentOption func(*RetrospectiveCommentMutation)

// newRetrospectiveCommentMutation creates new mutation for the RetrospectiveComment entity.
func newRetrospectiveCommentMutation(c config, op Op, opts ...retrospectivecommentOption) *RetrospectiveCommentMutation {
	m := &RetrospectiveCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeRetrospectiveComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetrospectiveCommentID sets the ID field of the mutation.
func withRetrospectiveCommentID(id uuid.UUID) retrospectivecommentOption {
	return func(m *RetrospectiveCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *RetrospectiveComment
		)
		m.oldValue = func(ctx context.Context) (*RetrospectiveComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetrospectiveComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetrospectiveComment sets the old RetrospectiveComment of the mutation.
func withRetrospectiveComment(node *RetrospectiveComment) retrospectivecommentOption {
	return func(m *RetrospectiveCommentMutation) {
		m.oldValue = func(context.Context) (*RetrospectiveComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetrospectiveCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetrospectiveCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RetrospectiveComment entities.
func (m *RetrospectiveCommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetrospectiveCommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetrospectiveCommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetrospectiveComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *RetrospectiveCommentMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RetrospectiveCommentMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the RetrospectiveComment entity.
// If the RetrospectiveComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveCommentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RetrospectiveCommentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRetrospectiveID sets the "retrospective_id" field.
func (m *RetrospectiveCommentMutation) SetRetrospectiveID(u uuid.UUID) {
	m.retrospective = &u
}

// RetrospectiveID returns the value of the "retrospective_id" field in the mutation.
func (m *RetrospectiveCommentMutation) RetrospectiveID() (r uuid.UUID, exists bool) {
	v := m.retrospective
	if v == nil {
		return
	}
	return *v, true
}

// OldRetrospectiveID returns the old "retrospective_id" field's value of the RetrospectiveComment entity.
// If the RetrospectiveComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveCommentMutation) OldRetrospectiveID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetrospectiveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetrospectiveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetrospectiveID: %w", err)
	}
	return oldValue.RetrospectiveID, nil
}

// ResetRetrospectiveID resets all changes to the "retrospective_id" field.
func (m *RetrospectiveCommentMutation) ResetRetrospectiveID() {
	m.retrospective = nil
}

// SetUserID sets the "user_id" field.
func (m *RetrospectiveCommentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RetrospectiveCommentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RetrospectiveComment entity.
// If the RetrospectiveComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveCommentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RetrospectiveCommentMutation) ResetUserID() {
	m.user = nil
}

// SetRetrospectiveReviewID sets the "retrospective_review_id" field.
func (m *RetrospectiveCommentMutation) SetRetrospectiveReviewID(u uuid.UUID) {
	m.review = &u
}

// RetrospectiveReviewID returns the value of the "retrospective_review_id" field in the mutation.
func (m *RetrospectiveCommentMutation) RetrospectiveReviewID() (r uuid.UUID, exists bool) {
	v := m.review
	if v == nil {
		return
	}
	return *v, true
}

// OldRetrospectiveReviewID returns the old "retrospective_review_id" field's value of the RetrospectiveComment entity.
// If the RetrospectiveComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveCommentMutation) OldRetrospectiveReviewID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetrospectiveReviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetrospectiveReviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetrospectiveReviewID: %w", err)
	}
	return oldValue.RetrospectiveReviewID, nil
}

// ClearRetrospectiveReviewID clears the value of the "retrospective_review_id" field.
func (m *RetrospectiveCommentMutation) ClearRetrospectiveReviewID() {
	m.review = nil
	m.clearedFields[retrospectivecomment.FieldRetrospectiveReviewID] = struct{}{}
}

// RetrospectiveReviewIDCleared returns if the "retrospective_review_id" field was cleared in this mutation.
func (m *RetrospectiveCommentMutation) RetrospectiveReviewIDCleared() bool {
	_, ok := m.clearedFields[retrospectivecomment.FieldRetrospectiveReviewID]
	return ok
}

// ResetRetrospectiveReviewID resets all changes to the "retrospective_review_id" field.
func (m *RetrospectiveCommentMutation) ResetRetrospectiveReviewID() {
	m.review = nil
	delete(m.clearedFields, retrospectivecomment.FieldRetrospectiveReviewID)
}

// SetParentReplyID sets the "parent_reply_id" field.
func (m *RetrospectiveCommentMutation) SetParentReplyID(u uuid.UUID) {
	m.parent = &u
}

// ParentReplyID returns the value of the "parent_reply_id" field in the mutation.
func (m *RetrospectiveCommentMutation) ParentReplyID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentReplyID returns the old "parent_reply_id" field's value of the RetrospectiveComment entity.
// If the RetrospectiveComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveCommentMutation) OldParentReplyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentReplyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentReplyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentReplyID: %w", err)
	}
	return oldValue.ParentReplyID, nil
}

// ClearParentReplyID clears the value of the "parent_reply_id" field.
func (m *RetrospectiveCommentMutation) ClearParentReplyID() {
	m.parent = nil
	m.clearedFields[retrospectivecomment.FieldParentReplyID] = struct{}{}
}

// ParentReplyIDCleared returns if the "parent_reply_id" field was cleared in this mutation.
func (m *RetrospectiveCommentMutation) ParentReplyIDCleared() bool {
	_, ok := m.clearedFields[retrospectivecomment.FieldParentReplyID]
	return ok
}

// ResetParentReplyID resets all changes to the "parent_reply_id" field.
func (m *RetrospectiveCommentMutation) ResetParentReplyID() {
	m.parent = nil
	delete(m.clearedFields, retrospectivecomment.FieldParentReplyID)
}

// SetContent sets the "content" field.
func (m *RetrospectiveCommentMutation) SetContent(b []byte) {
	m.content = &b
}

// Content returns the value of the "content" field in the mutation.
func (m *RetrospectiveCommentMutation) Content() (r []byte, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the RetrospectiveComment entity.
// If the RetrospectiveComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveCommentMutation) OldContent(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *RetrospectiveCommentMutation) ResetContent() {
	m.content = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RetrospectiveCommentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[retrospectivecomment.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RetrospectiveCommentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveCommentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RetrospectiveCommentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *RetrospectiveCommentMutation) ClearRetrospective() {
	m.clearedretrospective = true
	m.clearedFields[retrospectivecomment.FieldRetrospectiveID] = struct{}{}
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *RetrospectiveCommentMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveCommentMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *RetrospectiveCommentMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *RetrospectiveCommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[retrospectivecomment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RetrospectiveCommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveCommentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RetrospectiveCommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetReviewID sets the "review" edge to the RetrospectiveReview entity by id.
func (m *RetrospectiveCommentMutation) SetReviewID(id uuid.UUID) {
	m.review = &id
}

// ClearReview clears the "review" edge to the RetrospectiveReview entity.
func (m *RetrospectiveCommentMutation) ClearReview() {
	m.clearedreview = true
	m.clearedFields[retrospectivecomment.FieldRetrospectiveReviewID] = struct{}{}
}

// ReviewCleared reports if the "review" edge to the RetrospectiveReview entity was cleared.
func (m *RetrospectiveCommentMutation) ReviewCleared() bool {
	return m.RetrospectiveReviewIDCleared() || m.clearedreview
}

// ReviewID returns the "review" edge ID in the mutation.
func (m *RetrospectiveCommentMutation) ReviewID() (id uuid.UUID, exists bool) {
	if m.review != nil {
		return *m.review, true
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveCommentMutation) ReviewIDs() (ids []uuid.UUID) {
	if id := m.review; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *RetrospectiveCommentMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
}

// SetParentID sets the "parent" edge to the RetrospectiveComment entity by id.
func (m *RetrospectiveCommentMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the RetrospectiveComment entity.
func (m *RetrospectiveCommentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[retrospectivecomment.FieldParentReplyID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the RetrospectiveComment entity was cleared.
func (m *RetrospectiveCommentMutation) ParentCleared() bool {
	return m.ParentReplyIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *RetrospectiveCommentMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveCommentMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *RetrospectiveCommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddReplyIDs adds the "replies" edge to the RetrospectiveComment entity by ids.
func (m *RetrospectiveCommentMutation) AddReplyIDs(ids ...uuid.UUID) {
	if m.replies == nil {
		m.replies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the RetrospectiveComment entity.
func (m *RetrospectiveCommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the RetrospectiveComment entity was cleared.
func (m *RetrospectiveCommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the RetrospectiveComment entity by IDs.
func (m *RetrospectiveCommentMutation) RemoveReplyIDs(ids ...uuid.UUID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the RetrospectiveComment entity.
func (m *RetrospectiveCommentMutation) RemovedRepliesIDs() (ids []uuid.UUID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *RetrospectiveCommentMutation) RepliesIDs() (ids []uuid.UUID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *RetrospectiveCommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// Where appends a list predicates to the RetrospectiveCommentMutation builder.
func (m *RetrospectiveCommentMutation) Where(ps ...predicate.RetrospectiveComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetrospectiveCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetrospectiveCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RetrospectiveComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetrospectiveCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetrospectiveCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RetrospectiveComment).
func (m *RetrospectiveCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetrospectiveCommentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, retrospectivecomment.FieldTenantID)
	}
	if m.retrospective != nil {
		fields = append(fields, retrospectivecomment.FieldRetrospectiveID)
	}
	if m.user != nil {
		fields = append(fields, retrospectivecomment.FieldUserID)
	}
	if m.review != nil {
		fields = append(fields, retrospectivecomment.FieldRetrospectiveReviewID)
	}
	if m.parent != nil {
		fields = append(fields, retrospectivecomment.FieldParentReplyID)
	}
	if m.content != nil {
		fields = append(fields, retrospectivecomment.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetrospectiveCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retrospectivecomment.FieldTenantID:
		return m.TenantID()
	case retrospectivecomment.FieldRetrospectiveID:
		return m.RetrospectiveID()
	case retrospectivecomment.FieldUserID:
		return m.UserID()
	case retrospectivecomment.FieldRetrospectiveReviewID:
		return m.RetrospectiveReviewID()
	case retrospectivecomment.FieldParentReplyID:
		return m.ParentReplyID()
	case retrospectivecomment.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetrospectiveCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retrospectivecomment.FieldTenantID:
		return m.OldTenantID(ctx)
	case retrospectivecomment.FieldRetrospectiveID:
		return m.OldRetrospectiveID(ctx)
	case retrospectivecomment.FieldUserID:
		return m.OldUserID(ctx)
	case retrospectivecomment.FieldRetrospectiveReviewID:
		return m.OldRetrospectiveReviewID(ctx)
	case retrospectivecomment.FieldParentReplyID:
		return m.OldParentReplyID(ctx)
	case retrospectivecomment.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown RetrospectiveComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retrospectivecomment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case retrospectivecomment.FieldRetrospectiveID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetrospectiveID(v)
		return nil
	case retrospectivecomment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case retrospectivecomment.FieldRetrospectiveReviewID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetrospectiveReviewID(v)
		return nil
	case retrospectivecomment.FieldParentReplyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentReplyID(v)
		return nil
	case retrospectivecomment.FieldContent:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetrospectiveCommentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetrospectiveCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RetrospectiveComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetrospectiveCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(retrospectivecomment.FieldRetrospectiveReviewID) {
		fields = append(fields, retrospectivecomment.FieldRetrospectiveReviewID)
	}
	if m.FieldCleared(retrospectivecomment.FieldParentReplyID) {
		fields = append(fields, retrospectivecomment.FieldParentReplyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetrospectiveCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetrospectiveCommentMutation) ClearField(name string) error {
	switch name {
	case retrospectivecomment.FieldRetrospectiveReviewID:
		m.ClearRetrospectiveReviewID()
		return nil
	case retrospectivecomment.FieldParentReplyID:
		m.ClearParentReplyID()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetrospectiveCommentMutation) ResetField(name string) error {
	switch name {
	case retrospectivecomment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case retrospectivecomment.FieldRetrospectiveID:
		m.ResetRetrospectiveID()
		return nil
	case retrospectivecomment.FieldUserID:
		m.ResetUserID()
		return nil
	case retrospectivecomment.FieldRetrospectiveReviewID:
		m.ResetRetrospectiveReviewID()
		return nil
	case retrospectivecomment.FieldParentReplyID:
		m.ResetParentReplyID()
		return nil
	case retrospectivecomment.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetrospectiveCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tenant != nil {
		edges = append(edges, retrospectivecomment.EdgeTenant)
	}
	if m.retrospective != nil {
		edges = append(edges, retrospectivecomment.EdgeRetrospective)
	}
	if m.user != nil {
		edges = append(edges, retrospectivecomment.EdgeUser)
	}
	if m.review != nil {
		edges = append(edges, retrospectivecomment.EdgeReview)
	}
	if m.parent != nil {
		edges = append(edges, retrospectivecomment.EdgeParent)
	}
	if m.replies != nil {
		edges = append(edges, retrospectivecomment.EdgeReplies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetrospectiveCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retrospectivecomment.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivecomment.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivecomment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivecomment.EdgeReview:
		if id := m.review; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivecomment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivecomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetrospectiveCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedreplies != nil {
		edges = append(edges, retrospectivecomment.EdgeReplies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetrospectiveCommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case retrospectivecomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetrospectiveCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtenant {
		edges = append(edges, retrospectivecomment.EdgeTenant)
	}
	if m.clearedretrospective {
		edges = append(edges, retrospectivecomment.EdgeRetrospective)
	}
	if m.cleareduser {
		edges = append(edges, retrospectivecomment.EdgeUser)
	}
	if m.clearedreview {
		edges = append(edges, retrospectivecomment.EdgeReview)
	}
	if m.clearedparent {
		edges = append(edges, retrospectivecomment.EdgeParent)
	}
	if m.clearedreplies {
		edges = append(edges, retrospectivecomment.EdgeReplies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetrospectiveCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case retrospectivecomment.EdgeTenant:
		return m.clearedtenant
	case retrospectivecomment.EdgeRetrospective:
		return m.clearedretrospective
	case retrospectivecomment.EdgeUser:
		return m.cleareduser
	case retrospectivecomment.EdgeReview:
		return m.clearedreview
	case retrospectivecomment.EdgeParent:
		return m.clearedparent
	case retrospectivecomment.EdgeReplies:
		return m.clearedreplies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetrospectiveCommentMutation) ClearEdge(name string) error {
	switch name {
	case retrospectivecomment.EdgeTenant:
		m.ClearTenant()
		return nil
	case retrospectivecomment.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	case retrospectivecomment.EdgeUser:
		m.ClearUser()
		return nil
	case retrospectivecomment.EdgeReview:
		m.ClearReview()
		return nil
	case retrospectivecomment.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetrospectiveCommentMutation) ResetEdge(name string) error {
	switch name {
	case retrospectivecomment.EdgeTenant:
		m.ResetTenant()
		return nil
	case retrospectivecomment.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	case retrospectivecomment.EdgeUser:
		m.ResetUser()
		return nil
	case retrospectivecomment.EdgeReview:
		m.ResetReview()
		return nil
	case retrospectivecomment.EdgeParent:
		m.ResetParent()
		return nil
	case retrospectivecomment.EdgeReplies:
		m.ResetReplies()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveComment edge %s", name)
}

// RetrospectiveReviewMutation represents an operation that mutates the RetrospectiveReview nodes in the graph.
type RetrospectiveReviewMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	state                *retrospectivereview.State
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	retrospective        *uuid.UUID
	clearedretrospective bool
	requester            *uuid.UUID
	clearedrequester     bool
	reviewer             *uuid.UUID
	clearedreviewer      bool
	comment              *uuid.UUID
	clearedcomment       bool
	done                 bool
	oldValue             func(context.Context) (*RetrospectiveReview, error)
	predicates           []predicate.RetrospectiveReview
}

var _ ent.Mutation = (*RetrospectiveReviewMutation)(nil)

// retrospectivereviewOption allows management of the mutation configuration using functional options.
type retrospectivereviewOption func(*RetrospectiveReviewMutation)

// newRetrospectiveReviewMutation creates new mutation for the RetrospectiveReview entity.
func newRetrospectiveReviewMutation(c config, op Op, opts ...retrospectivereviewOption) *RetrospectiveReviewMutation {
	m := &RetrospectiveReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeRetrospectiveReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetrospectiveReviewID sets the ID field of the mutation.
func withRetrospectiveReviewID(id uuid.UUID) retrospectivereviewOption {
	return func(m *RetrospectiveReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *RetrospectiveReview
		)
		m.oldValue = func(ctx context.Context) (*RetrospectiveReview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetrospectiveReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetrospectiveReview sets the old RetrospectiveReview of the mutation.
func withRetrospectiveReview(node *RetrospectiveReview) retrospectivereviewOption {
	return func(m *RetrospectiveReviewMutation) {
		m.oldValue = func(context.Context) (*RetrospectiveReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetrospectiveReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetrospectiveReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RetrospectiveReview entities.
func (m *RetrospectiveReviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetrospectiveReviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetrospectiveReviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetrospectiveReview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *RetrospectiveReviewMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RetrospectiveReviewMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RetrospectiveReviewMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRetrospectiveID sets the "retrospective_id" field.
func (m *RetrospectiveReviewMutation) SetRetrospectiveID(u uuid.UUID) {
	m.retrospective = &u
}

// RetrospectiveID returns the value of the "retrospective_id" field in the mutation.
func (m *RetrospectiveReviewMutation) RetrospectiveID() (r uuid.UUID, exists bool) {
	v := m.retrospective
	if v == nil {
		return
	}
	return *v, true
}

// OldRetrospectiveID returns the old "retrospective_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldRetrospectiveID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetrospectiveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetrospectiveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetrospectiveID: %w", err)
	}
	return oldValue.RetrospectiveID, nil
}

// ResetRetrospectiveID resets all changes to the "retrospective_id" field.
func (m *RetrospectiveReviewMutation) ResetRetrospectiveID() {
	m.retrospective = nil
}

// SetCommentID sets the "comment_id" field.
func (m *RetrospectiveReviewMutation) SetCommentID(u uuid.UUID) {
	m.comment = &u
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *RetrospectiveReviewMutation) CommentID() (r uuid.UUID, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentID returns the old "comment_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldCommentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentID: %w", err)
	}
	return oldValue.CommentID, nil
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *RetrospectiveReviewMutation) ResetCommentID() {
	m.comment = nil
}

// SetRequesterID sets the "requester_id" field.
func (m *RetrospectiveReviewMutation) SetRequesterID(u uuid.UUID) {
	m.requester = &u
}

// RequesterID returns the value of the "requester_id" field in the mutation.
func (m *RetrospectiveReviewMutation) RequesterID() (r uuid.UUID, exists bool) {
	v := m.requester
	if v == nil {
		return
	}
	return *v, true
}

// OldRequesterID returns the old "requester_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldRequesterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequesterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequesterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequesterID: %w", err)
	}
	return oldValue.RequesterID, nil
}

// ResetRequesterID resets all changes to the "requester_id" field.
func (m *RetrospectiveReviewMutation) ResetRequesterID() {
	m.requester = nil
}

// SetReviewerID sets the "reviewer_id" field.
func (m *RetrospectiveReviewMutation) SetReviewerID(u uuid.UUID) {
	m.reviewer = &u
}

// ReviewerID returns the value of the "reviewer_id" field in the mutation.
func (m *RetrospectiveReviewMutation) ReviewerID() (r uuid.UUID, exists bool) {
	v := m.reviewer
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewerID returns the old "reviewer_id" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldReviewerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewerID: %w", err)
	}
	return oldValue.ReviewerID, nil
}

// ResetReviewerID resets all changes to the "reviewer_id" field.
func (m *RetrospectiveReviewMutation) ResetReviewerID() {
	m.reviewer = nil
}

// SetState sets the "state" field.
func (m *RetrospectiveReviewMutation) SetState(r retrospectivereview.State) {
	m.state = &r
}

// State returns the value of the "state" field in the mutation.
func (m *RetrospectiveReviewMutation) State() (r retrospectivereview.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the RetrospectiveReview entity.
// If the RetrospectiveReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetrospectiveReviewMutation) OldState(ctx context.Context) (v retrospectivereview.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *RetrospectiveReviewMutation) ResetState() {
	m.state = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RetrospectiveReviewMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[retrospectivereview.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RetrospectiveReviewMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RetrospectiveReviewMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *RetrospectiveReviewMutation) ClearRetrospective() {
	m.clearedretrospective = true
	m.clearedFields[retrospectivereview.FieldRetrospectiveID] = struct{}{}
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *RetrospectiveReviewMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *RetrospectiveReviewMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// ClearRequester clears the "requester" edge to the User entity.
func (m *RetrospectiveReviewMutation) ClearRequester() {
	m.clearedrequester = true
	m.clearedFields[retrospectivereview.FieldRequesterID] = struct{}{}
}

// RequesterCleared reports if the "requester" edge to the User entity was cleared.
func (m *RetrospectiveReviewMutation) RequesterCleared() bool {
	return m.clearedrequester
}

// RequesterIDs returns the "requester" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequesterID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) RequesterIDs() (ids []uuid.UUID) {
	if id := m.requester; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequester resets all changes to the "requester" edge.
func (m *RetrospectiveReviewMutation) ResetRequester() {
	m.requester = nil
	m.clearedrequester = false
}

// ClearReviewer clears the "reviewer" edge to the User entity.
func (m *RetrospectiveReviewMutation) ClearReviewer() {
	m.clearedreviewer = true
	m.clearedFields[retrospectivereview.FieldReviewerID] = struct{}{}
}

// ReviewerCleared reports if the "reviewer" edge to the User entity was cleared.
func (m *RetrospectiveReviewMutation) ReviewerCleared() bool {
	return m.clearedreviewer
}

// ReviewerIDs returns the "reviewer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewerID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) ReviewerIDs() (ids []uuid.UUID) {
	if id := m.reviewer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReviewer resets all changes to the "reviewer" edge.
func (m *RetrospectiveReviewMutation) ResetReviewer() {
	m.reviewer = nil
	m.clearedreviewer = false
}

// ClearComment clears the "comment" edge to the RetrospectiveComment entity.
func (m *RetrospectiveReviewMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[retrospectivereview.FieldCommentID] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the RetrospectiveComment entity was cleared.
func (m *RetrospectiveReviewMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *RetrospectiveReviewMutation) CommentIDs() (ids []uuid.UUID) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *RetrospectiveReviewMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the RetrospectiveReviewMutation builder.
func (m *RetrospectiveReviewMutation) Where(ps ...predicate.RetrospectiveReview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetrospectiveReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetrospectiveReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RetrospectiveReview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetrospectiveReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetrospectiveReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RetrospectiveReview).
func (m *RetrospectiveReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetrospectiveReviewMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, retrospectivereview.FieldTenantID)
	}
	if m.retrospective != nil {
		fields = append(fields, retrospectivereview.FieldRetrospectiveID)
	}
	if m.comment != nil {
		fields = append(fields, retrospectivereview.FieldCommentID)
	}
	if m.requester != nil {
		fields = append(fields, retrospectivereview.FieldRequesterID)
	}
	if m.reviewer != nil {
		fields = append(fields, retrospectivereview.FieldReviewerID)
	}
	if m.state != nil {
		fields = append(fields, retrospectivereview.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetrospectiveReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retrospectivereview.FieldTenantID:
		return m.TenantID()
	case retrospectivereview.FieldRetrospectiveID:
		return m.RetrospectiveID()
	case retrospectivereview.FieldCommentID:
		return m.CommentID()
	case retrospectivereview.FieldRequesterID:
		return m.RequesterID()
	case retrospectivereview.FieldReviewerID:
		return m.ReviewerID()
	case retrospectivereview.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetrospectiveReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retrospectivereview.FieldTenantID:
		return m.OldTenantID(ctx)
	case retrospectivereview.FieldRetrospectiveID:
		return m.OldRetrospectiveID(ctx)
	case retrospectivereview.FieldCommentID:
		return m.OldCommentID(ctx)
	case retrospectivereview.FieldRequesterID:
		return m.OldRequesterID(ctx)
	case retrospectivereview.FieldReviewerID:
		return m.OldReviewerID(ctx)
	case retrospectivereview.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown RetrospectiveReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retrospectivereview.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case retrospectivereview.FieldRetrospectiveID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetrospectiveID(v)
		return nil
	case retrospectivereview.FieldCommentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case retrospectivereview.FieldRequesterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequesterID(v)
		return nil
	case retrospectivereview.FieldReviewerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewerID(v)
		return nil
	case retrospectivereview.FieldState:
		v, ok := value.(retrospectivereview.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetrospectiveReviewMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetrospectiveReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetrospectiveReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RetrospectiveReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetrospectiveReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetrospectiveReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetrospectiveReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RetrospectiveReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetrospectiveReviewMutation) ResetField(name string) error {
	switch name {
	case retrospectivereview.FieldTenantID:
		m.ResetTenantID()
		return nil
	case retrospectivereview.FieldRetrospectiveID:
		m.ResetRetrospectiveID()
		return nil
	case retrospectivereview.FieldCommentID:
		m.ResetCommentID()
		return nil
	case retrospectivereview.FieldRequesterID:
		m.ResetRequesterID()
		return nil
	case retrospectivereview.FieldReviewerID:
		m.ResetReviewerID()
		return nil
	case retrospectivereview.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetrospectiveReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, retrospectivereview.EdgeTenant)
	}
	if m.retrospective != nil {
		edges = append(edges, retrospectivereview.EdgeRetrospective)
	}
	if m.requester != nil {
		edges = append(edges, retrospectivereview.EdgeRequester)
	}
	if m.reviewer != nil {
		edges = append(edges, retrospectivereview.EdgeReviewer)
	}
	if m.comment != nil {
		edges = append(edges, retrospectivereview.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetrospectiveReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retrospectivereview.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivereview.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivereview.EdgeRequester:
		if id := m.requester; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivereview.EdgeReviewer:
		if id := m.reviewer; id != nil {
			return []ent.Value{*id}
		}
	case retrospectivereview.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetrospectiveReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetrospectiveReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetrospectiveReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, retrospectivereview.EdgeTenant)
	}
	if m.clearedretrospective {
		edges = append(edges, retrospectivereview.EdgeRetrospective)
	}
	if m.clearedrequester {
		edges = append(edges, retrospectivereview.EdgeRequester)
	}
	if m.clearedreviewer {
		edges = append(edges, retrospectivereview.EdgeReviewer)
	}
	if m.clearedcomment {
		edges = append(edges, retrospectivereview.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetrospectiveReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case retrospectivereview.EdgeTenant:
		return m.clearedtenant
	case retrospectivereview.EdgeRetrospective:
		return m.clearedretrospective
	case retrospectivereview.EdgeRequester:
		return m.clearedrequester
	case retrospectivereview.EdgeReviewer:
		return m.clearedreviewer
	case retrospectivereview.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetrospectiveReviewMutation) ClearEdge(name string) error {
	switch name {
	case retrospectivereview.EdgeTenant:
		m.ClearTenant()
		return nil
	case retrospectivereview.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	case retrospectivereview.EdgeRequester:
		m.ClearRequester()
		return nil
	case retrospectivereview.EdgeReviewer:
		m.ClearReviewer()
		return nil
	case retrospectivereview.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetrospectiveReviewMutation) ResetEdge(name string) error {
	switch name {
	case retrospectivereview.EdgeTenant:
		m.ResetTenant()
		return nil
	case retrospectivereview.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	case retrospectivereview.EdgeRequester:
		m.ResetRequester()
		return nil
	case retrospectivereview.EdgeReviewer:
		m.ResetReviewer()
		return nil
	case retrospectivereview.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown RetrospectiveReview edge %s", name)
}

// SystemAnalysisMutation represents an operation that mutates the SystemAnalysis nodes in the graph.
type SystemAnalysisMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	tenant                     *int
	clearedtenant              bool
	retrospective              *uuid.UUID
	clearedretrospective       bool
	components                 map[uuid.UUID]struct{}
	removedcomponents          map[uuid.UUID]struct{}
	clearedcomponents          bool
	relationships              map[uuid.UUID]struct{}
	removedrelationships       map[uuid.UUID]struct{}
	clearedrelationships       bool
	analysis_components        map[uuid.UUID]struct{}
	removedanalysis_components map[uuid.UUID]struct{}
	clearedanalysis_components bool
	done                       bool
	oldValue                   func(context.Context) (*SystemAnalysis, error)
	predicates                 []predicate.SystemAnalysis
}

var _ ent.Mutation = (*SystemAnalysisMutation)(nil)

// systemanalysisOption allows management of the mutation configuration using functional options.
type systemanalysisOption func(*SystemAnalysisMutation)

// newSystemAnalysisMutation creates new mutation for the SystemAnalysis entity.
func newSystemAnalysisMutation(c config, op Op, opts ...systemanalysisOption) *SystemAnalysisMutation {
	m := &SystemAnalysisMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemAnalysis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemAnalysisID sets the ID field of the mutation.
func withSystemAnalysisID(id uuid.UUID) systemanalysisOption {
	return func(m *SystemAnalysisMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemAnalysis
		)
		m.oldValue = func(ctx context.Context) (*SystemAnalysis, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemAnalysis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemAnalysis sets the old SystemAnalysis of the mutation.
func withSystemAnalysis(node *SystemAnalysis) systemanalysisOption {
	return func(m *SystemAnalysisMutation) {
		m.oldValue = func(context.Context) (*SystemAnalysis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemAnalysisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemAnalysisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemAnalysis entities.
func (m *SystemAnalysisMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemAnalysisMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemAnalysisMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemAnalysis.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemAnalysisMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemAnalysisMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemAnalysis entity.
// If the SystemAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemAnalysisMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemAnalysisMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemAnalysisMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemAnalysis entity.
// If the SystemAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemAnalysisMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemAnalysisMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemAnalysisMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemAnalysis entity.
// If the SystemAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemAnalysisMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemAnalysisMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemanalysis.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemAnalysisMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemAnalysisMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetRetrospectiveID sets the "retrospective" edge to the Retrospective entity by id.
func (m *SystemAnalysisMutation) SetRetrospectiveID(id uuid.UUID) {
	m.retrospective = &id
}

// ClearRetrospective clears the "retrospective" edge to the Retrospective entity.
func (m *SystemAnalysisMutation) ClearRetrospective() {
	m.clearedretrospective = true
}

// RetrospectiveCleared reports if the "retrospective" edge to the Retrospective entity was cleared.
func (m *SystemAnalysisMutation) RetrospectiveCleared() bool {
	return m.clearedretrospective
}

// RetrospectiveID returns the "retrospective" edge ID in the mutation.
func (m *SystemAnalysisMutation) RetrospectiveID() (id uuid.UUID, exists bool) {
	if m.retrospective != nil {
		return *m.retrospective, true
	}
	return
}

// RetrospectiveIDs returns the "retrospective" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetrospectiveID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisMutation) RetrospectiveIDs() (ids []uuid.UUID) {
	if id := m.retrospective; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetrospective resets all changes to the "retrospective" edge.
func (m *SystemAnalysisMutation) ResetRetrospective() {
	m.retrospective = nil
	m.clearedretrospective = false
}

// AddComponentIDs adds the "components" edge to the SystemComponent entity by ids.
func (m *SystemAnalysisMutation) AddComponentIDs(ids ...uuid.UUID) {
	if m.components == nil {
		m.components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the SystemComponent entity.
func (m *SystemAnalysisMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the SystemComponent entity was cleared.
func (m *SystemAnalysisMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the SystemComponent entity by IDs.
func (m *SystemAnalysisMutation) RemoveComponentIDs(ids ...uuid.UUID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the SystemComponent entity.
func (m *SystemAnalysisMutation) RemovedComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *SystemAnalysisMutation) ComponentsIDs() (ids []uuid.UUID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *SystemAnalysisMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddRelationshipIDs adds the "relationships" edge to the SystemAnalysisRelationship entity by ids.
func (m *SystemAnalysisMutation) AddRelationshipIDs(ids ...uuid.UUID) {
	if m.relationships == nil {
		m.relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.relationships[ids[i]] = struct{}{}
	}
}

// ClearRelationships clears the "relationships" edge to the SystemAnalysisRelationship entity.
func (m *SystemAnalysisMutation) ClearRelationships() {
	m.clearedrelationships = true
}

// RelationshipsCleared reports if the "relationships" edge to the SystemAnalysisRelationship entity was cleared.
func (m *SystemAnalysisMutation) RelationshipsCleared() bool {
	return m.clearedrelationships
}

// RemoveRelationshipIDs removes the "relationships" edge to the SystemAnalysisRelationship entity by IDs.
func (m *SystemAnalysisMutation) RemoveRelationshipIDs(ids ...uuid.UUID) {
	if m.removedrelationships == nil {
		m.removedrelationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.relationships, ids[i])
		m.removedrelationships[ids[i]] = struct{}{}
	}
}

// RemovedRelationships returns the removed IDs of the "relationships" edge to the SystemAnalysisRelationship entity.
func (m *SystemAnalysisMutation) RemovedRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedrelationships {
		ids = append(ids, id)
	}
	return
}

// RelationshipsIDs returns the "relationships" edge IDs in the mutation.
func (m *SystemAnalysisMutation) RelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.relationships {
		ids = append(ids, id)
	}
	return
}

// ResetRelationships resets all changes to the "relationships" edge.
func (m *SystemAnalysisMutation) ResetRelationships() {
	m.relationships = nil
	m.clearedrelationships = false
	m.removedrelationships = nil
}

// AddAnalysisComponentIDs adds the "analysis_components" edge to the SystemAnalysisComponent entity by ids.
func (m *SystemAnalysisMutation) AddAnalysisComponentIDs(ids ...uuid.UUID) {
	if m.analysis_components == nil {
		m.analysis_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.analysis_components[ids[i]] = struct{}{}
	}
}

// ClearAnalysisComponents clears the "analysis_components" edge to the SystemAnalysisComponent entity.
func (m *SystemAnalysisMutation) ClearAnalysisComponents() {
	m.clearedanalysis_components = true
}

// AnalysisComponentsCleared reports if the "analysis_components" edge to the SystemAnalysisComponent entity was cleared.
func (m *SystemAnalysisMutation) AnalysisComponentsCleared() bool {
	return m.clearedanalysis_components
}

// RemoveAnalysisComponentIDs removes the "analysis_components" edge to the SystemAnalysisComponent entity by IDs.
func (m *SystemAnalysisMutation) RemoveAnalysisComponentIDs(ids ...uuid.UUID) {
	if m.removedanalysis_components == nil {
		m.removedanalysis_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.analysis_components, ids[i])
		m.removedanalysis_components[ids[i]] = struct{}{}
	}
}

// RemovedAnalysisComponents returns the removed IDs of the "analysis_components" edge to the SystemAnalysisComponent entity.
func (m *SystemAnalysisMutation) RemovedAnalysisComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedanalysis_components {
		ids = append(ids, id)
	}
	return
}

// AnalysisComponentsIDs returns the "analysis_components" edge IDs in the mutation.
func (m *SystemAnalysisMutation) AnalysisComponentsIDs() (ids []uuid.UUID) {
	for id := range m.analysis_components {
		ids = append(ids, id)
	}
	return
}

// ResetAnalysisComponents resets all changes to the "analysis_components" edge.
func (m *SystemAnalysisMutation) ResetAnalysisComponents() {
	m.analysis_components = nil
	m.clearedanalysis_components = false
	m.removedanalysis_components = nil
}

// Where appends a list predicates to the SystemAnalysisMutation builder.
func (m *SystemAnalysisMutation) Where(ps ...predicate.SystemAnalysis) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemAnalysisMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemAnalysisMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemAnalysis, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemAnalysisMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemAnalysisMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemAnalysis).
func (m *SystemAnalysisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemAnalysisMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, systemanalysis.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, systemanalysis.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systemanalysis.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemAnalysisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemanalysis.FieldTenantID:
		return m.TenantID()
	case systemanalysis.FieldCreatedAt:
		return m.CreatedAt()
	case systemanalysis.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemAnalysisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemanalysis.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemanalysis.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemanalysis.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemAnalysis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemAnalysisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemanalysis.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemanalysis.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemanalysis.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemAnalysisMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemAnalysisMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemAnalysisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemAnalysis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemAnalysisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemAnalysisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemAnalysisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SystemAnalysis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemAnalysisMutation) ResetField(name string) error {
	switch name {
	case systemanalysis.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemanalysis.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemanalysis.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemAnalysisMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, systemanalysis.EdgeTenant)
	}
	if m.retrospective != nil {
		edges = append(edges, systemanalysis.EdgeRetrospective)
	}
	if m.components != nil {
		edges = append(edges, systemanalysis.EdgeComponents)
	}
	if m.relationships != nil {
		edges = append(edges, systemanalysis.EdgeRelationships)
	}
	if m.analysis_components != nil {
		edges = append(edges, systemanalysis.EdgeAnalysisComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemAnalysisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemanalysis.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemanalysis.EdgeRetrospective:
		if id := m.retrospective; id != nil {
			return []ent.Value{*id}
		}
	case systemanalysis.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case systemanalysis.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.relationships))
		for id := range m.relationships {
			ids = append(ids, id)
		}
		return ids
	case systemanalysis.EdgeAnalysisComponents:
		ids := make([]ent.Value, 0, len(m.analysis_components))
		for id := range m.analysis_components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemAnalysisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcomponents != nil {
		edges = append(edges, systemanalysis.EdgeComponents)
	}
	if m.removedrelationships != nil {
		edges = append(edges, systemanalysis.EdgeRelationships)
	}
	if m.removedanalysis_components != nil {
		edges = append(edges, systemanalysis.EdgeAnalysisComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemAnalysisMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemanalysis.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case systemanalysis.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.removedrelationships))
		for id := range m.removedrelationships {
			ids = append(ids, id)
		}
		return ids
	case systemanalysis.EdgeAnalysisComponents:
		ids := make([]ent.Value, 0, len(m.removedanalysis_components))
		for id := range m.removedanalysis_components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemAnalysisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, systemanalysis.EdgeTenant)
	}
	if m.clearedretrospective {
		edges = append(edges, systemanalysis.EdgeRetrospective)
	}
	if m.clearedcomponents {
		edges = append(edges, systemanalysis.EdgeComponents)
	}
	if m.clearedrelationships {
		edges = append(edges, systemanalysis.EdgeRelationships)
	}
	if m.clearedanalysis_components {
		edges = append(edges, systemanalysis.EdgeAnalysisComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemAnalysisMutation) EdgeCleared(name string) bool {
	switch name {
	case systemanalysis.EdgeTenant:
		return m.clearedtenant
	case systemanalysis.EdgeRetrospective:
		return m.clearedretrospective
	case systemanalysis.EdgeComponents:
		return m.clearedcomponents
	case systemanalysis.EdgeRelationships:
		return m.clearedrelationships
	case systemanalysis.EdgeAnalysisComponents:
		return m.clearedanalysis_components
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemAnalysisMutation) ClearEdge(name string) error {
	switch name {
	case systemanalysis.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemanalysis.EdgeRetrospective:
		m.ClearRetrospective()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemAnalysisMutation) ResetEdge(name string) error {
	switch name {
	case systemanalysis.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemanalysis.EdgeRetrospective:
		m.ResetRetrospective()
		return nil
	case systemanalysis.EdgeComponents:
		m.ResetComponents()
		return nil
	case systemanalysis.EdgeRelationships:
		m.ResetRelationships()
		return nil
	case systemanalysis.EdgeAnalysisComponents:
		m.ResetAnalysisComponents()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysis edge %s", name)
}

// SystemAnalysisComponentMutation represents an operation that mutates the SystemAnalysisComponent nodes in the graph.
type SystemAnalysisComponentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	description      *string
	pos_x            *float64
	addpos_x         *float64
	pos_y            *float64
	addpos_y         *float64
	created_at       *time.Time
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	analysis         *uuid.UUID
	clearedanalysis  bool
	component        *uuid.UUID
	clearedcomponent bool
	done             bool
	oldValue         func(context.Context) (*SystemAnalysisComponent, error)
	predicates       []predicate.SystemAnalysisComponent
}

var _ ent.Mutation = (*SystemAnalysisComponentMutation)(nil)

// systemanalysiscomponentOption allows management of the mutation configuration using functional options.
type systemanalysiscomponentOption func(*SystemAnalysisComponentMutation)

// newSystemAnalysisComponentMutation creates new mutation for the SystemAnalysisComponent entity.
func newSystemAnalysisComponentMutation(c config, op Op, opts ...systemanalysiscomponentOption) *SystemAnalysisComponentMutation {
	m := &SystemAnalysisComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemAnalysisComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemAnalysisComponentID sets the ID field of the mutation.
func withSystemAnalysisComponentID(id uuid.UUID) systemanalysiscomponentOption {
	return func(m *SystemAnalysisComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemAnalysisComponent
		)
		m.oldValue = func(ctx context.Context) (*SystemAnalysisComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemAnalysisComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemAnalysisComponent sets the old SystemAnalysisComponent of the mutation.
func withSystemAnalysisComponent(node *SystemAnalysisComponent) systemanalysiscomponentOption {
	return func(m *SystemAnalysisComponentMutation) {
		m.oldValue = func(context.Context) (*SystemAnalysisComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemAnalysisComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemAnalysisComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemAnalysisComponent entities.
func (m *SystemAnalysisComponentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemAnalysisComponentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemAnalysisComponentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemAnalysisComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemAnalysisComponentMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemAnalysisComponentMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemAnalysisComponent entity.
// If the SystemAnalysisComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisComponentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemAnalysisComponentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAnalysisID sets the "analysis_id" field.
func (m *SystemAnalysisComponentMutation) SetAnalysisID(u uuid.UUID) {
	m.analysis = &u
}

// AnalysisID returns the value of the "analysis_id" field in the mutation.
func (m *SystemAnalysisComponentMutation) AnalysisID() (r uuid.UUID, exists bool) {
	v := m.analysis
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalysisID returns the old "analysis_id" field's value of the SystemAnalysisComponent entity.
// If the SystemAnalysisComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisComponentMutation) OldAnalysisID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalysisID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalysisID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalysisID: %w", err)
	}
	return oldValue.AnalysisID, nil
}

// ResetAnalysisID resets all changes to the "analysis_id" field.
func (m *SystemAnalysisComponentMutation) ResetAnalysisID() {
	m.analysis = nil
}

// SetComponentID sets the "component_id" field.
func (m *SystemAnalysisComponentMutation) SetComponentID(u uuid.UUID) {
	m.component = &u
}

// ComponentID returns the value of the "component_id" field in the mutation.
func (m *SystemAnalysisComponentMutation) ComponentID() (r uuid.UUID, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentID returns the old "component_id" field's value of the SystemAnalysisComponent entity.
// If the SystemAnalysisComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisComponentMutation) OldComponentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentID: %w", err)
	}
	return oldValue.ComponentID, nil
}

// ResetComponentID resets all changes to the "component_id" field.
func (m *SystemAnalysisComponentMutation) ResetComponentID() {
	m.component = nil
}

// SetDescription sets the "description" field.
func (m *SystemAnalysisComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemAnalysisComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemAnalysisComponent entity.
// If the SystemAnalysisComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemAnalysisComponentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemanalysiscomponent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemAnalysisComponentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemanalysiscomponent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemAnalysisComponentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemanalysiscomponent.FieldDescription)
}

// SetPosX sets the "pos_x" field.
func (m *SystemAnalysisComponentMutation) SetPosX(f float64) {
	m.pos_x = &f
	m.addpos_x = nil
}

// PosX returns the value of the "pos_x" field in the mutation.
func (m *SystemAnalysisComponentMutation) PosX() (r float64, exists bool) {
	v := m.pos_x
	if v == nil {
		return
	}
	return *v, true
}

// OldPosX returns the old "pos_x" field's value of the SystemAnalysisComponent entity.
// If the SystemAnalysisComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisComponentMutation) OldPosX(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosX: %w", err)
	}
	return oldValue.PosX, nil
}

// AddPosX adds f to the "pos_x" field.
func (m *SystemAnalysisComponentMutation) AddPosX(f float64) {
	if m.addpos_x != nil {
		*m.addpos_x += f
	} else {
		m.addpos_x = &f
	}
}

// AddedPosX returns the value that was added to the "pos_x" field in this mutation.
func (m *SystemAnalysisComponentMutation) AddedPosX() (r float64, exists bool) {
	v := m.addpos_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosX resets all changes to the "pos_x" field.
func (m *SystemAnalysisComponentMutation) ResetPosX() {
	m.pos_x = nil
	m.addpos_x = nil
}

// SetPosY sets the "pos_y" field.
func (m *SystemAnalysisComponentMutation) SetPosY(f float64) {
	m.pos_y = &f
	m.addpos_y = nil
}

// PosY returns the value of the "pos_y" field in the mutation.
func (m *SystemAnalysisComponentMutation) PosY() (r float64, exists bool) {
	v := m.pos_y
	if v == nil {
		return
	}
	return *v, true
}

// OldPosY returns the old "pos_y" field's value of the SystemAnalysisComponent entity.
// If the SystemAnalysisComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisComponentMutation) OldPosY(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosY: %w", err)
	}
	return oldValue.PosY, nil
}

// AddPosY adds f to the "pos_y" field.
func (m *SystemAnalysisComponentMutation) AddPosY(f float64) {
	if m.addpos_y != nil {
		*m.addpos_y += f
	} else {
		m.addpos_y = &f
	}
}

// AddedPosY returns the value that was added to the "pos_y" field in this mutation.
func (m *SystemAnalysisComponentMutation) AddedPosY() (r float64, exists bool) {
	v := m.addpos_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosY resets all changes to the "pos_y" field.
func (m *SystemAnalysisComponentMutation) ResetPosY() {
	m.pos_y = nil
	m.addpos_y = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemAnalysisComponentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemAnalysisComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemAnalysisComponent entity.
// If the SystemAnalysisComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemAnalysisComponentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemAnalysisComponentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemanalysiscomponent.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemAnalysisComponentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisComponentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemAnalysisComponentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearAnalysis clears the "analysis" edge to the SystemAnalysis entity.
func (m *SystemAnalysisComponentMutation) ClearAnalysis() {
	m.clearedanalysis = true
	m.clearedFields[systemanalysiscomponent.FieldAnalysisID] = struct{}{}
}

// AnalysisCleared reports if the "analysis" edge to the SystemAnalysis entity was cleared.
func (m *SystemAnalysisComponentMutation) AnalysisCleared() bool {
	return m.clearedanalysis
}

// AnalysisIDs returns the "analysis" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AnalysisID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisComponentMutation) AnalysisIDs() (ids []uuid.UUID) {
	if id := m.analysis; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAnalysis resets all changes to the "analysis" edge.
func (m *SystemAnalysisComponentMutation) ResetAnalysis() {
	m.analysis = nil
	m.clearedanalysis = false
}

// ClearComponent clears the "component" edge to the SystemComponent entity.
func (m *SystemAnalysisComponentMutation) ClearComponent() {
	m.clearedcomponent = true
	m.clearedFields[systemanalysiscomponent.FieldComponentID] = struct{}{}
}

// ComponentCleared reports if the "component" edge to the SystemComponent entity was cleared.
func (m *SystemAnalysisComponentMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisComponentMutation) ComponentIDs() (ids []uuid.UUID) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *SystemAnalysisComponentMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// Where appends a list predicates to the SystemAnalysisComponentMutation builder.
func (m *SystemAnalysisComponentMutation) Where(ps ...predicate.SystemAnalysisComponent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemAnalysisComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemAnalysisComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemAnalysisComponent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemAnalysisComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemAnalysisComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemAnalysisComponent).
func (m *SystemAnalysisComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemAnalysisComponentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, systemanalysiscomponent.FieldTenantID)
	}
	if m.analysis != nil {
		fields = append(fields, systemanalysiscomponent.FieldAnalysisID)
	}
	if m.component != nil {
		fields = append(fields, systemanalysiscomponent.FieldComponentID)
	}
	if m.description != nil {
		fields = append(fields, systemanalysiscomponent.FieldDescription)
	}
	if m.pos_x != nil {
		fields = append(fields, systemanalysiscomponent.FieldPosX)
	}
	if m.pos_y != nil {
		fields = append(fields, systemanalysiscomponent.FieldPosY)
	}
	if m.created_at != nil {
		fields = append(fields, systemanalysiscomponent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemAnalysisComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemanalysiscomponent.FieldTenantID:
		return m.TenantID()
	case systemanalysiscomponent.FieldAnalysisID:
		return m.AnalysisID()
	case systemanalysiscomponent.FieldComponentID:
		return m.ComponentID()
	case systemanalysiscomponent.FieldDescription:
		return m.Description()
	case systemanalysiscomponent.FieldPosX:
		return m.PosX()
	case systemanalysiscomponent.FieldPosY:
		return m.PosY()
	case systemanalysiscomponent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemAnalysisComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemanalysiscomponent.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemanalysiscomponent.FieldAnalysisID:
		return m.OldAnalysisID(ctx)
	case systemanalysiscomponent.FieldComponentID:
		return m.OldComponentID(ctx)
	case systemanalysiscomponent.FieldDescription:
		return m.OldDescription(ctx)
	case systemanalysiscomponent.FieldPosX:
		return m.OldPosX(ctx)
	case systemanalysiscomponent.FieldPosY:
		return m.OldPosY(ctx)
	case systemanalysiscomponent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemAnalysisComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemAnalysisComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemanalysiscomponent.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemanalysiscomponent.FieldAnalysisID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalysisID(v)
		return nil
	case systemanalysiscomponent.FieldComponentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentID(v)
		return nil
	case systemanalysiscomponent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemanalysiscomponent.FieldPosX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosX(v)
		return nil
	case systemanalysiscomponent.FieldPosY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosY(v)
		return nil
	case systemanalysiscomponent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemAnalysisComponentMutation) AddedFields() []string {
	var fields []string
	if m.addpos_x != nil {
		fields = append(fields, systemanalysiscomponent.FieldPosX)
	}
	if m.addpos_y != nil {
		fields = append(fields, systemanalysiscomponent.FieldPosY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemAnalysisComponentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemanalysiscomponent.FieldPosX:
		return m.AddedPosX()
	case systemanalysiscomponent.FieldPosY:
		return m.AddedPosY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemAnalysisComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemanalysiscomponent.FieldPosX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosX(v)
		return nil
	case systemanalysiscomponent.FieldPosY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosY(v)
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemAnalysisComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemanalysiscomponent.FieldDescription) {
		fields = append(fields, systemanalysiscomponent.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemAnalysisComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemAnalysisComponentMutation) ClearField(name string) error {
	switch name {
	case systemanalysiscomponent.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemAnalysisComponentMutation) ResetField(name string) error {
	switch name {
	case systemanalysiscomponent.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemanalysiscomponent.FieldAnalysisID:
		m.ResetAnalysisID()
		return nil
	case systemanalysiscomponent.FieldComponentID:
		m.ResetComponentID()
		return nil
	case systemanalysiscomponent.FieldDescription:
		m.ResetDescription()
		return nil
	case systemanalysiscomponent.FieldPosX:
		m.ResetPosX()
		return nil
	case systemanalysiscomponent.FieldPosY:
		m.ResetPosY()
		return nil
	case systemanalysiscomponent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemAnalysisComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, systemanalysiscomponent.EdgeTenant)
	}
	if m.analysis != nil {
		edges = append(edges, systemanalysiscomponent.EdgeAnalysis)
	}
	if m.component != nil {
		edges = append(edges, systemanalysiscomponent.EdgeComponent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemAnalysisComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemanalysiscomponent.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemanalysiscomponent.EdgeAnalysis:
		if id := m.analysis; id != nil {
			return []ent.Value{*id}
		}
	case systemanalysiscomponent.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemAnalysisComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemAnalysisComponentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemAnalysisComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, systemanalysiscomponent.EdgeTenant)
	}
	if m.clearedanalysis {
		edges = append(edges, systemanalysiscomponent.EdgeAnalysis)
	}
	if m.clearedcomponent {
		edges = append(edges, systemanalysiscomponent.EdgeComponent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemAnalysisComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case systemanalysiscomponent.EdgeTenant:
		return m.clearedtenant
	case systemanalysiscomponent.EdgeAnalysis:
		return m.clearedanalysis
	case systemanalysiscomponent.EdgeComponent:
		return m.clearedcomponent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemAnalysisComponentMutation) ClearEdge(name string) error {
	switch name {
	case systemanalysiscomponent.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemanalysiscomponent.EdgeAnalysis:
		m.ClearAnalysis()
		return nil
	case systemanalysiscomponent.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemAnalysisComponentMutation) ResetEdge(name string) error {
	switch name {
	case systemanalysiscomponent.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemanalysiscomponent.EdgeAnalysis:
		m.ResetAnalysis()
		return nil
	case systemanalysiscomponent.EdgeComponent:
		m.ResetComponent()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisComponent edge %s", name)
}

// SystemAnalysisRelationshipMutation represents an operation that mutates the SystemAnalysisRelationship nodes in the graph.
type SystemAnalysisRelationshipMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	description            *string
	created_at             *time.Time
	clearedFields          map[string]struct{}
	tenant                 *int
	clearedtenant          bool
	system_analysis        *uuid.UUID
	clearedsystem_analysis bool
	relationship           *uuid.UUID
	clearedrelationship    bool
	done                   bool
	oldValue               func(context.Context) (*SystemAnalysisRelationship, error)
	predicates             []predicate.SystemAnalysisRelationship
}

var _ ent.Mutation = (*SystemAnalysisRelationshipMutation)(nil)

// systemanalysisrelationshipOption allows management of the mutation configuration using functional options.
type systemanalysisrelationshipOption func(*SystemAnalysisRelationshipMutation)

// newSystemAnalysisRelationshipMutation creates new mutation for the SystemAnalysisRelationship entity.
func newSystemAnalysisRelationshipMutation(c config, op Op, opts ...systemanalysisrelationshipOption) *SystemAnalysisRelationshipMutation {
	m := &SystemAnalysisRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemAnalysisRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemAnalysisRelationshipID sets the ID field of the mutation.
func withSystemAnalysisRelationshipID(id uuid.UUID) systemanalysisrelationshipOption {
	return func(m *SystemAnalysisRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemAnalysisRelationship
		)
		m.oldValue = func(ctx context.Context) (*SystemAnalysisRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemAnalysisRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemAnalysisRelationship sets the old SystemAnalysisRelationship of the mutation.
func withSystemAnalysisRelationship(node *SystemAnalysisRelationship) systemanalysisrelationshipOption {
	return func(m *SystemAnalysisRelationshipMutation) {
		m.oldValue = func(context.Context) (*SystemAnalysisRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemAnalysisRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemAnalysisRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemAnalysisRelationship entities.
func (m *SystemAnalysisRelationshipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemAnalysisRelationshipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemAnalysisRelationshipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemAnalysisRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemAnalysisRelationshipMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemAnalysisRelationshipMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemAnalysisRelationship entity.
// If the SystemAnalysisRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisRelationshipMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemAnalysisRelationshipMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAnalysisID sets the "analysis_id" field.
func (m *SystemAnalysisRelationshipMutation) SetAnalysisID(u uuid.UUID) {
	m.system_analysis = &u
}

// AnalysisID returns the value of the "analysis_id" field in the mutation.
func (m *SystemAnalysisRelationshipMutation) AnalysisID() (r uuid.UUID, exists bool) {
	v := m.system_analysis
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalysisID returns the old "analysis_id" field's value of the SystemAnalysisRelationship entity.
// If the SystemAnalysisRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisRelationshipMutation) OldAnalysisID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalysisID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalysisID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalysisID: %w", err)
	}
	return oldValue.AnalysisID, nil
}

// ResetAnalysisID resets all changes to the "analysis_id" field.
func (m *SystemAnalysisRelationshipMutation) ResetAnalysisID() {
	m.system_analysis = nil
}

// SetRelationshipID sets the "relationship_id" field.
func (m *SystemAnalysisRelationshipMutation) SetRelationshipID(u uuid.UUID) {
	m.relationship = &u
}

// RelationshipID returns the value of the "relationship_id" field in the mutation.
func (m *SystemAnalysisRelationshipMutation) RelationshipID() (r uuid.UUID, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipID returns the old "relationship_id" field's value of the SystemAnalysisRelationship entity.
// If the SystemAnalysisRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisRelationshipMutation) OldRelationshipID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipID: %w", err)
	}
	return oldValue.RelationshipID, nil
}

// ResetRelationshipID resets all changes to the "relationship_id" field.
func (m *SystemAnalysisRelationshipMutation) ResetRelationshipID() {
	m.relationship = nil
}

// SetDescription sets the "description" field.
func (m *SystemAnalysisRelationshipMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemAnalysisRelationshipMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemAnalysisRelationship entity.
// If the SystemAnalysisRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisRelationshipMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemAnalysisRelationshipMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemanalysisrelationship.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemAnalysisRelationshipMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemanalysisrelationship.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemAnalysisRelationshipMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemanalysisrelationship.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemAnalysisRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemAnalysisRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemAnalysisRelationship entity.
// If the SystemAnalysisRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemAnalysisRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemAnalysisRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemAnalysisRelationshipMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemanalysisrelationship.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemAnalysisRelationshipMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisRelationshipMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemAnalysisRelationshipMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetSystemAnalysisID sets the "system_analysis" edge to the SystemAnalysis entity by id.
func (m *SystemAnalysisRelationshipMutation) SetSystemAnalysisID(id uuid.UUID) {
	m.system_analysis = &id
}

// ClearSystemAnalysis clears the "system_analysis" edge to the SystemAnalysis entity.
func (m *SystemAnalysisRelationshipMutation) ClearSystemAnalysis() {
	m.clearedsystem_analysis = true
	m.clearedFields[systemanalysisrelationship.FieldAnalysisID] = struct{}{}
}

// SystemAnalysisCleared reports if the "system_analysis" edge to the SystemAnalysis entity was cleared.
func (m *SystemAnalysisRelationshipMutation) SystemAnalysisCleared() bool {
	return m.clearedsystem_analysis
}

// SystemAnalysisID returns the "system_analysis" edge ID in the mutation.
func (m *SystemAnalysisRelationshipMutation) SystemAnalysisID() (id uuid.UUID, exists bool) {
	if m.system_analysis != nil {
		return *m.system_analysis, true
	}
	return
}

// SystemAnalysisIDs returns the "system_analysis" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SystemAnalysisID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisRelationshipMutation) SystemAnalysisIDs() (ids []uuid.UUID) {
	if id := m.system_analysis; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSystemAnalysis resets all changes to the "system_analysis" edge.
func (m *SystemAnalysisRelationshipMutation) ResetSystemAnalysis() {
	m.system_analysis = nil
	m.clearedsystem_analysis = false
}

// ClearRelationship clears the "relationship" edge to the SystemComponentRelationship entity.
func (m *SystemAnalysisRelationshipMutation) ClearRelationship() {
	m.clearedrelationship = true
	m.clearedFields[systemanalysisrelationship.FieldRelationshipID] = struct{}{}
}

// RelationshipCleared reports if the "relationship" edge to the SystemComponentRelationship entity was cleared.
func (m *SystemAnalysisRelationshipMutation) RelationshipCleared() bool {
	return m.clearedrelationship
}

// RelationshipIDs returns the "relationship" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RelationshipID instead. It exists only for internal usage by the builders.
func (m *SystemAnalysisRelationshipMutation) RelationshipIDs() (ids []uuid.UUID) {
	if id := m.relationship; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelationship resets all changes to the "relationship" edge.
func (m *SystemAnalysisRelationshipMutation) ResetRelationship() {
	m.relationship = nil
	m.clearedrelationship = false
}

// Where appends a list predicates to the SystemAnalysisRelationshipMutation builder.
func (m *SystemAnalysisRelationshipMutation) Where(ps ...predicate.SystemAnalysisRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemAnalysisRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemAnalysisRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemAnalysisRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemAnalysisRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemAnalysisRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemAnalysisRelationship).
func (m *SystemAnalysisRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemAnalysisRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, systemanalysisrelationship.FieldTenantID)
	}
	if m.system_analysis != nil {
		fields = append(fields, systemanalysisrelationship.FieldAnalysisID)
	}
	if m.relationship != nil {
		fields = append(fields, systemanalysisrelationship.FieldRelationshipID)
	}
	if m.description != nil {
		fields = append(fields, systemanalysisrelationship.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemanalysisrelationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemAnalysisRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemanalysisrelationship.FieldTenantID:
		return m.TenantID()
	case systemanalysisrelationship.FieldAnalysisID:
		return m.AnalysisID()
	case systemanalysisrelationship.FieldRelationshipID:
		return m.RelationshipID()
	case systemanalysisrelationship.FieldDescription:
		return m.Description()
	case systemanalysisrelationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemAnalysisRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemanalysisrelationship.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemanalysisrelationship.FieldAnalysisID:
		return m.OldAnalysisID(ctx)
	case systemanalysisrelationship.FieldRelationshipID:
		return m.OldRelationshipID(ctx)
	case systemanalysisrelationship.FieldDescription:
		return m.OldDescription(ctx)
	case systemanalysisrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemAnalysisRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemAnalysisRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemanalysisrelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemanalysisrelationship.FieldAnalysisID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalysisID(v)
		return nil
	case systemanalysisrelationship.FieldRelationshipID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipID(v)
		return nil
	case systemanalysisrelationship.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemanalysisrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemAnalysisRelationshipMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemAnalysisRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemAnalysisRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemAnalysisRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemAnalysisRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemanalysisrelationship.FieldDescription) {
		fields = append(fields, systemanalysisrelationship.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemAnalysisRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemAnalysisRelationshipMutation) ClearField(name string) error {
	switch name {
	case systemanalysisrelationship.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemAnalysisRelationshipMutation) ResetField(name string) error {
	switch name {
	case systemanalysisrelationship.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemanalysisrelationship.FieldAnalysisID:
		m.ResetAnalysisID()
		return nil
	case systemanalysisrelationship.FieldRelationshipID:
		m.ResetRelationshipID()
		return nil
	case systemanalysisrelationship.FieldDescription:
		m.ResetDescription()
		return nil
	case systemanalysisrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemAnalysisRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, systemanalysisrelationship.EdgeTenant)
	}
	if m.system_analysis != nil {
		edges = append(edges, systemanalysisrelationship.EdgeSystemAnalysis)
	}
	if m.relationship != nil {
		edges = append(edges, systemanalysisrelationship.EdgeRelationship)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemAnalysisRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemanalysisrelationship.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemanalysisrelationship.EdgeSystemAnalysis:
		if id := m.system_analysis; id != nil {
			return []ent.Value{*id}
		}
	case systemanalysisrelationship.EdgeRelationship:
		if id := m.relationship; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemAnalysisRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemAnalysisRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemAnalysisRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, systemanalysisrelationship.EdgeTenant)
	}
	if m.clearedsystem_analysis {
		edges = append(edges, systemanalysisrelationship.EdgeSystemAnalysis)
	}
	if m.clearedrelationship {
		edges = append(edges, systemanalysisrelationship.EdgeRelationship)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemAnalysisRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case systemanalysisrelationship.EdgeTenant:
		return m.clearedtenant
	case systemanalysisrelationship.EdgeSystemAnalysis:
		return m.clearedsystem_analysis
	case systemanalysisrelationship.EdgeRelationship:
		return m.clearedrelationship
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemAnalysisRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case systemanalysisrelationship.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemanalysisrelationship.EdgeSystemAnalysis:
		m.ClearSystemAnalysis()
		return nil
	case systemanalysisrelationship.EdgeRelationship:
		m.ClearRelationship()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemAnalysisRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case systemanalysisrelationship.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemanalysisrelationship.EdgeSystemAnalysis:
		m.ResetSystemAnalysis()
		return nil
	case systemanalysisrelationship.EdgeRelationship:
		m.ResetRelationship()
		return nil
	}
	return fmt.Errorf("unknown SystemAnalysisRelationship edge %s", name)
}

// SystemComponentMutation represents an operation that mutates the SystemComponent nodes in the graph.
type SystemComponentMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	external_id                       *string
	name                              *string
	description                       *string
	properties                        *map[string]interface{}
	created_at                        *time.Time
	updated_at                        *time.Time
	clearedFields                     map[string]struct{}
	tenant                            *int
	clearedtenant                     bool
	kind                              *uuid.UUID
	clearedkind                       bool
	related                           map[uuid.UUID]struct{}
	removedrelated                    map[uuid.UUID]struct{}
	clearedrelated                    bool
	system_analyses                   map[uuid.UUID]struct{}
	removedsystem_analyses            map[uuid.UUID]struct{}
	clearedsystem_analyses            bool
	events                            map[uuid.UUID]struct{}
	removedevents                     map[uuid.UUID]struct{}
	clearedevents                     bool
	constraints                       map[uuid.UUID]struct{}
	removedconstraints                map[uuid.UUID]struct{}
	clearedconstraints                bool
	controls                          map[uuid.UUID]struct{}
	removedcontrols                   map[uuid.UUID]struct{}
	clearedcontrols                   bool
	signals                           map[uuid.UUID]struct{}
	removedsignals                    map[uuid.UUID]struct{}
	clearedsignals                    bool
	hazards                           map[uuid.UUID]struct{}
	removedhazards                    map[uuid.UUID]struct{}
	clearedhazards                    bool
	component_relationships           map[uuid.UUID]struct{}
	removedcomponent_relationships    map[uuid.UUID]struct{}
	clearedcomponent_relationships    bool
	system_analysis_components        map[uuid.UUID]struct{}
	removedsystem_analysis_components map[uuid.UUID]struct{}
	clearedsystem_analysis_components bool
	event_components                  map[uuid.UUID]struct{}
	removedevent_components           map[uuid.UUID]struct{}
	clearedevent_components           bool
	done                              bool
	oldValue                          func(context.Context) (*SystemComponent, error)
	predicates                        []predicate.SystemComponent
}

var _ ent.Mutation = (*SystemComponentMutation)(nil)

// systemcomponentOption allows management of the mutation configuration using functional options.
type systemcomponentOption func(*SystemComponentMutation)

// newSystemComponentMutation creates new mutation for the SystemComponent entity.
func newSystemComponentMutation(c config, op Op, opts ...systemcomponentOption) *SystemComponentMutation {
	m := &SystemComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentID sets the ID field of the mutation.
func withSystemComponentID(id uuid.UUID) systemcomponentOption {
	return func(m *SystemComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponent
		)
		m.oldValue = func(ctx context.Context) (*SystemComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponent sets the old SystemComponent of the mutation.
func withSystemComponent(node *SystemComponent) systemcomponentOption {
	return func(m *SystemComponentMutation) {
		m.oldValue = func(context.Context) (*SystemComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponent entities.
func (m *SystemComponentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemComponentMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemComponentMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemComponentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *SystemComponentMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SystemComponentMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *SystemComponentMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[systemcomponent.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *SystemComponentMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[systemcomponent.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SystemComponentMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, systemcomponent.FieldExternalID)
}

// SetName sets the "name" field.
func (m *SystemComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemComponentMutation) ResetName() {
	m.name = nil
}

// SetKindID sets the "kind_id" field.
func (m *SystemComponentMutation) SetKindID(u uuid.UUID) {
	m.kind = &u
}

// KindID returns the value of the "kind_id" field in the mutation.
func (m *SystemComponentMutation) KindID() (r uuid.UUID, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKindID returns the old "kind_id" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldKindID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKindID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKindID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKindID: %w", err)
	}
	return oldValue.KindID, nil
}

// ResetKindID resets all changes to the "kind_id" field.
func (m *SystemComponentMutation) ResetKindID() {
	m.kind = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponent.FieldDescription)
}

// SetProperties sets the "properties" field.
func (m *SystemComponentMutation) SetProperties(value map[string]interface{}) {
	m.properties = &value
}

// Properties returns the value of the "properties" field in the mutation.
func (m *SystemComponentMutation) Properties() (r map[string]interface{}, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// ClearProperties clears the value of the "properties" field.
func (m *SystemComponentMutation) ClearProperties() {
	m.properties = nil
	m.clearedFields[systemcomponent.FieldProperties] = struct{}{}
}

// PropertiesCleared returns if the "properties" field was cleared in this mutation.
func (m *SystemComponentMutation) PropertiesCleared() bool {
	_, ok := m.clearedFields[systemcomponent.FieldProperties]
	return ok
}

// ResetProperties resets all changes to the "properties" field.
func (m *SystemComponentMutation) ResetProperties() {
	m.properties = nil
	delete(m.clearedFields, systemcomponent.FieldProperties)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemComponentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemComponentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemComponent entity.
// If the SystemComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemComponentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemComponentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemcomponent.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemComponentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemComponentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemComponentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearKind clears the "kind" edge to the SystemComponentKind entity.
func (m *SystemComponentMutation) ClearKind() {
	m.clearedkind = true
	m.clearedFields[systemcomponent.FieldKindID] = struct{}{}
}

// KindCleared reports if the "kind" edge to the SystemComponentKind entity was cleared.
func (m *SystemComponentMutation) KindCleared() bool {
	return m.clearedkind
}

// KindIDs returns the "kind" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KindID instead. It exists only for internal usage by the builders.
func (m *SystemComponentMutation) KindIDs() (ids []uuid.UUID) {
	if id := m.kind; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKind resets all changes to the "kind" edge.
func (m *SystemComponentMutation) ResetKind() {
	m.kind = nil
	m.clearedkind = false
}

// AddRelatedIDs adds the "related" edge to the SystemComponent entity by ids.
func (m *SystemComponentMutation) AddRelatedIDs(ids ...uuid.UUID) {
	if m.related == nil {
		m.related = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.related[ids[i]] = struct{}{}
	}
}

// ClearRelated clears the "related" edge to the SystemComponent entity.
func (m *SystemComponentMutation) ClearRelated() {
	m.clearedrelated = true
}

// RelatedCleared reports if the "related" edge to the SystemComponent entity was cleared.
func (m *SystemComponentMutation) RelatedCleared() bool {
	return m.clearedrelated
}

// RemoveRelatedIDs removes the "related" edge to the SystemComponent entity by IDs.
func (m *SystemComponentMutation) RemoveRelatedIDs(ids ...uuid.UUID) {
	if m.removedrelated == nil {
		m.removedrelated = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.related, ids[i])
		m.removedrelated[ids[i]] = struct{}{}
	}
}

// RemovedRelated returns the removed IDs of the "related" edge to the SystemComponent entity.
func (m *SystemComponentMutation) RemovedRelatedIDs() (ids []uuid.UUID) {
	for id := range m.removedrelated {
		ids = append(ids, id)
	}
	return
}

// RelatedIDs returns the "related" edge IDs in the mutation.
func (m *SystemComponentMutation) RelatedIDs() (ids []uuid.UUID) {
	for id := range m.related {
		ids = append(ids, id)
	}
	return
}

// ResetRelated resets all changes to the "related" edge.
func (m *SystemComponentMutation) ResetRelated() {
	m.related = nil
	m.clearedrelated = false
	m.removedrelated = nil
}

// AddSystemAnalysisIDs adds the "system_analyses" edge to the SystemAnalysis entity by ids.
func (m *SystemComponentMutation) AddSystemAnalysisIDs(ids ...uuid.UUID) {
	if m.system_analyses == nil {
		m.system_analyses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.system_analyses[ids[i]] = struct{}{}
	}
}

// ClearSystemAnalyses clears the "system_analyses" edge to the SystemAnalysis entity.
func (m *SystemComponentMutation) ClearSystemAnalyses() {
	m.clearedsystem_analyses = true
}

// SystemAnalysesCleared reports if the "system_analyses" edge to the SystemAnalysis entity was cleared.
func (m *SystemComponentMutation) SystemAnalysesCleared() bool {
	return m.clearedsystem_analyses
}

// RemoveSystemAnalysisIDs removes the "system_analyses" edge to the SystemAnalysis entity by IDs.
func (m *SystemComponentMutation) RemoveSystemAnalysisIDs(ids ...uuid.UUID) {
	if m.removedsystem_analyses == nil {
		m.removedsystem_analyses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.system_analyses, ids[i])
		m.removedsystem_analyses[ids[i]] = struct{}{}
	}
}

// RemovedSystemAnalyses returns the removed IDs of the "system_analyses" edge to the SystemAnalysis entity.
func (m *SystemComponentMutation) RemovedSystemAnalysesIDs() (ids []uuid.UUID) {
	for id := range m.removedsystem_analyses {
		ids = append(ids, id)
	}
	return
}

// SystemAnalysesIDs returns the "system_analyses" edge IDs in the mutation.
func (m *SystemComponentMutation) SystemAnalysesIDs() (ids []uuid.UUID) {
	for id := range m.system_analyses {
		ids = append(ids, id)
	}
	return
}

// ResetSystemAnalyses resets all changes to the "system_analyses" edge.
func (m *SystemComponentMutation) ResetSystemAnalyses() {
	m.system_analyses = nil
	m.clearedsystem_analyses = false
	m.removedsystem_analyses = nil
}

// AddEventIDs adds the "events" edge to the IncidentEvent entity by ids.
func (m *SystemComponentMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the IncidentEvent entity.
func (m *SystemComponentMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the IncidentEvent entity was cleared.
func (m *SystemComponentMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the IncidentEvent entity by IDs.
func (m *SystemComponentMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the IncidentEvent entity.
func (m *SystemComponentMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *SystemComponentMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *SystemComponentMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddConstraintIDs adds the "constraints" edge to the SystemComponentConstraint entity by ids.
func (m *SystemComponentMutation) AddConstraintIDs(ids ...uuid.UUID) {
	if m.constraints == nil {
		m.constraints = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.constraints[ids[i]] = struct{}{}
	}
}

// ClearConstraints clears the "constraints" edge to the SystemComponentConstraint entity.
func (m *SystemComponentMutation) ClearConstraints() {
	m.clearedconstraints = true
}

// ConstraintsCleared reports if the "constraints" edge to the SystemComponentConstraint entity was cleared.
func (m *SystemComponentMutation) ConstraintsCleared() bool {
	return m.clearedconstraints
}

// RemoveConstraintIDs removes the "constraints" edge to the SystemComponentConstraint entity by IDs.
func (m *SystemComponentMutation) RemoveConstraintIDs(ids ...uuid.UUID) {
	if m.removedconstraints == nil {
		m.removedconstraints = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.constraints, ids[i])
		m.removedconstraints[ids[i]] = struct{}{}
	}
}

// RemovedConstraints returns the removed IDs of the "constraints" edge to the SystemComponentConstraint entity.
func (m *SystemComponentMutation) RemovedConstraintsIDs() (ids []uuid.UUID) {
	for id := range m.removedconstraints {
		ids = append(ids, id)
	}
	return
}

// ConstraintsIDs returns the "constraints" edge IDs in the mutation.
func (m *SystemComponentMutation) ConstraintsIDs() (ids []uuid.UUID) {
	for id := range m.constraints {
		ids = append(ids, id)
	}
	return
}

// ResetConstraints resets all changes to the "constraints" edge.
func (m *SystemComponentMutation) ResetConstraints() {
	m.constraints = nil
	m.clearedconstraints = false
	m.removedconstraints = nil
}

// AddControlIDs adds the "controls" edge to the SystemComponentControl entity by ids.
func (m *SystemComponentMutation) AddControlIDs(ids ...uuid.UUID) {
	if m.controls == nil {
		m.controls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.controls[ids[i]] = struct{}{}
	}
}

// ClearControls clears the "controls" edge to the SystemComponentControl entity.
func (m *SystemComponentMutation) ClearControls() {
	m.clearedcontrols = true
}

// ControlsCleared reports if the "controls" edge to the SystemComponentControl entity was cleared.
func (m *SystemComponentMutation) ControlsCleared() bool {
	return m.clearedcontrols
}

// RemoveControlIDs removes the "controls" edge to the SystemComponentControl entity by IDs.
func (m *SystemComponentMutation) RemoveControlIDs(ids ...uuid.UUID) {
	if m.removedcontrols == nil {
		m.removedcontrols = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.controls, ids[i])
		m.removedcontrols[ids[i]] = struct{}{}
	}
}

// RemovedControls returns the removed IDs of the "controls" edge to the SystemComponentControl entity.
func (m *SystemComponentMutation) RemovedControlsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontrols {
		ids = append(ids, id)
	}
	return
}

// ControlsIDs returns the "controls" edge IDs in the mutation.
func (m *SystemComponentMutation) ControlsIDs() (ids []uuid.UUID) {
	for id := range m.controls {
		ids = append(ids, id)
	}
	return
}

// ResetControls resets all changes to the "controls" edge.
func (m *SystemComponentMutation) ResetControls() {
	m.controls = nil
	m.clearedcontrols = false
	m.removedcontrols = nil
}

// AddSignalIDs adds the "signals" edge to the SystemComponentSignal entity by ids.
func (m *SystemComponentMutation) AddSignalIDs(ids ...uuid.UUID) {
	if m.signals == nil {
		m.signals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.signals[ids[i]] = struct{}{}
	}
}

// ClearSignals clears the "signals" edge to the SystemComponentSignal entity.
func (m *SystemComponentMutation) ClearSignals() {
	m.clearedsignals = true
}

// SignalsCleared reports if the "signals" edge to the SystemComponentSignal entity was cleared.
func (m *SystemComponentMutation) SignalsCleared() bool {
	return m.clearedsignals
}

// RemoveSignalIDs removes the "signals" edge to the SystemComponentSignal entity by IDs.
func (m *SystemComponentMutation) RemoveSignalIDs(ids ...uuid.UUID) {
	if m.removedsignals == nil {
		m.removedsignals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.signals, ids[i])
		m.removedsignals[ids[i]] = struct{}{}
	}
}

// RemovedSignals returns the removed IDs of the "signals" edge to the SystemComponentSignal entity.
func (m *SystemComponentMutation) RemovedSignalsIDs() (ids []uuid.UUID) {
	for id := range m.removedsignals {
		ids = append(ids, id)
	}
	return
}

// SignalsIDs returns the "signals" edge IDs in the mutation.
func (m *SystemComponentMutation) SignalsIDs() (ids []uuid.UUID) {
	for id := range m.signals {
		ids = append(ids, id)
	}
	return
}

// ResetSignals resets all changes to the "signals" edge.
func (m *SystemComponentMutation) ResetSignals() {
	m.signals = nil
	m.clearedsignals = false
	m.removedsignals = nil
}

// AddHazardIDs adds the "hazards" edge to the SystemHazard entity by ids.
func (m *SystemComponentMutation) AddHazardIDs(ids ...uuid.UUID) {
	if m.hazards == nil {
		m.hazards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hazards[ids[i]] = struct{}{}
	}
}

// ClearHazards clears the "hazards" edge to the SystemHazard entity.
func (m *SystemComponentMutation) ClearHazards() {
	m.clearedhazards = true
}

// HazardsCleared reports if the "hazards" edge to the SystemHazard entity was cleared.
func (m *SystemComponentMutation) HazardsCleared() bool {
	return m.clearedhazards
}

// RemoveHazardIDs removes the "hazards" edge to the SystemHazard entity by IDs.
func (m *SystemComponentMutation) RemoveHazardIDs(ids ...uuid.UUID) {
	if m.removedhazards == nil {
		m.removedhazards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hazards, ids[i])
		m.removedhazards[ids[i]] = struct{}{}
	}
}

// RemovedHazards returns the removed IDs of the "hazards" edge to the SystemHazard entity.
func (m *SystemComponentMutation) RemovedHazardsIDs() (ids []uuid.UUID) {
	for id := range m.removedhazards {
		ids = append(ids, id)
	}
	return
}

// HazardsIDs returns the "hazards" edge IDs in the mutation.
func (m *SystemComponentMutation) HazardsIDs() (ids []uuid.UUID) {
	for id := range m.hazards {
		ids = append(ids, id)
	}
	return
}

// ResetHazards resets all changes to the "hazards" edge.
func (m *SystemComponentMutation) ResetHazards() {
	m.hazards = nil
	m.clearedhazards = false
	m.removedhazards = nil
}

// AddComponentRelationshipIDs adds the "component_relationships" edge to the SystemComponentRelationship entity by ids.
func (m *SystemComponentMutation) AddComponentRelationshipIDs(ids ...uuid.UUID) {
	if m.component_relationships == nil {
		m.component_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.component_relationships[ids[i]] = struct{}{}
	}
}

// ClearComponentRelationships clears the "component_relationships" edge to the SystemComponentRelationship entity.
func (m *SystemComponentMutation) ClearComponentRelationships() {
	m.clearedcomponent_relationships = true
}

// ComponentRelationshipsCleared reports if the "component_relationships" edge to the SystemComponentRelationship entity was cleared.
func (m *SystemComponentMutation) ComponentRelationshipsCleared() bool {
	return m.clearedcomponent_relationships
}

// RemoveComponentRelationshipIDs removes the "component_relationships" edge to the SystemComponentRelationship entity by IDs.
func (m *SystemComponentMutation) RemoveComponentRelationshipIDs(ids ...uuid.UUID) {
	if m.removedcomponent_relationships == nil {
		m.removedcomponent_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.component_relationships, ids[i])
		m.removedcomponent_relationships[ids[i]] = struct{}{}
	}
}

// RemovedComponentRelationships returns the removed IDs of the "component_relationships" edge to the SystemComponentRelationship entity.
func (m *SystemComponentMutation) RemovedComponentRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomponent_relationships {
		ids = append(ids, id)
	}
	return
}

// ComponentRelationshipsIDs returns the "component_relationships" edge IDs in the mutation.
func (m *SystemComponentMutation) ComponentRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.component_relationships {
		ids = append(ids, id)
	}
	return
}

// ResetComponentRelationships resets all changes to the "component_relationships" edge.
func (m *SystemComponentMutation) ResetComponentRelationships() {
	m.component_relationships = nil
	m.clearedcomponent_relationships = false
	m.removedcomponent_relationships = nil
}

// AddSystemAnalysisComponentIDs adds the "system_analysis_components" edge to the SystemAnalysisComponent entity by ids.
func (m *SystemComponentMutation) AddSystemAnalysisComponentIDs(ids ...uuid.UUID) {
	if m.system_analysis_components == nil {
		m.system_analysis_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.system_analysis_components[ids[i]] = struct{}{}
	}
}

// ClearSystemAnalysisComponents clears the "system_analysis_components" edge to the SystemAnalysisComponent entity.
func (m *SystemComponentMutation) ClearSystemAnalysisComponents() {
	m.clearedsystem_analysis_components = true
}

// SystemAnalysisComponentsCleared reports if the "system_analysis_components" edge to the SystemAnalysisComponent entity was cleared.
func (m *SystemComponentMutation) SystemAnalysisComponentsCleared() bool {
	return m.clearedsystem_analysis_components
}

// RemoveSystemAnalysisComponentIDs removes the "system_analysis_components" edge to the SystemAnalysisComponent entity by IDs.
func (m *SystemComponentMutation) RemoveSystemAnalysisComponentIDs(ids ...uuid.UUID) {
	if m.removedsystem_analysis_components == nil {
		m.removedsystem_analysis_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.system_analysis_components, ids[i])
		m.removedsystem_analysis_components[ids[i]] = struct{}{}
	}
}

// RemovedSystemAnalysisComponents returns the removed IDs of the "system_analysis_components" edge to the SystemAnalysisComponent entity.
func (m *SystemComponentMutation) RemovedSystemAnalysisComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedsystem_analysis_components {
		ids = append(ids, id)
	}
	return
}

// SystemAnalysisComponentsIDs returns the "system_analysis_components" edge IDs in the mutation.
func (m *SystemComponentMutation) SystemAnalysisComponentsIDs() (ids []uuid.UUID) {
	for id := range m.system_analysis_components {
		ids = append(ids, id)
	}
	return
}

// ResetSystemAnalysisComponents resets all changes to the "system_analysis_components" edge.
func (m *SystemComponentMutation) ResetSystemAnalysisComponents() {
	m.system_analysis_components = nil
	m.clearedsystem_analysis_components = false
	m.removedsystem_analysis_components = nil
}

// AddEventComponentIDs adds the "event_components" edge to the IncidentEventSystemComponent entity by ids.
func (m *SystemComponentMutation) AddEventComponentIDs(ids ...uuid.UUID) {
	if m.event_components == nil {
		m.event_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.event_components[ids[i]] = struct{}{}
	}
}

// ClearEventComponents clears the "event_components" edge to the IncidentEventSystemComponent entity.
func (m *SystemComponentMutation) ClearEventComponents() {
	m.clearedevent_components = true
}

// EventComponentsCleared reports if the "event_components" edge to the IncidentEventSystemComponent entity was cleared.
func (m *SystemComponentMutation) EventComponentsCleared() bool {
	return m.clearedevent_components
}

// RemoveEventComponentIDs removes the "event_components" edge to the IncidentEventSystemComponent entity by IDs.
func (m *SystemComponentMutation) RemoveEventComponentIDs(ids ...uuid.UUID) {
	if m.removedevent_components == nil {
		m.removedevent_components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.event_components, ids[i])
		m.removedevent_components[ids[i]] = struct{}{}
	}
}

// RemovedEventComponents returns the removed IDs of the "event_components" edge to the IncidentEventSystemComponent entity.
func (m *SystemComponentMutation) RemovedEventComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedevent_components {
		ids = append(ids, id)
	}
	return
}

// EventComponentsIDs returns the "event_components" edge IDs in the mutation.
func (m *SystemComponentMutation) EventComponentsIDs() (ids []uuid.UUID) {
	for id := range m.event_components {
		ids = append(ids, id)
	}
	return
}

// ResetEventComponents resets all changes to the "event_components" edge.
func (m *SystemComponentMutation) ResetEventComponents() {
	m.event_components = nil
	m.clearedevent_components = false
	m.removedevent_components = nil
}

// Where appends a list predicates to the SystemComponentMutation builder.
func (m *SystemComponentMutation) Where(ps ...predicate.SystemComponent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponent).
func (m *SystemComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant != nil {
		fields = append(fields, systemcomponent.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, systemcomponent.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, systemcomponent.FieldName)
	}
	if m.kind != nil {
		fields = append(fields, systemcomponent.FieldKindID)
	}
	if m.description != nil {
		fields = append(fields, systemcomponent.FieldDescription)
	}
	if m.properties != nil {
		fields = append(fields, systemcomponent.FieldProperties)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systemcomponent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponent.FieldTenantID:
		return m.TenantID()
	case systemcomponent.FieldExternalID:
		return m.ExternalID()
	case systemcomponent.FieldName:
		return m.Name()
	case systemcomponent.FieldKindID:
		return m.KindID()
	case systemcomponent.FieldDescription:
		return m.Description()
	case systemcomponent.FieldProperties:
		return m.Properties()
	case systemcomponent.FieldCreatedAt:
		return m.CreatedAt()
	case systemcomponent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponent.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemcomponent.FieldExternalID:
		return m.OldExternalID(ctx)
	case systemcomponent.FieldName:
		return m.OldName(ctx)
	case systemcomponent.FieldKindID:
		return m.OldKindID(ctx)
	case systemcomponent.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponent.FieldProperties:
		return m.OldProperties(ctx)
	case systemcomponent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemcomponent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponent.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemcomponent.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case systemcomponent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case systemcomponent.FieldKindID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKindID(v)
		return nil
	case systemcomponent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponent.FieldProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case systemcomponent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemcomponent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponent.FieldExternalID) {
		fields = append(fields, systemcomponent.FieldExternalID)
	}
	if m.FieldCleared(systemcomponent.FieldDescription) {
		fields = append(fields, systemcomponent.FieldDescription)
	}
	if m.FieldCleared(systemcomponent.FieldProperties) {
		fields = append(fields, systemcomponent.FieldProperties)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentMutation) ClearField(name string) error {
	switch name {
	case systemcomponent.FieldExternalID:
		m.ClearExternalID()
		return nil
	case systemcomponent.FieldDescription:
		m.ClearDescription()
		return nil
	case systemcomponent.FieldProperties:
		m.ClearProperties()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentMutation) ResetField(name string) error {
	switch name {
	case systemcomponent.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemcomponent.FieldExternalID:
		m.ResetExternalID()
		return nil
	case systemcomponent.FieldName:
		m.ResetName()
		return nil
	case systemcomponent.FieldKindID:
		m.ResetKindID()
		return nil
	case systemcomponent.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponent.FieldProperties:
		m.ResetProperties()
		return nil
	case systemcomponent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemcomponent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.tenant != nil {
		edges = append(edges, systemcomponent.EdgeTenant)
	}
	if m.kind != nil {
		edges = append(edges, systemcomponent.EdgeKind)
	}
	if m.related != nil {
		edges = append(edges, systemcomponent.EdgeRelated)
	}
	if m.system_analyses != nil {
		edges = append(edges, systemcomponent.EdgeSystemAnalyses)
	}
	if m.events != nil {
		edges = append(edges, systemcomponent.EdgeEvents)
	}
	if m.constraints != nil {
		edges = append(edges, systemcomponent.EdgeConstraints)
	}
	if m.controls != nil {
		edges = append(edges, systemcomponent.EdgeControls)
	}
	if m.signals != nil {
		edges = append(edges, systemcomponent.EdgeSignals)
	}
	if m.hazards != nil {
		edges = append(edges, systemcomponent.EdgeHazards)
	}
	if m.component_relationships != nil {
		edges = append(edges, systemcomponent.EdgeComponentRelationships)
	}
	if m.system_analysis_components != nil {
		edges = append(edges, systemcomponent.EdgeSystemAnalysisComponents)
	}
	if m.event_components != nil {
		edges = append(edges, systemcomponent.EdgeEventComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponent.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponent.EdgeKind:
		if id := m.kind; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponent.EdgeRelated:
		ids := make([]ent.Value, 0, len(m.related))
		for id := range m.related {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeSystemAnalyses:
		ids := make([]ent.Value, 0, len(m.system_analyses))
		for id := range m.system_analyses {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeConstraints:
		ids := make([]ent.Value, 0, len(m.constraints))
		for id := range m.constraints {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeControls:
		ids := make([]ent.Value, 0, len(m.controls))
		for id := range m.controls {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeSignals:
		ids := make([]ent.Value, 0, len(m.signals))
		for id := range m.signals {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeHazards:
		ids := make([]ent.Value, 0, len(m.hazards))
		for id := range m.hazards {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeComponentRelationships:
		ids := make([]ent.Value, 0, len(m.component_relationships))
		for id := range m.component_relationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeSystemAnalysisComponents:
		ids := make([]ent.Value, 0, len(m.system_analysis_components))
		for id := range m.system_analysis_components {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeEventComponents:
		ids := make([]ent.Value, 0, len(m.event_components))
		for id := range m.event_components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedrelated != nil {
		edges = append(edges, systemcomponent.EdgeRelated)
	}
	if m.removedsystem_analyses != nil {
		edges = append(edges, systemcomponent.EdgeSystemAnalyses)
	}
	if m.removedevents != nil {
		edges = append(edges, systemcomponent.EdgeEvents)
	}
	if m.removedconstraints != nil {
		edges = append(edges, systemcomponent.EdgeConstraints)
	}
	if m.removedcontrols != nil {
		edges = append(edges, systemcomponent.EdgeControls)
	}
	if m.removedsignals != nil {
		edges = append(edges, systemcomponent.EdgeSignals)
	}
	if m.removedhazards != nil {
		edges = append(edges, systemcomponent.EdgeHazards)
	}
	if m.removedcomponent_relationships != nil {
		edges = append(edges, systemcomponent.EdgeComponentRelationships)
	}
	if m.removedsystem_analysis_components != nil {
		edges = append(edges, systemcomponent.EdgeSystemAnalysisComponents)
	}
	if m.removedevent_components != nil {
		edges = append(edges, systemcomponent.EdgeEventComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemcomponent.EdgeRelated:
		ids := make([]ent.Value, 0, len(m.removedrelated))
		for id := range m.removedrelated {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeSystemAnalyses:
		ids := make([]ent.Value, 0, len(m.removedsystem_analyses))
		for id := range m.removedsystem_analyses {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeConstraints:
		ids := make([]ent.Value, 0, len(m.removedconstraints))
		for id := range m.removedconstraints {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeControls:
		ids := make([]ent.Value, 0, len(m.removedcontrols))
		for id := range m.removedcontrols {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeSignals:
		ids := make([]ent.Value, 0, len(m.removedsignals))
		for id := range m.removedsignals {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeHazards:
		ids := make([]ent.Value, 0, len(m.removedhazards))
		for id := range m.removedhazards {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeComponentRelationships:
		ids := make([]ent.Value, 0, len(m.removedcomponent_relationships))
		for id := range m.removedcomponent_relationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeSystemAnalysisComponents:
		ids := make([]ent.Value, 0, len(m.removedsystem_analysis_components))
		for id := range m.removedsystem_analysis_components {
			ids = append(ids, id)
		}
		return ids
	case systemcomponent.EdgeEventComponents:
		ids := make([]ent.Value, 0, len(m.removedevent_components))
		for id := range m.removedevent_components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedtenant {
		edges = append(edges, systemcomponent.EdgeTenant)
	}
	if m.clearedkind {
		edges = append(edges, systemcomponent.EdgeKind)
	}
	if m.clearedrelated {
		edges = append(edges, systemcomponent.EdgeRelated)
	}
	if m.clearedsystem_analyses {
		edges = append(edges, systemcomponent.EdgeSystemAnalyses)
	}
	if m.clearedevents {
		edges = append(edges, systemcomponent.EdgeEvents)
	}
	if m.clearedconstraints {
		edges = append(edges, systemcomponent.EdgeConstraints)
	}
	if m.clearedcontrols {
		edges = append(edges, systemcomponent.EdgeControls)
	}
	if m.clearedsignals {
		edges = append(edges, systemcomponent.EdgeSignals)
	}
	if m.clearedhazards {
		edges = append(edges, systemcomponent.EdgeHazards)
	}
	if m.clearedcomponent_relationships {
		edges = append(edges, systemcomponent.EdgeComponentRelationships)
	}
	if m.clearedsystem_analysis_components {
		edges = append(edges, systemcomponent.EdgeSystemAnalysisComponents)
	}
	if m.clearedevent_components {
		edges = append(edges, systemcomponent.EdgeEventComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponent.EdgeTenant:
		return m.clearedtenant
	case systemcomponent.EdgeKind:
		return m.clearedkind
	case systemcomponent.EdgeRelated:
		return m.clearedrelated
	case systemcomponent.EdgeSystemAnalyses:
		return m.clearedsystem_analyses
	case systemcomponent.EdgeEvents:
		return m.clearedevents
	case systemcomponent.EdgeConstraints:
		return m.clearedconstraints
	case systemcomponent.EdgeControls:
		return m.clearedcontrols
	case systemcomponent.EdgeSignals:
		return m.clearedsignals
	case systemcomponent.EdgeHazards:
		return m.clearedhazards
	case systemcomponent.EdgeComponentRelationships:
		return m.clearedcomponent_relationships
	case systemcomponent.EdgeSystemAnalysisComponents:
		return m.clearedsystem_analysis_components
	case systemcomponent.EdgeEventComponents:
		return m.clearedevent_components
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponent.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemcomponent.EdgeKind:
		m.ClearKind()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponent.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemcomponent.EdgeKind:
		m.ResetKind()
		return nil
	case systemcomponent.EdgeRelated:
		m.ResetRelated()
		return nil
	case systemcomponent.EdgeSystemAnalyses:
		m.ResetSystemAnalyses()
		return nil
	case systemcomponent.EdgeEvents:
		m.ResetEvents()
		return nil
	case systemcomponent.EdgeConstraints:
		m.ResetConstraints()
		return nil
	case systemcomponent.EdgeControls:
		m.ResetControls()
		return nil
	case systemcomponent.EdgeSignals:
		m.ResetSignals()
		return nil
	case systemcomponent.EdgeHazards:
		m.ResetHazards()
		return nil
	case systemcomponent.EdgeComponentRelationships:
		m.ResetComponentRelationships()
		return nil
	case systemcomponent.EdgeSystemAnalysisComponents:
		m.ResetSystemAnalysisComponents()
		return nil
	case systemcomponent.EdgeEventComponents:
		m.ResetEventComponents()
		return nil
	}
	return fmt.Errorf("unknown SystemComponent edge %s", name)
}

// SystemComponentConstraintMutation represents an operation that mutates the SystemComponentConstraint nodes in the graph.
type SystemComponentConstraintMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	label            *string
	description      *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	component        *uuid.UUID
	clearedcomponent bool
	hazards          map[uuid.UUID]struct{}
	removedhazards   map[uuid.UUID]struct{}
	clearedhazards   bool
	done             bool
	oldValue         func(context.Context) (*SystemComponentConstraint, error)
	predicates       []predicate.SystemComponentConstraint
}

var _ ent.Mutation = (*SystemComponentConstraintMutation)(nil)

// systemcomponentconstraintOption allows management of the mutation configuration using functional options.
type systemcomponentconstraintOption func(*SystemComponentConstraintMutation)

// newSystemComponentConstraintMutation creates new mutation for the SystemComponentConstraint entity.
func newSystemComponentConstraintMutation(c config, op Op, opts ...systemcomponentconstraintOption) *SystemComponentConstraintMutation {
	m := &SystemComponentConstraintMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponentConstraint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentConstraintID sets the ID field of the mutation.
func withSystemComponentConstraintID(id uuid.UUID) systemcomponentconstraintOption {
	return func(m *SystemComponentConstraintMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponentConstraint
		)
		m.oldValue = func(ctx context.Context) (*SystemComponentConstraint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponentConstraint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponentConstraint sets the old SystemComponentConstraint of the mutation.
func withSystemComponentConstraint(node *SystemComponentConstraint) systemcomponentconstraintOption {
	return func(m *SystemComponentConstraintMutation) {
		m.oldValue = func(context.Context) (*SystemComponentConstraint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentConstraintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentConstraintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponentConstraint entities.
func (m *SystemComponentConstraintMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentConstraintMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentConstraintMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponentConstraint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemComponentConstraintMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemComponentConstraintMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemComponentConstraint entity.
// If the SystemComponentConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentConstraintMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemComponentConstraintMutation) ResetTenantID() {
	m.tenant = nil
}

// SetComponentID sets the "component_id" field.
func (m *SystemComponentConstraintMutation) SetComponentID(u uuid.UUID) {
	m.component = &u
}

// ComponentID returns the value of the "component_id" field in the mutation.
func (m *SystemComponentConstraintMutation) ComponentID() (r uuid.UUID, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentID returns the old "component_id" field's value of the SystemComponentConstraint entity.
// If the SystemComponentConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentConstraintMutation) OldComponentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentID: %w", err)
	}
	return oldValue.ComponentID, nil
}

// ResetComponentID resets all changes to the "component_id" field.
func (m *SystemComponentConstraintMutation) ResetComponentID() {
	m.component = nil
}

// SetLabel sets the "label" field.
func (m *SystemComponentConstraintMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *SystemComponentConstraintMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the SystemComponentConstraint entity.
// If the SystemComponentConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentConstraintMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *SystemComponentConstraintMutation) ResetLabel() {
	m.label = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentConstraintMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentConstraintMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponentConstraint entity.
// If the SystemComponentConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentConstraintMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentConstraintMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponentconstraint.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentConstraintMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponentconstraint.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentConstraintMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponentconstraint.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentConstraintMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentConstraintMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponentConstraint entity.
// If the SystemComponentConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentConstraintMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentConstraintMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemComponentConstraintMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemcomponentconstraint.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemComponentConstraintMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemComponentConstraintMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemComponentConstraintMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearComponent clears the "component" edge to the SystemComponent entity.
func (m *SystemComponentConstraintMutation) ClearComponent() {
	m.clearedcomponent = true
	m.clearedFields[systemcomponentconstraint.FieldComponentID] = struct{}{}
}

// ComponentCleared reports if the "component" edge to the SystemComponent entity was cleared.
func (m *SystemComponentConstraintMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *SystemComponentConstraintMutation) ComponentIDs() (ids []uuid.UUID) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *SystemComponentConstraintMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// AddHazardIDs adds the "hazards" edge to the SystemHazard entity by ids.
func (m *SystemComponentConstraintMutation) AddHazardIDs(ids ...uuid.UUID) {
	if m.hazards == nil {
		m.hazards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hazards[ids[i]] = struct{}{}
	}
}

// ClearHazards clears the "hazards" edge to the SystemHazard entity.
func (m *SystemComponentConstraintMutation) ClearHazards() {
	m.clearedhazards = true
}

// HazardsCleared reports if the "hazards" edge to the SystemHazard entity was cleared.
func (m *SystemComponentConstraintMutation) HazardsCleared() bool {
	return m.clearedhazards
}

// RemoveHazardIDs removes the "hazards" edge to the SystemHazard entity by IDs.
func (m *SystemComponentConstraintMutation) RemoveHazardIDs(ids ...uuid.UUID) {
	if m.removedhazards == nil {
		m.removedhazards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hazards, ids[i])
		m.removedhazards[ids[i]] = struct{}{}
	}
}

// RemovedHazards returns the removed IDs of the "hazards" edge to the SystemHazard entity.
func (m *SystemComponentConstraintMutation) RemovedHazardsIDs() (ids []uuid.UUID) {
	for id := range m.removedhazards {
		ids = append(ids, id)
	}
	return
}

// HazardsIDs returns the "hazards" edge IDs in the mutation.
func (m *SystemComponentConstraintMutation) HazardsIDs() (ids []uuid.UUID) {
	for id := range m.hazards {
		ids = append(ids, id)
	}
	return
}

// ResetHazards resets all changes to the "hazards" edge.
func (m *SystemComponentConstraintMutation) ResetHazards() {
	m.hazards = nil
	m.clearedhazards = false
	m.removedhazards = nil
}

// Where appends a list predicates to the SystemComponentConstraintMutation builder.
func (m *SystemComponentConstraintMutation) Where(ps ...predicate.SystemComponentConstraint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentConstraintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentConstraintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponentConstraint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentConstraintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentConstraintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponentConstraint).
func (m *SystemComponentConstraintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentConstraintMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, systemcomponentconstraint.FieldTenantID)
	}
	if m.component != nil {
		fields = append(fields, systemcomponentconstraint.FieldComponentID)
	}
	if m.label != nil {
		fields = append(fields, systemcomponentconstraint.FieldLabel)
	}
	if m.description != nil {
		fields = append(fields, systemcomponentconstraint.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponentconstraint.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentConstraintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponentconstraint.FieldTenantID:
		return m.TenantID()
	case systemcomponentconstraint.FieldComponentID:
		return m.ComponentID()
	case systemcomponentconstraint.FieldLabel:
		return m.Label()
	case systemcomponentconstraint.FieldDescription:
		return m.Description()
	case systemcomponentconstraint.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentConstraintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponentconstraint.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemcomponentconstraint.FieldComponentID:
		return m.OldComponentID(ctx)
	case systemcomponentconstraint.FieldLabel:
		return m.OldLabel(ctx)
	case systemcomponentconstraint.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponentconstraint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponentConstraint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentConstraintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponentconstraint.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemcomponentconstraint.FieldComponentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentID(v)
		return nil
	case systemcomponentconstraint.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case systemcomponentconstraint.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponentconstraint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponentConstraint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentConstraintMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentConstraintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentConstraintMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponentConstraint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentConstraintMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponentconstraint.FieldDescription) {
		fields = append(fields, systemcomponentconstraint.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentConstraintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentConstraintMutation) ClearField(name string) error {
	switch name {
	case systemcomponentconstraint.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentConstraint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentConstraintMutation) ResetField(name string) error {
	switch name {
	case systemcomponentconstraint.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemcomponentconstraint.FieldComponentID:
		m.ResetComponentID()
		return nil
	case systemcomponentconstraint.FieldLabel:
		m.ResetLabel()
		return nil
	case systemcomponentconstraint.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponentconstraint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentConstraint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentConstraintMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, systemcomponentconstraint.EdgeTenant)
	}
	if m.component != nil {
		edges = append(edges, systemcomponentconstraint.EdgeComponent)
	}
	if m.hazards != nil {
		edges = append(edges, systemcomponentconstraint.EdgeHazards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentConstraintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentconstraint.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentconstraint.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentconstraint.EdgeHazards:
		ids := make([]ent.Value, 0, len(m.hazards))
		for id := range m.hazards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentConstraintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedhazards != nil {
		edges = append(edges, systemcomponentconstraint.EdgeHazards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentConstraintMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentconstraint.EdgeHazards:
		ids := make([]ent.Value, 0, len(m.removedhazards))
		for id := range m.removedhazards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentConstraintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, systemcomponentconstraint.EdgeTenant)
	}
	if m.clearedcomponent {
		edges = append(edges, systemcomponentconstraint.EdgeComponent)
	}
	if m.clearedhazards {
		edges = append(edges, systemcomponentconstraint.EdgeHazards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentConstraintMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponentconstraint.EdgeTenant:
		return m.clearedtenant
	case systemcomponentconstraint.EdgeComponent:
		return m.clearedcomponent
	case systemcomponentconstraint.EdgeHazards:
		return m.clearedhazards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentConstraintMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponentconstraint.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemcomponentconstraint.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentConstraint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentConstraintMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponentconstraint.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemcomponentconstraint.EdgeComponent:
		m.ResetComponent()
		return nil
	case systemcomponentconstraint.EdgeHazards:
		m.ResetHazards()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentConstraint edge %s", name)
}

// SystemComponentControlMutation represents an operation that mutates the SystemComponentControl nodes in the graph.
type SystemComponentControlMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	label                  *string
	description            *string
	created_at             *time.Time
	clearedFields          map[string]struct{}
	tenant                 *int
	clearedtenant          bool
	component              *uuid.UUID
	clearedcomponent       bool
	relationships          map[uuid.UUID]struct{}
	removedrelationships   map[uuid.UUID]struct{}
	clearedrelationships   bool
	control_actions        map[uuid.UUID]struct{}
	removedcontrol_actions map[uuid.UUID]struct{}
	clearedcontrol_actions bool
	done                   bool
	oldValue               func(context.Context) (*SystemComponentControl, error)
	predicates             []predicate.SystemComponentControl
}

var _ ent.Mutation = (*SystemComponentControlMutation)(nil)

// systemcomponentcontrolOption allows management of the mutation configuration using functional options.
type systemcomponentcontrolOption func(*SystemComponentControlMutation)

// newSystemComponentControlMutation creates new mutation for the SystemComponentControl entity.
func newSystemComponentControlMutation(c config, op Op, opts ...systemcomponentcontrolOption) *SystemComponentControlMutation {
	m := &SystemComponentControlMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponentControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentControlID sets the ID field of the mutation.
func withSystemComponentControlID(id uuid.UUID) systemcomponentcontrolOption {
	return func(m *SystemComponentControlMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponentControl
		)
		m.oldValue = func(ctx context.Context) (*SystemComponentControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponentControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponentControl sets the old SystemComponentControl of the mutation.
func withSystemComponentControl(node *SystemComponentControl) systemcomponentcontrolOption {
	return func(m *SystemComponentControlMutation) {
		m.oldValue = func(context.Context) (*SystemComponentControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponentControl entities.
func (m *SystemComponentControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponentControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemComponentControlMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemComponentControlMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemComponentControl entity.
// If the SystemComponentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemComponentControlMutation) ResetTenantID() {
	m.tenant = nil
}

// SetComponentID sets the "component_id" field.
func (m *SystemComponentControlMutation) SetComponentID(u uuid.UUID) {
	m.component = &u
}

// ComponentID returns the value of the "component_id" field in the mutation.
func (m *SystemComponentControlMutation) ComponentID() (r uuid.UUID, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentID returns the old "component_id" field's value of the SystemComponentControl entity.
// If the SystemComponentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlMutation) OldComponentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentID: %w", err)
	}
	return oldValue.ComponentID, nil
}

// ResetComponentID resets all changes to the "component_id" field.
func (m *SystemComponentControlMutation) ResetComponentID() {
	m.component = nil
}

// SetLabel sets the "label" field.
func (m *SystemComponentControlMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *SystemComponentControlMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the SystemComponentControl entity.
// If the SystemComponentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *SystemComponentControlMutation) ResetLabel() {
	m.label = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentControlMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentControlMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponentControl entity.
// If the SystemComponentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentControlMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponentcontrol.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentControlMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponentcontrol.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentControlMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponentcontrol.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponentControl entity.
// If the SystemComponentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemComponentControlMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemcomponentcontrol.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemComponentControlMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemComponentControlMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemComponentControlMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearComponent clears the "component" edge to the SystemComponent entity.
func (m *SystemComponentControlMutation) ClearComponent() {
	m.clearedcomponent = true
	m.clearedFields[systemcomponentcontrol.FieldComponentID] = struct{}{}
}

// ComponentCleared reports if the "component" edge to the SystemComponent entity was cleared.
func (m *SystemComponentControlMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *SystemComponentControlMutation) ComponentIDs() (ids []uuid.UUID) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *SystemComponentControlMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// AddRelationshipIDs adds the "relationships" edge to the SystemComponentRelationship entity by ids.
func (m *SystemComponentControlMutation) AddRelationshipIDs(ids ...uuid.UUID) {
	if m.relationships == nil {
		m.relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.relationships[ids[i]] = struct{}{}
	}
}

// ClearRelationships clears the "relationships" edge to the SystemComponentRelationship entity.
func (m *SystemComponentControlMutation) ClearRelationships() {
	m.clearedrelationships = true
}

// RelationshipsCleared reports if the "relationships" edge to the SystemComponentRelationship entity was cleared.
func (m *SystemComponentControlMutation) RelationshipsCleared() bool {
	return m.clearedrelationships
}

// RemoveRelationshipIDs removes the "relationships" edge to the SystemComponentRelationship entity by IDs.
func (m *SystemComponentControlMutation) RemoveRelationshipIDs(ids ...uuid.UUID) {
	if m.removedrelationships == nil {
		m.removedrelationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.relationships, ids[i])
		m.removedrelationships[ids[i]] = struct{}{}
	}
}

// RemovedRelationships returns the removed IDs of the "relationships" edge to the SystemComponentRelationship entity.
func (m *SystemComponentControlMutation) RemovedRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedrelationships {
		ids = append(ids, id)
	}
	return
}

// RelationshipsIDs returns the "relationships" edge IDs in the mutation.
func (m *SystemComponentControlMutation) RelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.relationships {
		ids = append(ids, id)
	}
	return
}

// ResetRelationships resets all changes to the "relationships" edge.
func (m *SystemComponentControlMutation) ResetRelationships() {
	m.relationships = nil
	m.clearedrelationships = false
	m.removedrelationships = nil
}

// AddControlActionIDs adds the "control_actions" edge to the SystemRelationshipControlAction entity by ids.
func (m *SystemComponentControlMutation) AddControlActionIDs(ids ...uuid.UUID) {
	if m.control_actions == nil {
		m.control_actions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.control_actions[ids[i]] = struct{}{}
	}
}

// ClearControlActions clears the "control_actions" edge to the SystemRelationshipControlAction entity.
func (m *SystemComponentControlMutation) ClearControlActions() {
	m.clearedcontrol_actions = true
}

// ControlActionsCleared reports if the "control_actions" edge to the SystemRelationshipControlAction entity was cleared.
func (m *SystemComponentControlMutation) ControlActionsCleared() bool {
	return m.clearedcontrol_actions
}

// RemoveControlActionIDs removes the "control_actions" edge to the SystemRelationshipControlAction entity by IDs.
func (m *SystemComponentControlMutation) RemoveControlActionIDs(ids ...uuid.UUID) {
	if m.removedcontrol_actions == nil {
		m.removedcontrol_actions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.control_actions, ids[i])
		m.removedcontrol_actions[ids[i]] = struct{}{}
	}
}

// RemovedControlActions returns the removed IDs of the "control_actions" edge to the SystemRelationshipControlAction entity.
func (m *SystemComponentControlMutation) RemovedControlActionsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontrol_actions {
		ids = append(ids, id)
	}
	return
}

// ControlActionsIDs returns the "control_actions" edge IDs in the mutation.
func (m *SystemComponentControlMutation) ControlActionsIDs() (ids []uuid.UUID) {
	for id := range m.control_actions {
		ids = append(ids, id)
	}
	return
}

// ResetControlActions resets all changes to the "control_actions" edge.
func (m *SystemComponentControlMutation) ResetControlActions() {
	m.control_actions = nil
	m.clearedcontrol_actions = false
	m.removedcontrol_actions = nil
}

// Where appends a list predicates to the SystemComponentControlMutation builder.
func (m *SystemComponentControlMutation) Where(ps ...predicate.SystemComponentControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponentControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponentControl).
func (m *SystemComponentControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentControlMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, systemcomponentcontrol.FieldTenantID)
	}
	if m.component != nil {
		fields = append(fields, systemcomponentcontrol.FieldComponentID)
	}
	if m.label != nil {
		fields = append(fields, systemcomponentcontrol.FieldLabel)
	}
	if m.description != nil {
		fields = append(fields, systemcomponentcontrol.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponentcontrol.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponentcontrol.FieldTenantID:
		return m.TenantID()
	case systemcomponentcontrol.FieldComponentID:
		return m.ComponentID()
	case systemcomponentcontrol.FieldLabel:
		return m.Label()
	case systemcomponentcontrol.FieldDescription:
		return m.Description()
	case systemcomponentcontrol.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponentcontrol.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemcomponentcontrol.FieldComponentID:
		return m.OldComponentID(ctx)
	case systemcomponentcontrol.FieldLabel:
		return m.OldLabel(ctx)
	case systemcomponentcontrol.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponentcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponentControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponentcontrol.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemcomponentcontrol.FieldComponentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentID(v)
		return nil
	case systemcomponentcontrol.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case systemcomponentcontrol.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponentcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentControlMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponentControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponentcontrol.FieldDescription) {
		fields = append(fields, systemcomponentcontrol.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentControlMutation) ClearField(name string) error {
	switch name {
	case systemcomponentcontrol.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentControlMutation) ResetField(name string) error {
	switch name {
	case systemcomponentcontrol.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemcomponentcontrol.FieldComponentID:
		m.ResetComponentID()
		return nil
	case systemcomponentcontrol.FieldLabel:
		m.ResetLabel()
		return nil
	case systemcomponentcontrol.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponentcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, systemcomponentcontrol.EdgeTenant)
	}
	if m.component != nil {
		edges = append(edges, systemcomponentcontrol.EdgeComponent)
	}
	if m.relationships != nil {
		edges = append(edges, systemcomponentcontrol.EdgeRelationships)
	}
	if m.control_actions != nil {
		edges = append(edges, systemcomponentcontrol.EdgeControlActions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentcontrol.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentcontrol.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentcontrol.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.relationships))
		for id := range m.relationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentcontrol.EdgeControlActions:
		ids := make([]ent.Value, 0, len(m.control_actions))
		for id := range m.control_actions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrelationships != nil {
		edges = append(edges, systemcomponentcontrol.EdgeRelationships)
	}
	if m.removedcontrol_actions != nil {
		edges = append(edges, systemcomponentcontrol.EdgeControlActions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentControlMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentcontrol.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.removedrelationships))
		for id := range m.removedrelationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentcontrol.EdgeControlActions:
		ids := make([]ent.Value, 0, len(m.removedcontrol_actions))
		for id := range m.removedcontrol_actions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, systemcomponentcontrol.EdgeTenant)
	}
	if m.clearedcomponent {
		edges = append(edges, systemcomponentcontrol.EdgeComponent)
	}
	if m.clearedrelationships {
		edges = append(edges, systemcomponentcontrol.EdgeRelationships)
	}
	if m.clearedcontrol_actions {
		edges = append(edges, systemcomponentcontrol.EdgeControlActions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentControlMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponentcontrol.EdgeTenant:
		return m.clearedtenant
	case systemcomponentcontrol.EdgeComponent:
		return m.clearedcomponent
	case systemcomponentcontrol.EdgeRelationships:
		return m.clearedrelationships
	case systemcomponentcontrol.EdgeControlActions:
		return m.clearedcontrol_actions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentControlMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponentcontrol.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemcomponentcontrol.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentControlMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponentcontrol.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemcomponentcontrol.EdgeComponent:
		m.ResetComponent()
		return nil
	case systemcomponentcontrol.EdgeRelationships:
		m.ResetRelationships()
		return nil
	case systemcomponentcontrol.EdgeControlActions:
		m.ResetControlActions()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentControl edge %s", name)
}

// SystemComponentKindMutation represents an operation that mutates the SystemComponentKind nodes in the graph.
type SystemComponentKindMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	external_id       *string
	label             *string
	description       *string
	created_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	components        map[uuid.UUID]struct{}
	removedcomponents map[uuid.UUID]struct{}
	clearedcomponents bool
	done              bool
	oldValue          func(context.Context) (*SystemComponentKind, error)
	predicates        []predicate.SystemComponentKind
}

var _ ent.Mutation = (*SystemComponentKindMutation)(nil)

// systemcomponentkindOption allows management of the mutation configuration using functional options.
type systemcomponentkindOption func(*SystemComponentKindMutation)

// newSystemComponentKindMutation creates new mutation for the SystemComponentKind entity.
func newSystemComponentKindMutation(c config, op Op, opts ...systemcomponentkindOption) *SystemComponentKindMutation {
	m := &SystemComponentKindMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponentKind,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentKindID sets the ID field of the mutation.
func withSystemComponentKindID(id uuid.UUID) systemcomponentkindOption {
	return func(m *SystemComponentKindMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponentKind
		)
		m.oldValue = func(ctx context.Context) (*SystemComponentKind, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponentKind.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponentKind sets the old SystemComponentKind of the mutation.
func withSystemComponentKind(node *SystemComponentKind) systemcomponentkindOption {
	return func(m *SystemComponentKindMutation) {
		m.oldValue = func(context.Context) (*SystemComponentKind, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentKindMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentKindMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponentKind entities.
func (m *SystemComponentKindMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentKindMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentKindMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponentKind.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemComponentKindMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemComponentKindMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemComponentKind entity.
// If the SystemComponentKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentKindMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemComponentKindMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *SystemComponentKindMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SystemComponentKindMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the SystemComponentKind entity.
// If the SystemComponentKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentKindMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *SystemComponentKindMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[systemcomponentkind.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *SystemComponentKindMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[systemcomponentkind.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SystemComponentKindMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, systemcomponentkind.FieldExternalID)
}

// SetLabel sets the "label" field.
func (m *SystemComponentKindMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *SystemComponentKindMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the SystemComponentKind entity.
// If the SystemComponentKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentKindMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *SystemComponentKindMutation) ResetLabel() {
	m.label = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentKindMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentKindMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponentKind entity.
// If the SystemComponentKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentKindMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentKindMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponentkind.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentKindMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponentkind.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentKindMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponentkind.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentKindMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentKindMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponentKind entity.
// If the SystemComponentKind object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentKindMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentKindMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemComponentKindMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemcomponentkind.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemComponentKindMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemComponentKindMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemComponentKindMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddComponentIDs adds the "components" edge to the SystemComponent entity by ids.
func (m *SystemComponentKindMutation) AddComponentIDs(ids ...uuid.UUID) {
	if m.components == nil {
		m.components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the SystemComponent entity.
func (m *SystemComponentKindMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the SystemComponent entity was cleared.
func (m *SystemComponentKindMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the SystemComponent entity by IDs.
func (m *SystemComponentKindMutation) RemoveComponentIDs(ids ...uuid.UUID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the SystemComponent entity.
func (m *SystemComponentKindMutation) RemovedComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *SystemComponentKindMutation) ComponentsIDs() (ids []uuid.UUID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *SystemComponentKindMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// Where appends a list predicates to the SystemComponentKindMutation builder.
func (m *SystemComponentKindMutation) Where(ps ...predicate.SystemComponentKind) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentKindMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentKindMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponentKind, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentKindMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentKindMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponentKind).
func (m *SystemComponentKindMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentKindMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, systemcomponentkind.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, systemcomponentkind.FieldExternalID)
	}
	if m.label != nil {
		fields = append(fields, systemcomponentkind.FieldLabel)
	}
	if m.description != nil {
		fields = append(fields, systemcomponentkind.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponentkind.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentKindMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponentkind.FieldTenantID:
		return m.TenantID()
	case systemcomponentkind.FieldExternalID:
		return m.ExternalID()
	case systemcomponentkind.FieldLabel:
		return m.Label()
	case systemcomponentkind.FieldDescription:
		return m.Description()
	case systemcomponentkind.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentKindMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponentkind.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemcomponentkind.FieldExternalID:
		return m.OldExternalID(ctx)
	case systemcomponentkind.FieldLabel:
		return m.OldLabel(ctx)
	case systemcomponentkind.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponentkind.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponentKind field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentKindMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponentkind.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemcomponentkind.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case systemcomponentkind.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case systemcomponentkind.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponentkind.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponentKind field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentKindMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentKindMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentKindMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponentKind numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentKindMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponentkind.FieldExternalID) {
		fields = append(fields, systemcomponentkind.FieldExternalID)
	}
	if m.FieldCleared(systemcomponentkind.FieldDescription) {
		fields = append(fields, systemcomponentkind.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentKindMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentKindMutation) ClearField(name string) error {
	switch name {
	case systemcomponentkind.FieldExternalID:
		m.ClearExternalID()
		return nil
	case systemcomponentkind.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentKind nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentKindMutation) ResetField(name string) error {
	switch name {
	case systemcomponentkind.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemcomponentkind.FieldExternalID:
		m.ResetExternalID()
		return nil
	case systemcomponentkind.FieldLabel:
		m.ResetLabel()
		return nil
	case systemcomponentkind.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponentkind.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentKind field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentKindMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, systemcomponentkind.EdgeTenant)
	}
	if m.components != nil {
		edges = append(edges, systemcomponentkind.EdgeComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentKindMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentkind.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentkind.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentKindMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomponents != nil {
		edges = append(edges, systemcomponentkind.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentKindMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentkind.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentKindMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, systemcomponentkind.EdgeTenant)
	}
	if m.clearedcomponents {
		edges = append(edges, systemcomponentkind.EdgeComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentKindMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponentkind.EdgeTenant:
		return m.clearedtenant
	case systemcomponentkind.EdgeComponents:
		return m.clearedcomponents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentKindMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponentkind.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentKind unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentKindMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponentkind.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemcomponentkind.EdgeComponents:
		m.ResetComponents()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentKind edge %s", name)
}

// SystemComponentRelationshipMutation represents an operation that mutates the SystemComponentRelationship nodes in the graph.
type SystemComponentRelationshipMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	external_id             *string
	description             *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	tenant                  *int
	clearedtenant           bool
	source                  *uuid.UUID
	clearedsource           bool
	target                  *uuid.UUID
	clearedtarget           bool
	system_analyses         map[uuid.UUID]struct{}
	removedsystem_analyses  map[uuid.UUID]struct{}
	clearedsystem_analyses  bool
	hazards                 map[uuid.UUID]struct{}
	removedhazards          map[uuid.UUID]struct{}
	clearedhazards          bool
	controls                map[uuid.UUID]struct{}
	removedcontrols         map[uuid.UUID]struct{}
	clearedcontrols         bool
	signals                 map[uuid.UUID]struct{}
	removedsignals          map[uuid.UUID]struct{}
	clearedsignals          bool
	control_actions         map[uuid.UUID]struct{}
	removedcontrol_actions  map[uuid.UUID]struct{}
	clearedcontrol_actions  bool
	feedback_signals        map[uuid.UUID]struct{}
	removedfeedback_signals map[uuid.UUID]struct{}
	clearedfeedback_signals bool
	done                    bool
	oldValue                func(context.Context) (*SystemComponentRelationship, error)
	predicates              []predicate.SystemComponentRelationship
}

var _ ent.Mutation = (*SystemComponentRelationshipMutation)(nil)

// systemcomponentrelationshipOption allows management of the mutation configuration using functional options.
type systemcomponentrelationshipOption func(*SystemComponentRelationshipMutation)

// newSystemComponentRelationshipMutation creates new mutation for the SystemComponentRelationship entity.
func newSystemComponentRelationshipMutation(c config, op Op, opts ...systemcomponentrelationshipOption) *SystemComponentRelationshipMutation {
	m := &SystemComponentRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponentRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentRelationshipID sets the ID field of the mutation.
func withSystemComponentRelationshipID(id uuid.UUID) systemcomponentrelationshipOption {
	return func(m *SystemComponentRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponentRelationship
		)
		m.oldValue = func(ctx context.Context) (*SystemComponentRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponentRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponentRelationship sets the old SystemComponentRelationship of the mutation.
func withSystemComponentRelationship(node *SystemComponentRelationship) systemcomponentrelationshipOption {
	return func(m *SystemComponentRelationshipMutation) {
		m.oldValue = func(context.Context) (*SystemComponentRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponentRelationship entities.
func (m *SystemComponentRelationshipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentRelationshipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentRelationshipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponentRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemComponentRelationshipMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemComponentRelationshipMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemComponentRelationship entity.
// If the SystemComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentRelationshipMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemComponentRelationshipMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *SystemComponentRelationshipMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SystemComponentRelationshipMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the SystemComponentRelationship entity.
// If the SystemComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentRelationshipMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *SystemComponentRelationshipMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[systemcomponentrelationship.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *SystemComponentRelationshipMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[systemcomponentrelationship.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SystemComponentRelationshipMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, systemcomponentrelationship.FieldExternalID)
}

// SetSourceID sets the "source_id" field.
func (m *SystemComponentRelationshipMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *SystemComponentRelationshipMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the SystemComponentRelationship entity.
// If the SystemComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentRelationshipMutation) OldSourceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *SystemComponentRelationshipMutation) ResetSourceID() {
	m.source = nil
}

// SetTargetID sets the "target_id" field.
func (m *SystemComponentRelationshipMutation) SetTargetID(u uuid.UUID) {
	m.target = &u
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *SystemComponentRelationshipMutation) TargetID() (r uuid.UUID, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the SystemComponentRelationship entity.
// If the SystemComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentRelationshipMutation) OldTargetID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *SystemComponentRelationshipMutation) ResetTargetID() {
	m.target = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentRelationshipMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentRelationshipMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponentRelationship entity.
// If the SystemComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentRelationshipMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentRelationshipMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponentrelationship.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentRelationshipMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponentrelationship.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentRelationshipMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponentrelationship.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponentRelationship entity.
// If the SystemComponentRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemComponentRelationshipMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemcomponentrelationship.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemComponentRelationshipMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemComponentRelationshipMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemComponentRelationshipMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearSource clears the "source" edge to the SystemComponent entity.
func (m *SystemComponentRelationshipMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[systemcomponentrelationship.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SystemComponent entity was cleared.
func (m *SystemComponentRelationshipMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *SystemComponentRelationshipMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *SystemComponentRelationshipMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// ClearTarget clears the "target" edge to the SystemComponent entity.
func (m *SystemComponentRelationshipMutation) ClearTarget() {
	m.clearedtarget = true
	m.clearedFields[systemcomponentrelationship.FieldTargetID] = struct{}{}
}

// TargetCleared reports if the "target" edge to the SystemComponent entity was cleared.
func (m *SystemComponentRelationshipMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *SystemComponentRelationshipMutation) TargetIDs() (ids []uuid.UUID) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *SystemComponentRelationshipMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// AddSystemAnalysisIDs adds the "system_analyses" edge to the SystemAnalysisRelationship entity by ids.
func (m *SystemComponentRelationshipMutation) AddSystemAnalysisIDs(ids ...uuid.UUID) {
	if m.system_analyses == nil {
		m.system_analyses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.system_analyses[ids[i]] = struct{}{}
	}
}

// ClearSystemAnalyses clears the "system_analyses" edge to the SystemAnalysisRelationship entity.
func (m *SystemComponentRelationshipMutation) ClearSystemAnalyses() {
	m.clearedsystem_analyses = true
}

// SystemAnalysesCleared reports if the "system_analyses" edge to the SystemAnalysisRelationship entity was cleared.
func (m *SystemComponentRelationshipMutation) SystemAnalysesCleared() bool {
	return m.clearedsystem_analyses
}

// RemoveSystemAnalysisIDs removes the "system_analyses" edge to the SystemAnalysisRelationship entity by IDs.
func (m *SystemComponentRelationshipMutation) RemoveSystemAnalysisIDs(ids ...uuid.UUID) {
	if m.removedsystem_analyses == nil {
		m.removedsystem_analyses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.system_analyses, ids[i])
		m.removedsystem_analyses[ids[i]] = struct{}{}
	}
}

// RemovedSystemAnalyses returns the removed IDs of the "system_analyses" edge to the SystemAnalysisRelationship entity.
func (m *SystemComponentRelationshipMutation) RemovedSystemAnalysesIDs() (ids []uuid.UUID) {
	for id := range m.removedsystem_analyses {
		ids = append(ids, id)
	}
	return
}

// SystemAnalysesIDs returns the "system_analyses" edge IDs in the mutation.
func (m *SystemComponentRelationshipMutation) SystemAnalysesIDs() (ids []uuid.UUID) {
	for id := range m.system_analyses {
		ids = append(ids, id)
	}
	return
}

// ResetSystemAnalyses resets all changes to the "system_analyses" edge.
func (m *SystemComponentRelationshipMutation) ResetSystemAnalyses() {
	m.system_analyses = nil
	m.clearedsystem_analyses = false
	m.removedsystem_analyses = nil
}

// AddHazardIDs adds the "hazards" edge to the SystemHazard entity by ids.
func (m *SystemComponentRelationshipMutation) AddHazardIDs(ids ...uuid.UUID) {
	if m.hazards == nil {
		m.hazards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hazards[ids[i]] = struct{}{}
	}
}

// ClearHazards clears the "hazards" edge to the SystemHazard entity.
func (m *SystemComponentRelationshipMutation) ClearHazards() {
	m.clearedhazards = true
}

// HazardsCleared reports if the "hazards" edge to the SystemHazard entity was cleared.
func (m *SystemComponentRelationshipMutation) HazardsCleared() bool {
	return m.clearedhazards
}

// RemoveHazardIDs removes the "hazards" edge to the SystemHazard entity by IDs.
func (m *SystemComponentRelationshipMutation) RemoveHazardIDs(ids ...uuid.UUID) {
	if m.removedhazards == nil {
		m.removedhazards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hazards, ids[i])
		m.removedhazards[ids[i]] = struct{}{}
	}
}

// RemovedHazards returns the removed IDs of the "hazards" edge to the SystemHazard entity.
func (m *SystemComponentRelationshipMutation) RemovedHazardsIDs() (ids []uuid.UUID) {
	for id := range m.removedhazards {
		ids = append(ids, id)
	}
	return
}

// HazardsIDs returns the "hazards" edge IDs in the mutation.
func (m *SystemComponentRelationshipMutation) HazardsIDs() (ids []uuid.UUID) {
	for id := range m.hazards {
		ids = append(ids, id)
	}
	return
}

// ResetHazards resets all changes to the "hazards" edge.
func (m *SystemComponentRelationshipMutation) ResetHazards() {
	m.hazards = nil
	m.clearedhazards = false
	m.removedhazards = nil
}

// AddControlIDs adds the "controls" edge to the SystemComponentControl entity by ids.
func (m *SystemComponentRelationshipMutation) AddControlIDs(ids ...uuid.UUID) {
	if m.controls == nil {
		m.controls = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.controls[ids[i]] = struct{}{}
	}
}

// ClearControls clears the "controls" edge to the SystemComponentControl entity.
func (m *SystemComponentRelationshipMutation) ClearControls() {
	m.clearedcontrols = true
}

// ControlsCleared reports if the "controls" edge to the SystemComponentControl entity was cleared.
func (m *SystemComponentRelationshipMutation) ControlsCleared() bool {
	return m.clearedcontrols
}

// RemoveControlIDs removes the "controls" edge to the SystemComponentControl entity by IDs.
func (m *SystemComponentRelationshipMutation) RemoveControlIDs(ids ...uuid.UUID) {
	if m.removedcontrols == nil {
		m.removedcontrols = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.controls, ids[i])
		m.removedcontrols[ids[i]] = struct{}{}
	}
}

// RemovedControls returns the removed IDs of the "controls" edge to the SystemComponentControl entity.
func (m *SystemComponentRelationshipMutation) RemovedControlsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontrols {
		ids = append(ids, id)
	}
	return
}

// ControlsIDs returns the "controls" edge IDs in the mutation.
func (m *SystemComponentRelationshipMutation) ControlsIDs() (ids []uuid.UUID) {
	for id := range m.controls {
		ids = append(ids, id)
	}
	return
}

// ResetControls resets all changes to the "controls" edge.
func (m *SystemComponentRelationshipMutation) ResetControls() {
	m.controls = nil
	m.clearedcontrols = false
	m.removedcontrols = nil
}

// AddSignalIDs adds the "signals" edge to the SystemComponentSignal entity by ids.
func (m *SystemComponentRelationshipMutation) AddSignalIDs(ids ...uuid.UUID) {
	if m.signals == nil {
		m.signals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.signals[ids[i]] = struct{}{}
	}
}

// ClearSignals clears the "signals" edge to the SystemComponentSignal entity.
func (m *SystemComponentRelationshipMutation) ClearSignals() {
	m.clearedsignals = true
}

// SignalsCleared reports if the "signals" edge to the SystemComponentSignal entity was cleared.
func (m *SystemComponentRelationshipMutation) SignalsCleared() bool {
	return m.clearedsignals
}

// RemoveSignalIDs removes the "signals" edge to the SystemComponentSignal entity by IDs.
func (m *SystemComponentRelationshipMutation) RemoveSignalIDs(ids ...uuid.UUID) {
	if m.removedsignals == nil {
		m.removedsignals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.signals, ids[i])
		m.removedsignals[ids[i]] = struct{}{}
	}
}

// RemovedSignals returns the removed IDs of the "signals" edge to the SystemComponentSignal entity.
func (m *SystemComponentRelationshipMutation) RemovedSignalsIDs() (ids []uuid.UUID) {
	for id := range m.removedsignals {
		ids = append(ids, id)
	}
	return
}

// SignalsIDs returns the "signals" edge IDs in the mutation.
func (m *SystemComponentRelationshipMutation) SignalsIDs() (ids []uuid.UUID) {
	for id := range m.signals {
		ids = append(ids, id)
	}
	return
}

// ResetSignals resets all changes to the "signals" edge.
func (m *SystemComponentRelationshipMutation) ResetSignals() {
	m.signals = nil
	m.clearedsignals = false
	m.removedsignals = nil
}

// AddControlActionIDs adds the "control_actions" edge to the SystemRelationshipControlAction entity by ids.
func (m *SystemComponentRelationshipMutation) AddControlActionIDs(ids ...uuid.UUID) {
	if m.control_actions == nil {
		m.control_actions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.control_actions[ids[i]] = struct{}{}
	}
}

// ClearControlActions clears the "control_actions" edge to the SystemRelationshipControlAction entity.
func (m *SystemComponentRelationshipMutation) ClearControlActions() {
	m.clearedcontrol_actions = true
}

// ControlActionsCleared reports if the "control_actions" edge to the SystemRelationshipControlAction entity was cleared.
func (m *SystemComponentRelationshipMutation) ControlActionsCleared() bool {
	return m.clearedcontrol_actions
}

// RemoveControlActionIDs removes the "control_actions" edge to the SystemRelationshipControlAction entity by IDs.
func (m *SystemComponentRelationshipMutation) RemoveControlActionIDs(ids ...uuid.UUID) {
	if m.removedcontrol_actions == nil {
		m.removedcontrol_actions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.control_actions, ids[i])
		m.removedcontrol_actions[ids[i]] = struct{}{}
	}
}

// RemovedControlActions returns the removed IDs of the "control_actions" edge to the SystemRelationshipControlAction entity.
func (m *SystemComponentRelationshipMutation) RemovedControlActionsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontrol_actions {
		ids = append(ids, id)
	}
	return
}

// ControlActionsIDs returns the "control_actions" edge IDs in the mutation.
func (m *SystemComponentRelationshipMutation) ControlActionsIDs() (ids []uuid.UUID) {
	for id := range m.control_actions {
		ids = append(ids, id)
	}
	return
}

// ResetControlActions resets all changes to the "control_actions" edge.
func (m *SystemComponentRelationshipMutation) ResetControlActions() {
	m.control_actions = nil
	m.clearedcontrol_actions = false
	m.removedcontrol_actions = nil
}

// AddFeedbackSignalIDs adds the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity by ids.
func (m *SystemComponentRelationshipMutation) AddFeedbackSignalIDs(ids ...uuid.UUID) {
	if m.feedback_signals == nil {
		m.feedback_signals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.feedback_signals[ids[i]] = struct{}{}
	}
}

// ClearFeedbackSignals clears the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity.
func (m *SystemComponentRelationshipMutation) ClearFeedbackSignals() {
	m.clearedfeedback_signals = true
}

// FeedbackSignalsCleared reports if the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity was cleared.
func (m *SystemComponentRelationshipMutation) FeedbackSignalsCleared() bool {
	return m.clearedfeedback_signals
}

// RemoveFeedbackSignalIDs removes the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity by IDs.
func (m *SystemComponentRelationshipMutation) RemoveFeedbackSignalIDs(ids ...uuid.UUID) {
	if m.removedfeedback_signals == nil {
		m.removedfeedback_signals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.feedback_signals, ids[i])
		m.removedfeedback_signals[ids[i]] = struct{}{}
	}
}

// RemovedFeedbackSignals returns the removed IDs of the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity.
func (m *SystemComponentRelationshipMutation) RemovedFeedbackSignalsIDs() (ids []uuid.UUID) {
	for id := range m.removedfeedback_signals {
		ids = append(ids, id)
	}
	return
}

// FeedbackSignalsIDs returns the "feedback_signals" edge IDs in the mutation.
func (m *SystemComponentRelationshipMutation) FeedbackSignalsIDs() (ids []uuid.UUID) {
	for id := range m.feedback_signals {
		ids = append(ids, id)
	}
	return
}

// ResetFeedbackSignals resets all changes to the "feedback_signals" edge.
func (m *SystemComponentRelationshipMutation) ResetFeedbackSignals() {
	m.feedback_signals = nil
	m.clearedfeedback_signals = false
	m.removedfeedback_signals = nil
}

// Where appends a list predicates to the SystemComponentRelationshipMutation builder.
func (m *SystemComponentRelationshipMutation) Where(ps ...predicate.SystemComponentRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponentRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponentRelationship).
func (m *SystemComponentRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, systemcomponentrelationship.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, systemcomponentrelationship.FieldExternalID)
	}
	if m.source != nil {
		fields = append(fields, systemcomponentrelationship.FieldSourceID)
	}
	if m.target != nil {
		fields = append(fields, systemcomponentrelationship.FieldTargetID)
	}
	if m.description != nil {
		fields = append(fields, systemcomponentrelationship.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponentrelationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponentrelationship.FieldTenantID:
		return m.TenantID()
	case systemcomponentrelationship.FieldExternalID:
		return m.ExternalID()
	case systemcomponentrelationship.FieldSourceID:
		return m.SourceID()
	case systemcomponentrelationship.FieldTargetID:
		return m.TargetID()
	case systemcomponentrelationship.FieldDescription:
		return m.Description()
	case systemcomponentrelationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponentrelationship.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemcomponentrelationship.FieldExternalID:
		return m.OldExternalID(ctx)
	case systemcomponentrelationship.FieldSourceID:
		return m.OldSourceID(ctx)
	case systemcomponentrelationship.FieldTargetID:
		return m.OldTargetID(ctx)
	case systemcomponentrelationship.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponentrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponentRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponentrelationship.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemcomponentrelationship.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case systemcomponentrelationship.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case systemcomponentrelationship.FieldTargetID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case systemcomponentrelationship.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponentrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponentRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentRelationshipMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponentRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponentrelationship.FieldExternalID) {
		fields = append(fields, systemcomponentrelationship.FieldExternalID)
	}
	if m.FieldCleared(systemcomponentrelationship.FieldDescription) {
		fields = append(fields, systemcomponentrelationship.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentRelationshipMutation) ClearField(name string) error {
	switch name {
	case systemcomponentrelationship.FieldExternalID:
		m.ClearExternalID()
		return nil
	case systemcomponentrelationship.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentRelationshipMutation) ResetField(name string) error {
	switch name {
	case systemcomponentrelationship.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemcomponentrelationship.FieldExternalID:
		m.ResetExternalID()
		return nil
	case systemcomponentrelationship.FieldSourceID:
		m.ResetSourceID()
		return nil
	case systemcomponentrelationship.FieldTargetID:
		m.ResetTargetID()
		return nil
	case systemcomponentrelationship.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponentrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.tenant != nil {
		edges = append(edges, systemcomponentrelationship.EdgeTenant)
	}
	if m.source != nil {
		edges = append(edges, systemcomponentrelationship.EdgeSource)
	}
	if m.target != nil {
		edges = append(edges, systemcomponentrelationship.EdgeTarget)
	}
	if m.system_analyses != nil {
		edges = append(edges, systemcomponentrelationship.EdgeSystemAnalyses)
	}
	if m.hazards != nil {
		edges = append(edges, systemcomponentrelationship.EdgeHazards)
	}
	if m.controls != nil {
		edges = append(edges, systemcomponentrelationship.EdgeControls)
	}
	if m.signals != nil {
		edges = append(edges, systemcomponentrelationship.EdgeSignals)
	}
	if m.control_actions != nil {
		edges = append(edges, systemcomponentrelationship.EdgeControlActions)
	}
	if m.feedback_signals != nil {
		edges = append(edges, systemcomponentrelationship.EdgeFeedbackSignals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentrelationship.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentrelationship.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentrelationship.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentrelationship.EdgeSystemAnalyses:
		ids := make([]ent.Value, 0, len(m.system_analyses))
		for id := range m.system_analyses {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeHazards:
		ids := make([]ent.Value, 0, len(m.hazards))
		for id := range m.hazards {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeControls:
		ids := make([]ent.Value, 0, len(m.controls))
		for id := range m.controls {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeSignals:
		ids := make([]ent.Value, 0, len(m.signals))
		for id := range m.signals {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeControlActions:
		ids := make([]ent.Value, 0, len(m.control_actions))
		for id := range m.control_actions {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeFeedbackSignals:
		ids := make([]ent.Value, 0, len(m.feedback_signals))
		for id := range m.feedback_signals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedsystem_analyses != nil {
		edges = append(edges, systemcomponentrelationship.EdgeSystemAnalyses)
	}
	if m.removedhazards != nil {
		edges = append(edges, systemcomponentrelationship.EdgeHazards)
	}
	if m.removedcontrols != nil {
		edges = append(edges, systemcomponentrelationship.EdgeControls)
	}
	if m.removedsignals != nil {
		edges = append(edges, systemcomponentrelationship.EdgeSignals)
	}
	if m.removedcontrol_actions != nil {
		edges = append(edges, systemcomponentrelationship.EdgeControlActions)
	}
	if m.removedfeedback_signals != nil {
		edges = append(edges, systemcomponentrelationship.EdgeFeedbackSignals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentRelationshipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentrelationship.EdgeSystemAnalyses:
		ids := make([]ent.Value, 0, len(m.removedsystem_analyses))
		for id := range m.removedsystem_analyses {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeHazards:
		ids := make([]ent.Value, 0, len(m.removedhazards))
		for id := range m.removedhazards {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeControls:
		ids := make([]ent.Value, 0, len(m.removedcontrols))
		for id := range m.removedcontrols {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeSignals:
		ids := make([]ent.Value, 0, len(m.removedsignals))
		for id := range m.removedsignals {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeControlActions:
		ids := make([]ent.Value, 0, len(m.removedcontrol_actions))
		for id := range m.removedcontrol_actions {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentrelationship.EdgeFeedbackSignals:
		ids := make([]ent.Value, 0, len(m.removedfeedback_signals))
		for id := range m.removedfeedback_signals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedtenant {
		edges = append(edges, systemcomponentrelationship.EdgeTenant)
	}
	if m.clearedsource {
		edges = append(edges, systemcomponentrelationship.EdgeSource)
	}
	if m.clearedtarget {
		edges = append(edges, systemcomponentrelationship.EdgeTarget)
	}
	if m.clearedsystem_analyses {
		edges = append(edges, systemcomponentrelationship.EdgeSystemAnalyses)
	}
	if m.clearedhazards {
		edges = append(edges, systemcomponentrelationship.EdgeHazards)
	}
	if m.clearedcontrols {
		edges = append(edges, systemcomponentrelationship.EdgeControls)
	}
	if m.clearedsignals {
		edges = append(edges, systemcomponentrelationship.EdgeSignals)
	}
	if m.clearedcontrol_actions {
		edges = append(edges, systemcomponentrelationship.EdgeControlActions)
	}
	if m.clearedfeedback_signals {
		edges = append(edges, systemcomponentrelationship.EdgeFeedbackSignals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponentrelationship.EdgeTenant:
		return m.clearedtenant
	case systemcomponentrelationship.EdgeSource:
		return m.clearedsource
	case systemcomponentrelationship.EdgeTarget:
		return m.clearedtarget
	case systemcomponentrelationship.EdgeSystemAnalyses:
		return m.clearedsystem_analyses
	case systemcomponentrelationship.EdgeHazards:
		return m.clearedhazards
	case systemcomponentrelationship.EdgeControls:
		return m.clearedcontrols
	case systemcomponentrelationship.EdgeSignals:
		return m.clearedsignals
	case systemcomponentrelationship.EdgeControlActions:
		return m.clearedcontrol_actions
	case systemcomponentrelationship.EdgeFeedbackSignals:
		return m.clearedfeedback_signals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponentrelationship.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemcomponentrelationship.EdgeSource:
		m.ClearSource()
		return nil
	case systemcomponentrelationship.EdgeTarget:
		m.ClearTarget()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponentrelationship.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemcomponentrelationship.EdgeSource:
		m.ResetSource()
		return nil
	case systemcomponentrelationship.EdgeTarget:
		m.ResetTarget()
		return nil
	case systemcomponentrelationship.EdgeSystemAnalyses:
		m.ResetSystemAnalyses()
		return nil
	case systemcomponentrelationship.EdgeHazards:
		m.ResetHazards()
		return nil
	case systemcomponentrelationship.EdgeControls:
		m.ResetControls()
		return nil
	case systemcomponentrelationship.EdgeSignals:
		m.ResetSignals()
		return nil
	case systemcomponentrelationship.EdgeControlActions:
		m.ResetControlActions()
		return nil
	case systemcomponentrelationship.EdgeFeedbackSignals:
		m.ResetFeedbackSignals()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentRelationship edge %s", name)
}

// SystemComponentSignalMutation represents an operation that mutates the SystemComponentSignal nodes in the graph.
type SystemComponentSignalMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	label                   *string
	description             *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	tenant                  *int
	clearedtenant           bool
	component               *uuid.UUID
	clearedcomponent        bool
	relationships           map[uuid.UUID]struct{}
	removedrelationships    map[uuid.UUID]struct{}
	clearedrelationships    bool
	feedback_signals        map[uuid.UUID]struct{}
	removedfeedback_signals map[uuid.UUID]struct{}
	clearedfeedback_signals bool
	done                    bool
	oldValue                func(context.Context) (*SystemComponentSignal, error)
	predicates              []predicate.SystemComponentSignal
}

var _ ent.Mutation = (*SystemComponentSignalMutation)(nil)

// systemcomponentsignalOption allows management of the mutation configuration using functional options.
type systemcomponentsignalOption func(*SystemComponentSignalMutation)

// newSystemComponentSignalMutation creates new mutation for the SystemComponentSignal entity.
func newSystemComponentSignalMutation(c config, op Op, opts ...systemcomponentsignalOption) *SystemComponentSignalMutation {
	m := &SystemComponentSignalMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemComponentSignal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemComponentSignalID sets the ID field of the mutation.
func withSystemComponentSignalID(id uuid.UUID) systemcomponentsignalOption {
	return func(m *SystemComponentSignalMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemComponentSignal
		)
		m.oldValue = func(ctx context.Context) (*SystemComponentSignal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemComponentSignal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemComponentSignal sets the old SystemComponentSignal of the mutation.
func withSystemComponentSignal(node *SystemComponentSignal) systemcomponentsignalOption {
	return func(m *SystemComponentSignalMutation) {
		m.oldValue = func(context.Context) (*SystemComponentSignal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemComponentSignalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemComponentSignalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemComponentSignal entities.
func (m *SystemComponentSignalMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemComponentSignalMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemComponentSignalMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemComponentSignal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemComponentSignalMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemComponentSignalMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemComponentSignal entity.
// If the SystemComponentSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentSignalMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemComponentSignalMutation) ResetTenantID() {
	m.tenant = nil
}

// SetComponentID sets the "component_id" field.
func (m *SystemComponentSignalMutation) SetComponentID(u uuid.UUID) {
	m.component = &u
}

// ComponentID returns the value of the "component_id" field in the mutation.
func (m *SystemComponentSignalMutation) ComponentID() (r uuid.UUID, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponentID returns the old "component_id" field's value of the SystemComponentSignal entity.
// If the SystemComponentSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentSignalMutation) OldComponentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponentID: %w", err)
	}
	return oldValue.ComponentID, nil
}

// ResetComponentID resets all changes to the "component_id" field.
func (m *SystemComponentSignalMutation) ResetComponentID() {
	m.component = nil
}

// SetLabel sets the "label" field.
func (m *SystemComponentSignalMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *SystemComponentSignalMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the SystemComponentSignal entity.
// If the SystemComponentSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentSignalMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *SystemComponentSignalMutation) ResetLabel() {
	m.label = nil
}

// SetDescription sets the "description" field.
func (m *SystemComponentSignalMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemComponentSignalMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemComponentSignal entity.
// If the SystemComponentSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentSignalMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemComponentSignalMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemcomponentsignal.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemComponentSignalMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemcomponentsignal.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemComponentSignalMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemcomponentsignal.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemComponentSignalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemComponentSignalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemComponentSignal entity.
// If the SystemComponentSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemComponentSignalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemComponentSignalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemComponentSignalMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemcomponentsignal.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemComponentSignalMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemComponentSignalMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemComponentSignalMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearComponent clears the "component" edge to the SystemComponent entity.
func (m *SystemComponentSignalMutation) ClearComponent() {
	m.clearedcomponent = true
	m.clearedFields[systemcomponentsignal.FieldComponentID] = struct{}{}
}

// ComponentCleared reports if the "component" edge to the SystemComponent entity was cleared.
func (m *SystemComponentSignalMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *SystemComponentSignalMutation) ComponentIDs() (ids []uuid.UUID) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *SystemComponentSignalMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// AddRelationshipIDs adds the "relationships" edge to the SystemComponentRelationship entity by ids.
func (m *SystemComponentSignalMutation) AddRelationshipIDs(ids ...uuid.UUID) {
	if m.relationships == nil {
		m.relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.relationships[ids[i]] = struct{}{}
	}
}

// ClearRelationships clears the "relationships" edge to the SystemComponentRelationship entity.
func (m *SystemComponentSignalMutation) ClearRelationships() {
	m.clearedrelationships = true
}

// RelationshipsCleared reports if the "relationships" edge to the SystemComponentRelationship entity was cleared.
func (m *SystemComponentSignalMutation) RelationshipsCleared() bool {
	return m.clearedrelationships
}

// RemoveRelationshipIDs removes the "relationships" edge to the SystemComponentRelationship entity by IDs.
func (m *SystemComponentSignalMutation) RemoveRelationshipIDs(ids ...uuid.UUID) {
	if m.removedrelationships == nil {
		m.removedrelationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.relationships, ids[i])
		m.removedrelationships[ids[i]] = struct{}{}
	}
}

// RemovedRelationships returns the removed IDs of the "relationships" edge to the SystemComponentRelationship entity.
func (m *SystemComponentSignalMutation) RemovedRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedrelationships {
		ids = append(ids, id)
	}
	return
}

// RelationshipsIDs returns the "relationships" edge IDs in the mutation.
func (m *SystemComponentSignalMutation) RelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.relationships {
		ids = append(ids, id)
	}
	return
}

// ResetRelationships resets all changes to the "relationships" edge.
func (m *SystemComponentSignalMutation) ResetRelationships() {
	m.relationships = nil
	m.clearedrelationships = false
	m.removedrelationships = nil
}

// AddFeedbackSignalIDs adds the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity by ids.
func (m *SystemComponentSignalMutation) AddFeedbackSignalIDs(ids ...uuid.UUID) {
	if m.feedback_signals == nil {
		m.feedback_signals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.feedback_signals[ids[i]] = struct{}{}
	}
}

// ClearFeedbackSignals clears the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity.
func (m *SystemComponentSignalMutation) ClearFeedbackSignals() {
	m.clearedfeedback_signals = true
}

// FeedbackSignalsCleared reports if the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity was cleared.
func (m *SystemComponentSignalMutation) FeedbackSignalsCleared() bool {
	return m.clearedfeedback_signals
}

// RemoveFeedbackSignalIDs removes the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity by IDs.
func (m *SystemComponentSignalMutation) RemoveFeedbackSignalIDs(ids ...uuid.UUID) {
	if m.removedfeedback_signals == nil {
		m.removedfeedback_signals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.feedback_signals, ids[i])
		m.removedfeedback_signals[ids[i]] = struct{}{}
	}
}

// RemovedFeedbackSignals returns the removed IDs of the "feedback_signals" edge to the SystemRelationshipFeedbackSignal entity.
func (m *SystemComponentSignalMutation) RemovedFeedbackSignalsIDs() (ids []uuid.UUID) {
	for id := range m.removedfeedback_signals {
		ids = append(ids, id)
	}
	return
}

// FeedbackSignalsIDs returns the "feedback_signals" edge IDs in the mutation.
func (m *SystemComponentSignalMutation) FeedbackSignalsIDs() (ids []uuid.UUID) {
	for id := range m.feedback_signals {
		ids = append(ids, id)
	}
	return
}

// ResetFeedbackSignals resets all changes to the "feedback_signals" edge.
func (m *SystemComponentSignalMutation) ResetFeedbackSignals() {
	m.feedback_signals = nil
	m.clearedfeedback_signals = false
	m.removedfeedback_signals = nil
}

// Where appends a list predicates to the SystemComponentSignalMutation builder.
func (m *SystemComponentSignalMutation) Where(ps ...predicate.SystemComponentSignal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemComponentSignalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemComponentSignalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemComponentSignal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemComponentSignalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemComponentSignalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemComponentSignal).
func (m *SystemComponentSignalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemComponentSignalMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, systemcomponentsignal.FieldTenantID)
	}
	if m.component != nil {
		fields = append(fields, systemcomponentsignal.FieldComponentID)
	}
	if m.label != nil {
		fields = append(fields, systemcomponentsignal.FieldLabel)
	}
	if m.description != nil {
		fields = append(fields, systemcomponentsignal.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemcomponentsignal.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemComponentSignalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcomponentsignal.FieldTenantID:
		return m.TenantID()
	case systemcomponentsignal.FieldComponentID:
		return m.ComponentID()
	case systemcomponentsignal.FieldLabel:
		return m.Label()
	case systemcomponentsignal.FieldDescription:
		return m.Description()
	case systemcomponentsignal.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemComponentSignalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcomponentsignal.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemcomponentsignal.FieldComponentID:
		return m.OldComponentID(ctx)
	case systemcomponentsignal.FieldLabel:
		return m.OldLabel(ctx)
	case systemcomponentsignal.FieldDescription:
		return m.OldDescription(ctx)
	case systemcomponentsignal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemComponentSignal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentSignalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcomponentsignal.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemcomponentsignal.FieldComponentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponentID(v)
		return nil
	case systemcomponentsignal.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case systemcomponentsignal.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemcomponentsignal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemComponentSignal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemComponentSignalMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemComponentSignalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemComponentSignalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemComponentSignal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemComponentSignalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemcomponentsignal.FieldDescription) {
		fields = append(fields, systemcomponentsignal.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemComponentSignalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemComponentSignalMutation) ClearField(name string) error {
	switch name {
	case systemcomponentsignal.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentSignal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemComponentSignalMutation) ResetField(name string) error {
	switch name {
	case systemcomponentsignal.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemcomponentsignal.FieldComponentID:
		m.ResetComponentID()
		return nil
	case systemcomponentsignal.FieldLabel:
		m.ResetLabel()
		return nil
	case systemcomponentsignal.FieldDescription:
		m.ResetDescription()
		return nil
	case systemcomponentsignal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentSignal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemComponentSignalMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, systemcomponentsignal.EdgeTenant)
	}
	if m.component != nil {
		edges = append(edges, systemcomponentsignal.EdgeComponent)
	}
	if m.relationships != nil {
		edges = append(edges, systemcomponentsignal.EdgeRelationships)
	}
	if m.feedback_signals != nil {
		edges = append(edges, systemcomponentsignal.EdgeFeedbackSignals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemComponentSignalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentsignal.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentsignal.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	case systemcomponentsignal.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.relationships))
		for id := range m.relationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentsignal.EdgeFeedbackSignals:
		ids := make([]ent.Value, 0, len(m.feedback_signals))
		for id := range m.feedback_signals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemComponentSignalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrelationships != nil {
		edges = append(edges, systemcomponentsignal.EdgeRelationships)
	}
	if m.removedfeedback_signals != nil {
		edges = append(edges, systemcomponentsignal.EdgeFeedbackSignals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemComponentSignalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemcomponentsignal.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.removedrelationships))
		for id := range m.removedrelationships {
			ids = append(ids, id)
		}
		return ids
	case systemcomponentsignal.EdgeFeedbackSignals:
		ids := make([]ent.Value, 0, len(m.removedfeedback_signals))
		for id := range m.removedfeedback_signals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemComponentSignalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, systemcomponentsignal.EdgeTenant)
	}
	if m.clearedcomponent {
		edges = append(edges, systemcomponentsignal.EdgeComponent)
	}
	if m.clearedrelationships {
		edges = append(edges, systemcomponentsignal.EdgeRelationships)
	}
	if m.clearedfeedback_signals {
		edges = append(edges, systemcomponentsignal.EdgeFeedbackSignals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemComponentSignalMutation) EdgeCleared(name string) bool {
	switch name {
	case systemcomponentsignal.EdgeTenant:
		return m.clearedtenant
	case systemcomponentsignal.EdgeComponent:
		return m.clearedcomponent
	case systemcomponentsignal.EdgeRelationships:
		return m.clearedrelationships
	case systemcomponentsignal.EdgeFeedbackSignals:
		return m.clearedfeedback_signals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemComponentSignalMutation) ClearEdge(name string) error {
	switch name {
	case systemcomponentsignal.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemcomponentsignal.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentSignal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemComponentSignalMutation) ResetEdge(name string) error {
	switch name {
	case systemcomponentsignal.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemcomponentsignal.EdgeComponent:
		m.ResetComponent()
		return nil
	case systemcomponentsignal.EdgeRelationships:
		m.ResetRelationships()
		return nil
	case systemcomponentsignal.EdgeFeedbackSignals:
		m.ResetFeedbackSignals()
		return nil
	}
	return fmt.Errorf("unknown SystemComponentSignal edge %s", name)
}

// SystemHazardMutation represents an operation that mutates the SystemHazard nodes in the graph.
type SystemHazardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	external_id          *string
	name                 *string
	description          *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	components           map[uuid.UUID]struct{}
	removedcomponents    map[uuid.UUID]struct{}
	clearedcomponents    bool
	constraints          map[uuid.UUID]struct{}
	removedconstraints   map[uuid.UUID]struct{}
	clearedconstraints   bool
	relationships        map[uuid.UUID]struct{}
	removedrelationships map[uuid.UUID]struct{}
	clearedrelationships bool
	done                 bool
	oldValue             func(context.Context) (*SystemHazard, error)
	predicates           []predicate.SystemHazard
}

var _ ent.Mutation = (*SystemHazardMutation)(nil)

// systemhazardOption allows management of the mutation configuration using functional options.
type systemhazardOption func(*SystemHazardMutation)

// newSystemHazardMutation creates new mutation for the SystemHazard entity.
func newSystemHazardMutation(c config, op Op, opts ...systemhazardOption) *SystemHazardMutation {
	m := &SystemHazardMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemHazard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemHazardID sets the ID field of the mutation.
func withSystemHazardID(id uuid.UUID) systemhazardOption {
	return func(m *SystemHazardMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemHazard
		)
		m.oldValue = func(ctx context.Context) (*SystemHazard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemHazard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemHazard sets the old SystemHazard of the mutation.
func withSystemHazard(node *SystemHazard) systemhazardOption {
	return func(m *SystemHazardMutation) {
		m.oldValue = func(context.Context) (*SystemHazard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemHazardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemHazardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemHazard entities.
func (m *SystemHazardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemHazardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemHazardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemHazard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemHazardMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemHazardMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemHazard entity.
// If the SystemHazard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemHazardMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemHazardMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *SystemHazardMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SystemHazardMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the SystemHazard entity.
// If the SystemHazard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemHazardMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *SystemHazardMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[systemhazard.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *SystemHazardMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[systemhazard.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SystemHazardMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, systemhazard.FieldExternalID)
}

// SetName sets the "name" field.
func (m *SystemHazardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemHazardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SystemHazard entity.
// If the SystemHazard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemHazardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemHazardMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SystemHazardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemHazardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemHazard entity.
// If the SystemHazard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemHazardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemHazardMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemHazardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemHazardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemHazard entity.
// If the SystemHazard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemHazardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemHazardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemHazardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemHazardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemHazard entity.
// If the SystemHazard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemHazardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemHazardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemHazardMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemhazard.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemHazardMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemHazardMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemHazardMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddComponentIDs adds the "components" edge to the SystemComponent entity by ids.
func (m *SystemHazardMutation) AddComponentIDs(ids ...uuid.UUID) {
	if m.components == nil {
		m.components = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the SystemComponent entity.
func (m *SystemHazardMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the SystemComponent entity was cleared.
func (m *SystemHazardMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the SystemComponent entity by IDs.
func (m *SystemHazardMutation) RemoveComponentIDs(ids ...uuid.UUID) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the SystemComponent entity.
func (m *SystemHazardMutation) RemovedComponentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *SystemHazardMutation) ComponentsIDs() (ids []uuid.UUID) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *SystemHazardMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddConstraintIDs adds the "constraints" edge to the SystemComponentConstraint entity by ids.
func (m *SystemHazardMutation) AddConstraintIDs(ids ...uuid.UUID) {
	if m.constraints == nil {
		m.constraints = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.constraints[ids[i]] = struct{}{}
	}
}

// ClearConstraints clears the "constraints" edge to the SystemComponentConstraint entity.
func (m *SystemHazardMutation) ClearConstraints() {
	m.clearedconstraints = true
}

// ConstraintsCleared reports if the "constraints" edge to the SystemComponentConstraint entity was cleared.
func (m *SystemHazardMutation) ConstraintsCleared() bool {
	return m.clearedconstraints
}

// RemoveConstraintIDs removes the "constraints" edge to the SystemComponentConstraint entity by IDs.
func (m *SystemHazardMutation) RemoveConstraintIDs(ids ...uuid.UUID) {
	if m.removedconstraints == nil {
		m.removedconstraints = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.constraints, ids[i])
		m.removedconstraints[ids[i]] = struct{}{}
	}
}

// RemovedConstraints returns the removed IDs of the "constraints" edge to the SystemComponentConstraint entity.
func (m *SystemHazardMutation) RemovedConstraintsIDs() (ids []uuid.UUID) {
	for id := range m.removedconstraints {
		ids = append(ids, id)
	}
	return
}

// ConstraintsIDs returns the "constraints" edge IDs in the mutation.
func (m *SystemHazardMutation) ConstraintsIDs() (ids []uuid.UUID) {
	for id := range m.constraints {
		ids = append(ids, id)
	}
	return
}

// ResetConstraints resets all changes to the "constraints" edge.
func (m *SystemHazardMutation) ResetConstraints() {
	m.constraints = nil
	m.clearedconstraints = false
	m.removedconstraints = nil
}

// AddRelationshipIDs adds the "relationships" edge to the SystemComponentRelationship entity by ids.
func (m *SystemHazardMutation) AddRelationshipIDs(ids ...uuid.UUID) {
	if m.relationships == nil {
		m.relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.relationships[ids[i]] = struct{}{}
	}
}

// ClearRelationships clears the "relationships" edge to the SystemComponentRelationship entity.
func (m *SystemHazardMutation) ClearRelationships() {
	m.clearedrelationships = true
}

// RelationshipsCleared reports if the "relationships" edge to the SystemComponentRelationship entity was cleared.
func (m *SystemHazardMutation) RelationshipsCleared() bool {
	return m.clearedrelationships
}

// RemoveRelationshipIDs removes the "relationships" edge to the SystemComponentRelationship entity by IDs.
func (m *SystemHazardMutation) RemoveRelationshipIDs(ids ...uuid.UUID) {
	if m.removedrelationships == nil {
		m.removedrelationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.relationships, ids[i])
		m.removedrelationships[ids[i]] = struct{}{}
	}
}

// RemovedRelationships returns the removed IDs of the "relationships" edge to the SystemComponentRelationship entity.
func (m *SystemHazardMutation) RemovedRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedrelationships {
		ids = append(ids, id)
	}
	return
}

// RelationshipsIDs returns the "relationships" edge IDs in the mutation.
func (m *SystemHazardMutation) RelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.relationships {
		ids = append(ids, id)
	}
	return
}

// ResetRelationships resets all changes to the "relationships" edge.
func (m *SystemHazardMutation) ResetRelationships() {
	m.relationships = nil
	m.clearedrelationships = false
	m.removedrelationships = nil
}

// Where appends a list predicates to the SystemHazardMutation builder.
func (m *SystemHazardMutation) Where(ps ...predicate.SystemHazard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemHazardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemHazardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemHazard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemHazardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemHazardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemHazard).
func (m *SystemHazardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemHazardMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, systemhazard.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, systemhazard.FieldExternalID)
	}
	if m.name != nil {
		fields = append(fields, systemhazard.FieldName)
	}
	if m.description != nil {
		fields = append(fields, systemhazard.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemhazard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systemhazard.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemHazardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemhazard.FieldTenantID:
		return m.TenantID()
	case systemhazard.FieldExternalID:
		return m.ExternalID()
	case systemhazard.FieldName:
		return m.Name()
	case systemhazard.FieldDescription:
		return m.Description()
	case systemhazard.FieldCreatedAt:
		return m.CreatedAt()
	case systemhazard.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemHazardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemhazard.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemhazard.FieldExternalID:
		return m.OldExternalID(ctx)
	case systemhazard.FieldName:
		return m.OldName(ctx)
	case systemhazard.FieldDescription:
		return m.OldDescription(ctx)
	case systemhazard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemhazard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemHazard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemHazardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemhazard.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemhazard.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case systemhazard.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case systemhazard.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemhazard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemhazard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemHazard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemHazardMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemHazardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemHazardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemHazard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemHazardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemhazard.FieldExternalID) {
		fields = append(fields, systemhazard.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemHazardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemHazardMutation) ClearField(name string) error {
	switch name {
	case systemhazard.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown SystemHazard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemHazardMutation) ResetField(name string) error {
	switch name {
	case systemhazard.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemhazard.FieldExternalID:
		m.ResetExternalID()
		return nil
	case systemhazard.FieldName:
		m.ResetName()
		return nil
	case systemhazard.FieldDescription:
		m.ResetDescription()
		return nil
	case systemhazard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemhazard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemHazard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemHazardMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, systemhazard.EdgeTenant)
	}
	if m.components != nil {
		edges = append(edges, systemhazard.EdgeComponents)
	}
	if m.constraints != nil {
		edges = append(edges, systemhazard.EdgeConstraints)
	}
	if m.relationships != nil {
		edges = append(edges, systemhazard.EdgeRelationships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemHazardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemhazard.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemhazard.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case systemhazard.EdgeConstraints:
		ids := make([]ent.Value, 0, len(m.constraints))
		for id := range m.constraints {
			ids = append(ids, id)
		}
		return ids
	case systemhazard.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.relationships))
		for id := range m.relationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemHazardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomponents != nil {
		edges = append(edges, systemhazard.EdgeComponents)
	}
	if m.removedconstraints != nil {
		edges = append(edges, systemhazard.EdgeConstraints)
	}
	if m.removedrelationships != nil {
		edges = append(edges, systemhazard.EdgeRelationships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemHazardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case systemhazard.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case systemhazard.EdgeConstraints:
		ids := make([]ent.Value, 0, len(m.removedconstraints))
		for id := range m.removedconstraints {
			ids = append(ids, id)
		}
		return ids
	case systemhazard.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.removedrelationships))
		for id := range m.removedrelationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemHazardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, systemhazard.EdgeTenant)
	}
	if m.clearedcomponents {
		edges = append(edges, systemhazard.EdgeComponents)
	}
	if m.clearedconstraints {
		edges = append(edges, systemhazard.EdgeConstraints)
	}
	if m.clearedrelationships {
		edges = append(edges, systemhazard.EdgeRelationships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemHazardMutation) EdgeCleared(name string) bool {
	switch name {
	case systemhazard.EdgeTenant:
		return m.clearedtenant
	case systemhazard.EdgeComponents:
		return m.clearedcomponents
	case systemhazard.EdgeConstraints:
		return m.clearedconstraints
	case systemhazard.EdgeRelationships:
		return m.clearedrelationships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemHazardMutation) ClearEdge(name string) error {
	switch name {
	case systemhazard.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SystemHazard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemHazardMutation) ResetEdge(name string) error {
	switch name {
	case systemhazard.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemhazard.EdgeComponents:
		m.ResetComponents()
		return nil
	case systemhazard.EdgeConstraints:
		m.ResetConstraints()
		return nil
	case systemhazard.EdgeRelationships:
		m.ResetRelationships()
		return nil
	}
	return fmt.Errorf("unknown SystemHazard edge %s", name)
}

// SystemRelationshipControlActionMutation represents an operation that mutates the SystemRelationshipControlAction nodes in the graph.
type SystemRelationshipControlActionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	description         *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	relationship        *uuid.UUID
	clearedrelationship bool
	control             *uuid.UUID
	clearedcontrol      bool
	done                bool
	oldValue            func(context.Context) (*SystemRelationshipControlAction, error)
	predicates          []predicate.SystemRelationshipControlAction
}

var _ ent.Mutation = (*SystemRelationshipControlActionMutation)(nil)

// systemrelationshipcontrolactionOption allows management of the mutation configuration using functional options.
type systemrelationshipcontrolactionOption func(*SystemRelationshipControlActionMutation)

// newSystemRelationshipControlActionMutation creates new mutation for the SystemRelationshipControlAction entity.
func newSystemRelationshipControlActionMutation(c config, op Op, opts ...systemrelationshipcontrolactionOption) *SystemRelationshipControlActionMutation {
	m := &SystemRelationshipControlActionMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemRelationshipControlAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemRelationshipControlActionID sets the ID field of the mutation.
func withSystemRelationshipControlActionID(id uuid.UUID) systemrelationshipcontrolactionOption {
	return func(m *SystemRelationshipControlActionMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemRelationshipControlAction
		)
		m.oldValue = func(ctx context.Context) (*SystemRelationshipControlAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemRelationshipControlAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemRelationshipControlAction sets the old SystemRelationshipControlAction of the mutation.
func withSystemRelationshipControlAction(node *SystemRelationshipControlAction) systemrelationshipcontrolactionOption {
	return func(m *SystemRelationshipControlActionMutation) {
		m.oldValue = func(context.Context) (*SystemRelationshipControlAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemRelationshipControlActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemRelationshipControlActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemRelationshipControlAction entities.
func (m *SystemRelationshipControlActionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemRelationshipControlActionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemRelationshipControlActionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemRelationshipControlAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemRelationshipControlActionMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemRelationshipControlActionMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemRelationshipControlAction entity.
// If the SystemRelationshipControlAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipControlActionMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemRelationshipControlActionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRelationshipID sets the "relationship_id" field.
func (m *SystemRelationshipControlActionMutation) SetRelationshipID(u uuid.UUID) {
	m.relationship = &u
}

// RelationshipID returns the value of the "relationship_id" field in the mutation.
func (m *SystemRelationshipControlActionMutation) RelationshipID() (r uuid.UUID, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipID returns the old "relationship_id" field's value of the SystemRelationshipControlAction entity.
// If the SystemRelationshipControlAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipControlActionMutation) OldRelationshipID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipID: %w", err)
	}
	return oldValue.RelationshipID, nil
}

// ResetRelationshipID resets all changes to the "relationship_id" field.
func (m *SystemRelationshipControlActionMutation) ResetRelationshipID() {
	m.relationship = nil
}

// SetControlID sets the "control_id" field.
func (m *SystemRelationshipControlActionMutation) SetControlID(u uuid.UUID) {
	m.control = &u
}

// ControlID returns the value of the "control_id" field in the mutation.
func (m *SystemRelationshipControlActionMutation) ControlID() (r uuid.UUID, exists bool) {
	v := m.control
	if v == nil {
		return
	}
	return *v, true
}

// OldControlID returns the old "control_id" field's value of the SystemRelationshipControlAction entity.
// If the SystemRelationshipControlAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipControlActionMutation) OldControlID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlID: %w", err)
	}
	return oldValue.ControlID, nil
}

// ResetControlID resets all changes to the "control_id" field.
func (m *SystemRelationshipControlActionMutation) ResetControlID() {
	m.control = nil
}

// SetName sets the "name" field.
func (m *SystemRelationshipControlActionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemRelationshipControlActionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SystemRelationshipControlAction entity.
// If the SystemRelationshipControlAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipControlActionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemRelationshipControlActionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SystemRelationshipControlActionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemRelationshipControlActionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemRelationshipControlAction entity.
// If the SystemRelationshipControlAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipControlActionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemRelationshipControlActionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemrelationshipcontrolaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemRelationshipControlActionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemrelationshipcontrolaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemRelationshipControlActionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemrelationshipcontrolaction.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemRelationshipControlActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemRelationshipControlActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemRelationshipControlAction entity.
// If the SystemRelationshipControlAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipControlActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemRelationshipControlActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemRelationshipControlActionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemrelationshipcontrolaction.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemRelationshipControlActionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemRelationshipControlActionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemRelationshipControlActionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearRelationship clears the "relationship" edge to the SystemComponentRelationship entity.
func (m *SystemRelationshipControlActionMutation) ClearRelationship() {
	m.clearedrelationship = true
	m.clearedFields[systemrelationshipcontrolaction.FieldRelationshipID] = struct{}{}
}

// RelationshipCleared reports if the "relationship" edge to the SystemComponentRelationship entity was cleared.
func (m *SystemRelationshipControlActionMutation) RelationshipCleared() bool {
	return m.clearedrelationship
}

// RelationshipIDs returns the "relationship" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RelationshipID instead. It exists only for internal usage by the builders.
func (m *SystemRelationshipControlActionMutation) RelationshipIDs() (ids []uuid.UUID) {
	if id := m.relationship; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelationship resets all changes to the "relationship" edge.
func (m *SystemRelationshipControlActionMutation) ResetRelationship() {
	m.relationship = nil
	m.clearedrelationship = false
}

// ClearControl clears the "control" edge to the SystemComponentControl entity.
func (m *SystemRelationshipControlActionMutation) ClearControl() {
	m.clearedcontrol = true
	m.clearedFields[systemrelationshipcontrolaction.FieldControlID] = struct{}{}
}

// ControlCleared reports if the "control" edge to the SystemComponentControl entity was cleared.
func (m *SystemRelationshipControlActionMutation) ControlCleared() bool {
	return m.clearedcontrol
}

// ControlIDs returns the "control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ControlID instead. It exists only for internal usage by the builders.
func (m *SystemRelationshipControlActionMutation) ControlIDs() (ids []uuid.UUID) {
	if id := m.control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetControl resets all changes to the "control" edge.
func (m *SystemRelationshipControlActionMutation) ResetControl() {
	m.control = nil
	m.clearedcontrol = false
}

// Where appends a list predicates to the SystemRelationshipControlActionMutation builder.
func (m *SystemRelationshipControlActionMutation) Where(ps ...predicate.SystemRelationshipControlAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemRelationshipControlActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemRelationshipControlActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemRelationshipControlAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemRelationshipControlActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemRelationshipControlActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemRelationshipControlAction).
func (m *SystemRelationshipControlActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemRelationshipControlActionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, systemrelationshipcontrolaction.FieldTenantID)
	}
	if m.relationship != nil {
		fields = append(fields, systemrelationshipcontrolaction.FieldRelationshipID)
	}
	if m.control != nil {
		fields = append(fields, systemrelationshipcontrolaction.FieldControlID)
	}
	if m.name != nil {
		fields = append(fields, systemrelationshipcontrolaction.FieldName)
	}
	if m.description != nil {
		fields = append(fields, systemrelationshipcontrolaction.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemrelationshipcontrolaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemRelationshipControlActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemrelationshipcontrolaction.FieldTenantID:
		return m.TenantID()
	case systemrelationshipcontrolaction.FieldRelationshipID:
		return m.RelationshipID()
	case systemrelationshipcontrolaction.FieldControlID:
		return m.ControlID()
	case systemrelationshipcontrolaction.FieldName:
		return m.Name()
	case systemrelationshipcontrolaction.FieldDescription:
		return m.Description()
	case systemrelationshipcontrolaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemRelationshipControlActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemrelationshipcontrolaction.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemrelationshipcontrolaction.FieldRelationshipID:
		return m.OldRelationshipID(ctx)
	case systemrelationshipcontrolaction.FieldControlID:
		return m.OldControlID(ctx)
	case systemrelationshipcontrolaction.FieldName:
		return m.OldName(ctx)
	case systemrelationshipcontrolaction.FieldDescription:
		return m.OldDescription(ctx)
	case systemrelationshipcontrolaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemRelationshipControlAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemRelationshipControlActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemrelationshipcontrolaction.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemrelationshipcontrolaction.FieldRelationshipID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipID(v)
		return nil
	case systemrelationshipcontrolaction.FieldControlID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlID(v)
		return nil
	case systemrelationshipcontrolaction.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case systemrelationshipcontrolaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemrelationshipcontrolaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipControlAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemRelationshipControlActionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemRelationshipControlActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemRelationshipControlActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemRelationshipControlAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemRelationshipControlActionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemrelationshipcontrolaction.FieldDescription) {
		fields = append(fields, systemrelationshipcontrolaction.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemRelationshipControlActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemRelationshipControlActionMutation) ClearField(name string) error {
	switch name {
	case systemrelationshipcontrolaction.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipControlAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemRelationshipControlActionMutation) ResetField(name string) error {
	switch name {
	case systemrelationshipcontrolaction.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemrelationshipcontrolaction.FieldRelationshipID:
		m.ResetRelationshipID()
		return nil
	case systemrelationshipcontrolaction.FieldControlID:
		m.ResetControlID()
		return nil
	case systemrelationshipcontrolaction.FieldName:
		m.ResetName()
		return nil
	case systemrelationshipcontrolaction.FieldDescription:
		m.ResetDescription()
		return nil
	case systemrelationshipcontrolaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipControlAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemRelationshipControlActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, systemrelationshipcontrolaction.EdgeTenant)
	}
	if m.relationship != nil {
		edges = append(edges, systemrelationshipcontrolaction.EdgeRelationship)
	}
	if m.control != nil {
		edges = append(edges, systemrelationshipcontrolaction.EdgeControl)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemRelationshipControlActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemrelationshipcontrolaction.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemrelationshipcontrolaction.EdgeRelationship:
		if id := m.relationship; id != nil {
			return []ent.Value{*id}
		}
	case systemrelationshipcontrolaction.EdgeControl:
		if id := m.control; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemRelationshipControlActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemRelationshipControlActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemRelationshipControlActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, systemrelationshipcontrolaction.EdgeTenant)
	}
	if m.clearedrelationship {
		edges = append(edges, systemrelationshipcontrolaction.EdgeRelationship)
	}
	if m.clearedcontrol {
		edges = append(edges, systemrelationshipcontrolaction.EdgeControl)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemRelationshipControlActionMutation) EdgeCleared(name string) bool {
	switch name {
	case systemrelationshipcontrolaction.EdgeTenant:
		return m.clearedtenant
	case systemrelationshipcontrolaction.EdgeRelationship:
		return m.clearedrelationship
	case systemrelationshipcontrolaction.EdgeControl:
		return m.clearedcontrol
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemRelationshipControlActionMutation) ClearEdge(name string) error {
	switch name {
	case systemrelationshipcontrolaction.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemrelationshipcontrolaction.EdgeRelationship:
		m.ClearRelationship()
		return nil
	case systemrelationshipcontrolaction.EdgeControl:
		m.ClearControl()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipControlAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemRelationshipControlActionMutation) ResetEdge(name string) error {
	switch name {
	case systemrelationshipcontrolaction.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemrelationshipcontrolaction.EdgeRelationship:
		m.ResetRelationship()
		return nil
	case systemrelationshipcontrolaction.EdgeControl:
		m.ResetControl()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipControlAction edge %s", name)
}

// SystemRelationshipFeedbackSignalMutation represents an operation that mutates the SystemRelationshipFeedbackSignal nodes in the graph.
type SystemRelationshipFeedbackSignalMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	description         *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	relationship        *uuid.UUID
	clearedrelationship bool
	signal              *uuid.UUID
	clearedsignal       bool
	done                bool
	oldValue            func(context.Context) (*SystemRelationshipFeedbackSignal, error)
	predicates          []predicate.SystemRelationshipFeedbackSignal
}

var _ ent.Mutation = (*SystemRelationshipFeedbackSignalMutation)(nil)

// systemrelationshipfeedbacksignalOption allows management of the mutation configuration using functional options.
type systemrelationshipfeedbacksignalOption func(*SystemRelationshipFeedbackSignalMutation)

// newSystemRelationshipFeedbackSignalMutation creates new mutation for the SystemRelationshipFeedbackSignal entity.
func newSystemRelationshipFeedbackSignalMutation(c config, op Op, opts ...systemrelationshipfeedbacksignalOption) *SystemRelationshipFeedbackSignalMutation {
	m := &SystemRelationshipFeedbackSignalMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemRelationshipFeedbackSignal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemRelationshipFeedbackSignalID sets the ID field of the mutation.
func withSystemRelationshipFeedbackSignalID(id uuid.UUID) systemrelationshipfeedbacksignalOption {
	return func(m *SystemRelationshipFeedbackSignalMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemRelationshipFeedbackSignal
		)
		m.oldValue = func(ctx context.Context) (*SystemRelationshipFeedbackSignal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemRelationshipFeedbackSignal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemRelationshipFeedbackSignal sets the old SystemRelationshipFeedbackSignal of the mutation.
func withSystemRelationshipFeedbackSignal(node *SystemRelationshipFeedbackSignal) systemrelationshipfeedbacksignalOption {
	return func(m *SystemRelationshipFeedbackSignalMutation) {
		m.oldValue = func(context.Context) (*SystemRelationshipFeedbackSignal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemRelationshipFeedbackSignalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemRelationshipFeedbackSignalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemRelationshipFeedbackSignal entities.
func (m *SystemRelationshipFeedbackSignalMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemRelationshipFeedbackSignalMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemRelationshipFeedbackSignalMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemRelationshipFeedbackSignal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemRelationshipFeedbackSignalMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemRelationshipFeedbackSignalMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemRelationshipFeedbackSignal entity.
// If the SystemRelationshipFeedbackSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipFeedbackSignalMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemRelationshipFeedbackSignalMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRelationshipID sets the "relationship_id" field.
func (m *SystemRelationshipFeedbackSignalMutation) SetRelationshipID(u uuid.UUID) {
	m.relationship = &u
}

// RelationshipID returns the value of the "relationship_id" field in the mutation.
func (m *SystemRelationshipFeedbackSignalMutation) RelationshipID() (r uuid.UUID, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipID returns the old "relationship_id" field's value of the SystemRelationshipFeedbackSignal entity.
// If the SystemRelationshipFeedbackSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipFeedbackSignalMutation) OldRelationshipID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipID: %w", err)
	}
	return oldValue.RelationshipID, nil
}

// ResetRelationshipID resets all changes to the "relationship_id" field.
func (m *SystemRelationshipFeedbackSignalMutation) ResetRelationshipID() {
	m.relationship = nil
}

// SetSignalID sets the "signal_id" field.
func (m *SystemRelationshipFeedbackSignalMutation) SetSignalID(u uuid.UUID) {
	m.signal = &u
}

// SignalID returns the value of the "signal_id" field in the mutation.
func (m *SystemRelationshipFeedbackSignalMutation) SignalID() (r uuid.UUID, exists bool) {
	v := m.signal
	if v == nil {
		return
	}
	return *v, true
}

// OldSignalID returns the old "signal_id" field's value of the SystemRelationshipFeedbackSignal entity.
// If the SystemRelationshipFeedbackSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipFeedbackSignalMutation) OldSignalID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignalID: %w", err)
	}
	return oldValue.SignalID, nil
}

// ResetSignalID resets all changes to the "signal_id" field.
func (m *SystemRelationshipFeedbackSignalMutation) ResetSignalID() {
	m.signal = nil
}

// SetName sets the "name" field.
func (m *SystemRelationshipFeedbackSignalMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemRelationshipFeedbackSignalMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SystemRelationshipFeedbackSignal entity.
// If the SystemRelationshipFeedbackSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipFeedbackSignalMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemRelationshipFeedbackSignalMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SystemRelationshipFeedbackSignalMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemRelationshipFeedbackSignalMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemRelationshipFeedbackSignal entity.
// If the SystemRelationshipFeedbackSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipFeedbackSignalMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemRelationshipFeedbackSignalMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[systemrelationshipfeedbacksignal.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[systemrelationshipfeedbacksignal.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemRelationshipFeedbackSignalMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, systemrelationshipfeedbacksignal.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemRelationshipFeedbackSignalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemRelationshipFeedbackSignalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemRelationshipFeedbackSignal entity.
// If the SystemRelationshipFeedbackSignal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemRelationshipFeedbackSignalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemRelationshipFeedbackSignalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemRelationshipFeedbackSignalMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemrelationshipfeedbacksignal.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemRelationshipFeedbackSignalMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemRelationshipFeedbackSignalMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemRelationshipFeedbackSignalMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearRelationship clears the "relationship" edge to the SystemComponentRelationship entity.
func (m *SystemRelationshipFeedbackSignalMutation) ClearRelationship() {
	m.clearedrelationship = true
	m.clearedFields[systemrelationshipfeedbacksignal.FieldRelationshipID] = struct{}{}
}

// RelationshipCleared reports if the "relationship" edge to the SystemComponentRelationship entity was cleared.
func (m *SystemRelationshipFeedbackSignalMutation) RelationshipCleared() bool {
	return m.clearedrelationship
}

// RelationshipIDs returns the "relationship" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RelationshipID instead. It exists only for internal usage by the builders.
func (m *SystemRelationshipFeedbackSignalMutation) RelationshipIDs() (ids []uuid.UUID) {
	if id := m.relationship; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelationship resets all changes to the "relationship" edge.
func (m *SystemRelationshipFeedbackSignalMutation) ResetRelationship() {
	m.relationship = nil
	m.clearedrelationship = false
}

// ClearSignal clears the "signal" edge to the SystemComponentSignal entity.
func (m *SystemRelationshipFeedbackSignalMutation) ClearSignal() {
	m.clearedsignal = true
	m.clearedFields[systemrelationshipfeedbacksignal.FieldSignalID] = struct{}{}
}

// SignalCleared reports if the "signal" edge to the SystemComponentSignal entity was cleared.
func (m *SystemRelationshipFeedbackSignalMutation) SignalCleared() bool {
	return m.clearedsignal
}

// SignalIDs returns the "signal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SignalID instead. It exists only for internal usage by the builders.
func (m *SystemRelationshipFeedbackSignalMutation) SignalIDs() (ids []uuid.UUID) {
	if id := m.signal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSignal resets all changes to the "signal" edge.
func (m *SystemRelationshipFeedbackSignalMutation) ResetSignal() {
	m.signal = nil
	m.clearedsignal = false
}

// Where appends a list predicates to the SystemRelationshipFeedbackSignalMutation builder.
func (m *SystemRelationshipFeedbackSignalMutation) Where(ps ...predicate.SystemRelationshipFeedbackSignal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemRelationshipFeedbackSignalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemRelationshipFeedbackSignalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemRelationshipFeedbackSignal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemRelationshipFeedbackSignalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemRelationshipFeedbackSignalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemRelationshipFeedbackSignal).
func (m *SystemRelationshipFeedbackSignalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemRelationshipFeedbackSignalMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, systemrelationshipfeedbacksignal.FieldTenantID)
	}
	if m.relationship != nil {
		fields = append(fields, systemrelationshipfeedbacksignal.FieldRelationshipID)
	}
	if m.signal != nil {
		fields = append(fields, systemrelationshipfeedbacksignal.FieldSignalID)
	}
	if m.name != nil {
		fields = append(fields, systemrelationshipfeedbacksignal.FieldName)
	}
	if m.description != nil {
		fields = append(fields, systemrelationshipfeedbacksignal.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, systemrelationshipfeedbacksignal.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemRelationshipFeedbackSignalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemrelationshipfeedbacksignal.FieldTenantID:
		return m.TenantID()
	case systemrelationshipfeedbacksignal.FieldRelationshipID:
		return m.RelationshipID()
	case systemrelationshipfeedbacksignal.FieldSignalID:
		return m.SignalID()
	case systemrelationshipfeedbacksignal.FieldName:
		return m.Name()
	case systemrelationshipfeedbacksignal.FieldDescription:
		return m.Description()
	case systemrelationshipfeedbacksignal.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemRelationshipFeedbackSignalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemrelationshipfeedbacksignal.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemrelationshipfeedbacksignal.FieldRelationshipID:
		return m.OldRelationshipID(ctx)
	case systemrelationshipfeedbacksignal.FieldSignalID:
		return m.OldSignalID(ctx)
	case systemrelationshipfeedbacksignal.FieldName:
		return m.OldName(ctx)
	case systemrelationshipfeedbacksignal.FieldDescription:
		return m.OldDescription(ctx)
	case systemrelationshipfeedbacksignal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemRelationshipFeedbackSignal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemRelationshipFeedbackSignalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemrelationshipfeedbacksignal.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemrelationshipfeedbacksignal.FieldRelationshipID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipID(v)
		return nil
	case systemrelationshipfeedbacksignal.FieldSignalID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignalID(v)
		return nil
	case systemrelationshipfeedbacksignal.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case systemrelationshipfeedbacksignal.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemrelationshipfeedbacksignal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipFeedbackSignal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemRelationshipFeedbackSignalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemRelationshipFeedbackSignalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemRelationshipFeedbackSignal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemRelationshipFeedbackSignalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemrelationshipfeedbacksignal.FieldDescription) {
		fields = append(fields, systemrelationshipfeedbacksignal.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemRelationshipFeedbackSignalMutation) ClearField(name string) error {
	switch name {
	case systemrelationshipfeedbacksignal.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipFeedbackSignal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemRelationshipFeedbackSignalMutation) ResetField(name string) error {
	switch name {
	case systemrelationshipfeedbacksignal.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemrelationshipfeedbacksignal.FieldRelationshipID:
		m.ResetRelationshipID()
		return nil
	case systemrelationshipfeedbacksignal.FieldSignalID:
		m.ResetSignalID()
		return nil
	case systemrelationshipfeedbacksignal.FieldName:
		m.ResetName()
		return nil
	case systemrelationshipfeedbacksignal.FieldDescription:
		m.ResetDescription()
		return nil
	case systemrelationshipfeedbacksignal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipFeedbackSignal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, systemrelationshipfeedbacksignal.EdgeTenant)
	}
	if m.relationship != nil {
		edges = append(edges, systemrelationshipfeedbacksignal.EdgeRelationship)
	}
	if m.signal != nil {
		edges = append(edges, systemrelationshipfeedbacksignal.EdgeSignal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemrelationshipfeedbacksignal.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case systemrelationshipfeedbacksignal.EdgeRelationship:
		if id := m.relationship; id != nil {
			return []ent.Value{*id}
		}
	case systemrelationshipfeedbacksignal.EdgeSignal:
		if id := m.signal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, systemrelationshipfeedbacksignal.EdgeTenant)
	}
	if m.clearedrelationship {
		edges = append(edges, systemrelationshipfeedbacksignal.EdgeRelationship)
	}
	if m.clearedsignal {
		edges = append(edges, systemrelationshipfeedbacksignal.EdgeSignal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemRelationshipFeedbackSignalMutation) EdgeCleared(name string) bool {
	switch name {
	case systemrelationshipfeedbacksignal.EdgeTenant:
		return m.clearedtenant
	case systemrelationshipfeedbacksignal.EdgeRelationship:
		return m.clearedrelationship
	case systemrelationshipfeedbacksignal.EdgeSignal:
		return m.clearedsignal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemRelationshipFeedbackSignalMutation) ClearEdge(name string) error {
	switch name {
	case systemrelationshipfeedbacksignal.EdgeTenant:
		m.ClearTenant()
		return nil
	case systemrelationshipfeedbacksignal.EdgeRelationship:
		m.ClearRelationship()
		return nil
	case systemrelationshipfeedbacksignal.EdgeSignal:
		m.ClearSignal()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipFeedbackSignal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemRelationshipFeedbackSignalMutation) ResetEdge(name string) error {
	switch name {
	case systemrelationshipfeedbacksignal.EdgeTenant:
		m.ResetTenant()
		return nil
	case systemrelationshipfeedbacksignal.EdgeRelationship:
		m.ResetRelationship()
		return nil
	case systemrelationshipfeedbacksignal.EdgeSignal:
		m.ResetSignal()
		return nil
	}
	return fmt.Errorf("unknown SystemRelationshipFeedbackSignal edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	_type           *task.Type
	title           *string
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	tickets         map[uuid.UUID]struct{}
	removedtickets  map[uuid.UUID]struct{}
	clearedtickets  bool
	incident        *uuid.UUID
	clearedincident bool
	assignee        *uuid.UUID
	clearedassignee bool
	creator         *uuid.UUID
	clearedcreator  bool
	done            bool
	oldValue        func(context.Context) (*Task, error)
	predicates      []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TaskMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TaskMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TaskMutation) ResetTenantID() {
	m.tenant = nil
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(t task.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r task.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v task.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *TaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskMutation) ResetTitle() {
	m.title = nil
}

// SetIncidentID sets the "incident_id" field.
func (m *TaskMutation) SetIncidentID(u uuid.UUID) {
	m.incident = &u
}

// IncidentID returns the value of the "incident_id" field in the mutation.
func (m *TaskMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m.incident
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "incident_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ClearIncidentID clears the value of the "incident_id" field.
func (m *TaskMutation) ClearIncidentID() {
	m.incident = nil
	m.clearedFields[task.FieldIncidentID] = struct{}{}
}

// IncidentIDCleared returns if the "incident_id" field was cleared in this mutation.
func (m *TaskMutation) IncidentIDCleared() bool {
	_, ok := m.clearedFields[task.FieldIncidentID]
	return ok
}

// ResetIncidentID resets all changes to the "incident_id" field.
func (m *TaskMutation) ResetIncidentID() {
	m.incident = nil
	delete(m.clearedFields, task.FieldIncidentID)
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TaskMutation) SetAssigneeID(u uuid.UUID) {
	m.assignee = &u
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TaskMutation) AssigneeID() (r uuid.UUID, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssigneeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TaskMutation) ClearAssigneeID() {
	m.assignee = nil
	m.clearedFields[task.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TaskMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[task.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TaskMutation) ResetAssigneeID() {
	m.assignee = nil
	delete(m.clearedFields, task.FieldAssigneeID)
}

// SetCreatorID sets the "creator_id" field.
func (m *TaskMutation) SetCreatorID(u uuid.UUID) {
	m.creator = &u
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *TaskMutation) CreatorID() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ClearCreatorID clears the value of the "creator_id" field.
func (m *TaskMutation) ClearCreatorID() {
	m.creator = nil
	m.clearedFields[task.FieldCreatorID] = struct{}{}
}

// CreatorIDCleared returns if the "creator_id" field was cleared in this mutation.
func (m *TaskMutation) CreatorIDCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatorID]
	return ok
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *TaskMutation) ResetCreatorID() {
	m.creator = nil
	delete(m.clearedFields, task.FieldCreatorID)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TaskMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[task.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TaskMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TaskMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TaskMutation) AddTicketIDs(ids ...uuid.UUID) {
	if m.tickets == nil {
		m.tickets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TaskMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TaskMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TaskMutation) RemoveTicketIDs(ids ...uuid.UUID) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TaskMutation) RemovedTicketsIDs() (ids []uuid.UUID) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TaskMutation) TicketsIDs() (ids []uuid.UUID) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TaskMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// ClearIncident clears the "incident" edge to the Incident entity.
func (m *TaskMutation) ClearIncident() {
	m.clearedincident = true
	m.clearedFields[task.FieldIncidentID] = struct{}{}
}

// IncidentCleared reports if the "incident" edge to the Incident entity was cleared.
func (m *TaskMutation) IncidentCleared() bool {
	return m.IncidentIDCleared() || m.clearedincident
}

// IncidentIDs returns the "incident" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncidentID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) IncidentIDs() (ids []uuid.UUID) {
	if id := m.incident; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncident resets all changes to the "incident" edge.
func (m *TaskMutation) ResetIncident() {
	m.incident = nil
	m.clearedincident = false
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *TaskMutation) ClearAssignee() {
	m.clearedassignee = true
	m.clearedFields[task.FieldAssigneeID] = struct{}{}
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *TaskMutation) AssigneeCleared() bool {
	return m.AssigneeIDCleared() || m.clearedassignee
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) AssigneeIDs() (ids []uuid.UUID) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *TaskMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *TaskMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[task.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *TaskMutation) CreatorCleared() bool {
	return m.CreatorIDCleared() || m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TaskMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, task.FieldTenantID)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.title != nil {
		fields = append(fields, task.FieldTitle)
	}
	if m.incident != nil {
		fields = append(fields, task.FieldIncidentID)
	}
	if m.assignee != nil {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.creator != nil {
		fields = append(fields, task.FieldCreatorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTenantID:
		return m.TenantID()
	case task.FieldType:
		return m.GetType()
	case task.FieldTitle:
		return m.Title()
	case task.FieldIncidentID:
		return m.IncidentID()
	case task.FieldAssigneeID:
		return m.AssigneeID()
	case task.FieldCreatorID:
		return m.CreatorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldTenantID:
		return m.OldTenantID(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldTitle:
		return m.OldTitle(ctx)
	case task.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case task.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case task.FieldCreatorID:
		return m.OldCreatorID(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case task.FieldType:
		v, ok := value.(task.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case task.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case task.FieldAssigneeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case task.FieldCreatorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldIncidentID) {
		fields = append(fields, task.FieldIncidentID)
	}
	if m.FieldCleared(task.FieldAssigneeID) {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.FieldCleared(task.FieldCreatorID) {
		fields = append(fields, task.FieldCreatorID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldIncidentID:
		m.ClearIncidentID()
		return nil
	case task.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case task.FieldCreatorID:
		m.ClearCreatorID()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldTenantID:
		m.ResetTenantID()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldTitle:
		m.ResetTitle()
		return nil
	case task.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case task.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case task.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, task.EdgeTenant)
	}
	if m.tickets != nil {
		edges = append(edges, task.EdgeTickets)
	}
	if m.incident != nil {
		edges = append(edges, task.EdgeIncident)
	}
	if m.assignee != nil {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.creator != nil {
		edges = append(edges, task.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeIncident:
		if id := m.incident; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtickets != nil {
		edges = append(edges, task.EdgeTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, task.EdgeTenant)
	}
	if m.clearedtickets {
		edges = append(edges, task.EdgeTickets)
	}
	if m.clearedincident {
		edges = append(edges, task.EdgeIncident)
	}
	if m.clearedassignee {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.clearedcreator {
		edges = append(edges, task.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeTenant:
		return m.clearedtenant
	case task.EdgeTickets:
		return m.clearedtickets
	case task.EdgeIncident:
		return m.clearedincident
	case task.EdgeAssignee:
		return m.clearedassignee
	case task.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeTenant:
		m.ClearTenant()
		return nil
	case task.EdgeIncident:
		m.ClearIncident()
		return nil
	case task.EdgeAssignee:
		m.ClearAssignee()
		return nil
	case task.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeTenant:
		m.ResetTenant()
		return nil
	case task.EdgeTickets:
		m.ResetTickets()
		return nil
	case task.EdgeIncident:
		m.ResetIncident()
		return nil
	case task.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case task.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	external_id               *string
	slug                      *string
	name                      *string
	chat_channel_id           *string
	timezone                  *string
	clearedFields             map[string]struct{}
	tenant                    *int
	clearedtenant             bool
	users                     map[uuid.UUID]struct{}
	removedusers              map[uuid.UUID]struct{}
	clearedusers              bool
	oncall_rosters            map[uuid.UUID]struct{}
	removedoncall_rosters     map[uuid.UUID]struct{}
	clearedoncall_rosters     bool
	scheduled_meetings        map[uuid.UUID]struct{}
	removedscheduled_meetings map[uuid.UUID]struct{}
	clearedscheduled_meetings bool
	done                      bool
	oldValue                  func(context.Context) (*Team, error)
	predicates                []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TeamMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TeamMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TeamMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *TeamMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *TeamMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *TeamMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[team.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *TeamMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[team.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *TeamMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, team.FieldExternalID)
}

// SetSlug sets the "slug" field.
func (m *TeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetChatChannelID sets the "chat_channel_id" field.
func (m *TeamMutation) SetChatChannelID(s string) {
	m.chat_channel_id = &s
}

// ChatChannelID returns the value of the "chat_channel_id" field in the mutation.
func (m *TeamMutation) ChatChannelID() (r string, exists bool) {
	v := m.chat_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatChannelID returns the old "chat_channel_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldChatChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatChannelID: %w", err)
	}
	return oldValue.ChatChannelID, nil
}

// ClearChatChannelID clears the value of the "chat_channel_id" field.
func (m *TeamMutation) ClearChatChannelID() {
	m.chat_channel_id = nil
	m.clearedFields[team.FieldChatChannelID] = struct{}{}
}

// ChatChannelIDCleared returns if the "chat_channel_id" field was cleared in this mutation.
func (m *TeamMutation) ChatChannelIDCleared() bool {
	_, ok := m.clearedFields[team.FieldChatChannelID]
	return ok
}

// ResetChatChannelID resets all changes to the "chat_channel_id" field.
func (m *TeamMutation) ResetChatChannelID() {
	m.chat_channel_id = nil
	delete(m.clearedFields, team.FieldChatChannelID)
}

// SetTimezone sets the "timezone" field.
func (m *TeamMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *TeamMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *TeamMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[team.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *TeamMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[team.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *TeamMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, team.FieldTimezone)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TeamMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[team.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TeamMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TeamMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *TeamMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *TeamMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *TeamMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *TeamMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *TeamMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TeamMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddOncallRosterIDs adds the "oncall_rosters" edge to the OncallRoster entity by ids.
func (m *TeamMutation) AddOncallRosterIDs(ids ...uuid.UUID) {
	if m.oncall_rosters == nil {
		m.oncall_rosters = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.oncall_rosters[ids[i]] = struct{}{}
	}
}

// ClearOncallRosters clears the "oncall_rosters" edge to the OncallRoster entity.
func (m *TeamMutation) ClearOncallRosters() {
	m.clearedoncall_rosters = true
}

// OncallRostersCleared reports if the "oncall_rosters" edge to the OncallRoster entity was cleared.
func (m *TeamMutation) OncallRostersCleared() bool {
	return m.clearedoncall_rosters
}

// RemoveOncallRosterIDs removes the "oncall_rosters" edge to the OncallRoster entity by IDs.
func (m *TeamMutation) RemoveOncallRosterIDs(ids ...uuid.UUID) {
	if m.removedoncall_rosters == nil {
		m.removedoncall_rosters = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.oncall_rosters, ids[i])
		m.removedoncall_rosters[ids[i]] = struct{}{}
	}
}

// RemovedOncallRosters returns the removed IDs of the "oncall_rosters" edge to the OncallRoster entity.
func (m *TeamMutation) RemovedOncallRostersIDs() (ids []uuid.UUID) {
	for id := range m.removedoncall_rosters {
		ids = append(ids, id)
	}
	return
}

// OncallRostersIDs returns the "oncall_rosters" edge IDs in the mutation.
func (m *TeamMutation) OncallRostersIDs() (ids []uuid.UUID) {
	for id := range m.oncall_rosters {
		ids = append(ids, id)
	}
	return
}

// ResetOncallRosters resets all changes to the "oncall_rosters" edge.
func (m *TeamMutation) ResetOncallRosters() {
	m.oncall_rosters = nil
	m.clearedoncall_rosters = false
	m.removedoncall_rosters = nil
}

// AddScheduledMeetingIDs adds the "scheduled_meetings" edge to the MeetingSchedule entity by ids.
func (m *TeamMutation) AddScheduledMeetingIDs(ids ...uuid.UUID) {
	if m.scheduled_meetings == nil {
		m.scheduled_meetings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.scheduled_meetings[ids[i]] = struct{}{}
	}
}

// ClearScheduledMeetings clears the "scheduled_meetings" edge to the MeetingSchedule entity.
func (m *TeamMutation) ClearScheduledMeetings() {
	m.clearedscheduled_meetings = true
}

// ScheduledMeetingsCleared reports if the "scheduled_meetings" edge to the MeetingSchedule entity was cleared.
func (m *TeamMutation) ScheduledMeetingsCleared() bool {
	return m.clearedscheduled_meetings
}

// RemoveScheduledMeetingIDs removes the "scheduled_meetings" edge to the MeetingSchedule entity by IDs.
func (m *TeamMutation) RemoveScheduledMeetingIDs(ids ...uuid.UUID) {
	if m.removedscheduled_meetings == nil {
		m.removedscheduled_meetings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.scheduled_meetings, ids[i])
		m.removedscheduled_meetings[ids[i]] = struct{}{}
	}
}

// RemovedScheduledMeetings returns the removed IDs of the "scheduled_meetings" edge to the MeetingSchedule entity.
func (m *TeamMutation) RemovedScheduledMeetingsIDs() (ids []uuid.UUID) {
	for id := range m.removedscheduled_meetings {
		ids = append(ids, id)
	}
	return
}

// ScheduledMeetingsIDs returns the "scheduled_meetings" edge IDs in the mutation.
func (m *TeamMutation) ScheduledMeetingsIDs() (ids []uuid.UUID) {
	for id := range m.scheduled_meetings {
		ids = append(ids, id)
	}
	return
}

// ResetScheduledMeetings resets all changes to the "scheduled_meetings" edge.
func (m *TeamMutation) ResetScheduledMeetings() {
	m.scheduled_meetings = nil
	m.clearedscheduled_meetings = false
	m.removedscheduled_meetings = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, team.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, team.FieldExternalID)
	}
	if m.slug != nil {
		fields = append(fields, team.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.chat_channel_id != nil {
		fields = append(fields, team.FieldChatChannelID)
	}
	if m.timezone != nil {
		fields = append(fields, team.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTenantID:
		return m.TenantID()
	case team.FieldExternalID:
		return m.ExternalID()
	case team.FieldSlug:
		return m.Slug()
	case team.FieldName:
		return m.Name()
	case team.FieldChatChannelID:
		return m.ChatChannelID()
	case team.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldTenantID:
		return m.OldTenantID(ctx)
	case team.FieldExternalID:
		return m.OldExternalID(ctx)
	case team.FieldSlug:
		return m.OldSlug(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldChatChannelID:
		return m.OldChatChannelID(ctx)
	case team.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case team.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case team.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldChatChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatChannelID(v)
		return nil
	case team.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldExternalID) {
		fields = append(fields, team.FieldExternalID)
	}
	if m.FieldCleared(team.FieldChatChannelID) {
		fields = append(fields, team.FieldChatChannelID)
	}
	if m.FieldCleared(team.FieldTimezone) {
		fields = append(fields, team.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldExternalID:
		m.ClearExternalID()
		return nil
	case team.FieldChatChannelID:
		m.ClearChatChannelID()
		return nil
	case team.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldTenantID:
		m.ResetTenantID()
		return nil
	case team.FieldExternalID:
		m.ResetExternalID()
		return nil
	case team.FieldSlug:
		m.ResetSlug()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldChatChannelID:
		m.ResetChatChannelID()
		return nil
	case team.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, team.EdgeTenant)
	}
	if m.users != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.oncall_rosters != nil {
		edges = append(edges, team.EdgeOncallRosters)
	}
	if m.scheduled_meetings != nil {
		edges = append(edges, team.EdgeScheduledMeetings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOncallRosters:
		ids := make([]ent.Value, 0, len(m.oncall_rosters))
		for id := range m.oncall_rosters {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeScheduledMeetings:
		ids := make([]ent.Value, 0, len(m.scheduled_meetings))
		for id := range m.scheduled_meetings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusers != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.removedoncall_rosters != nil {
		edges = append(edges, team.EdgeOncallRosters)
	}
	if m.removedscheduled_meetings != nil {
		edges = append(edges, team.EdgeScheduledMeetings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeOncallRosters:
		ids := make([]ent.Value, 0, len(m.removedoncall_rosters))
		for id := range m.removedoncall_rosters {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeScheduledMeetings:
		ids := make([]ent.Value, 0, len(m.removedscheduled_meetings))
		for id := range m.removedscheduled_meetings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, team.EdgeTenant)
	}
	if m.clearedusers {
		edges = append(edges, team.EdgeUsers)
	}
	if m.clearedoncall_rosters {
		edges = append(edges, team.EdgeOncallRosters)
	}
	if m.clearedscheduled_meetings {
		edges = append(edges, team.EdgeScheduledMeetings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeTenant:
		return m.clearedtenant
	case team.EdgeUsers:
		return m.clearedusers
	case team.EdgeOncallRosters:
		return m.clearedoncall_rosters
	case team.EdgeScheduledMeetings:
		return m.clearedscheduled_meetings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeTenant:
		m.ResetTenant()
		return nil
	case team.EdgeUsers:
		m.ResetUsers()
		return nil
	case team.EdgeOncallRosters:
		m.ResetOncallRosters()
		return nil
	case team.EdgeScheduledMeetings:
		m.ResetScheduledMeetings()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	external_id   *string
	title         *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	tasks         map[uuid.UUID]struct{}
	removedtasks  map[uuid.UUID]struct{}
	clearedtasks  bool
	done          bool
	oldValue      func(context.Context) (*Ticket, error)
	predicates    []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id uuid.UUID) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ticket entities.
func (m *TicketMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TicketMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TicketMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TicketMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *TicketMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *TicketMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *TicketMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[ticket.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *TicketMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[ticket.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *TicketMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, ticket.FieldExternalID)
}

// SetTitle sets the "title" field.
func (m *TicketMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TicketMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TicketMutation) ResetTitle() {
	m.title = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TicketMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[ticket.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TicketMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TicketMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *TicketMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *TicketMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *TicketMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *TicketMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *TicketMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *TicketMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *TicketMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, ticket.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, ticket.FieldExternalID)
	}
	if m.title != nil {
		fields = append(fields, ticket.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldTenantID:
		return m.TenantID()
	case ticket.FieldExternalID:
		return m.ExternalID()
	case ticket.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldTenantID:
		return m.OldTenantID(ctx)
	case ticket.FieldExternalID:
		return m.OldExternalID(ctx)
	case ticket.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ticket.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case ticket.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldExternalID) {
		fields = append(fields, ticket.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ticket.FieldExternalID:
		m.ResetExternalID()
		return nil
	case ticket.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, ticket.EdgeTenant)
	}
	if m.tasks != nil {
		edges = append(edges, ticket.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtasks != nil {
		edges = append(edges, ticket.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, ticket.EdgeTenant)
	}
	if m.clearedtasks {
		edges = append(edges, ticket.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeTenant:
		return m.clearedtenant
	case ticket.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeTenant:
		m.ResetTenant()
		return nil
	case ticket.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *uuid.UUID
	auth_provider_id                      *string
	email                                 *string
	name                                  *string
	chat_id                               *string
	timezone                              *string
	confirmed                             *bool
	clearedFields                         map[string]struct{}
	tenant                                *int
	clearedtenant                         bool
	teams                                 map[uuid.UUID]struct{}
	removedteams                          map[uuid.UUID]struct{}
	clearedteams                          bool
	watched_oncall_rosters                map[uuid.UUID]struct{}
	removedwatched_oncall_rosters         map[uuid.UUID]struct{}
	clearedwatched_oncall_rosters         bool
	oncall_schedules                      map[uuid.UUID]struct{}
	removedoncall_schedules               map[uuid.UUID]struct{}
	clearedoncall_schedules               bool
	oncall_shifts                         map[uuid.UUID]struct{}
	removedoncall_shifts                  map[uuid.UUID]struct{}
	clearedoncall_shifts                  bool
	event_annotations                     map[uuid.UUID]struct{}
	removedevent_annotations              map[uuid.UUID]struct{}
	clearedevent_annotations              bool
	incidents                             map[uuid.UUID]struct{}
	removedincidents                      map[uuid.UUID]struct{}
	clearedincidents                      bool
	incident_debriefs                     map[uuid.UUID]struct{}
	removedincident_debriefs              map[uuid.UUID]struct{}
	clearedincident_debriefs              bool
	assigned_tasks                        map[uuid.UUID]struct{}
	removedassigned_tasks                 map[uuid.UUID]struct{}
	clearedassigned_tasks                 bool
	created_tasks                         map[uuid.UUID]struct{}
	removedcreated_tasks                  map[uuid.UUID]struct{}
	clearedcreated_tasks                  bool
	retrospective_review_requests         map[uuid.UUID]struct{}
	removedretrospective_review_requests  map[uuid.UUID]struct{}
	clearedretrospective_review_requests  bool
	retrospective_review_responses        map[uuid.UUID]struct{}
	removedretrospective_review_responses map[uuid.UUID]struct{}
	clearedretrospective_review_responses bool
	retrospective_comments                map[uuid.UUID]struct{}
	removedretrospective_comments         map[uuid.UUID]struct{}
	clearedretrospective_comments         bool
	role_assignments                      map[uuid.UUID]struct{}
	removedrole_assignments               map[uuid.UUID]struct{}
	clearedrole_assignments               bool
	done                                  bool
	oldValue                              func(context.Context) (*User, error)
	predicates                            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAuthProviderID sets the "auth_provider_id" field.
func (m *UserMutation) SetAuthProviderID(s string) {
	m.auth_provider_id = &s
}

// AuthProviderID returns the value of the "auth_provider_id" field in the mutation.
func (m *UserMutation) AuthProviderID() (r string, exists bool) {
	v := m.auth_provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProviderID returns the old "auth_provider_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProviderID: %w", err)
	}
	return oldValue.AuthProviderID, nil
}

// ClearAuthProviderID clears the value of the "auth_provider_id" field.
func (m *UserMutation) ClearAuthProviderID() {
	m.auth_provider_id = nil
	m.clearedFields[user.FieldAuthProviderID] = struct{}{}
}

// AuthProviderIDCleared returns if the "auth_provider_id" field was cleared in this mutation.
func (m *UserMutation) AuthProviderIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAuthProviderID]
	return ok
}

// ResetAuthProviderID resets all changes to the "auth_provider_id" field.
func (m *UserMutation) ResetAuthProviderID() {
	m.auth_provider_id = nil
	delete(m.clearedFields, user.FieldAuthProviderID)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetChatID sets the "chat_id" field.
func (m *UserMutation) SetChatID(s string) {
	m.chat_id = &s
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *UserMutation) ChatID() (r string, exists bool) {
	v := m.chat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldChatID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ClearChatID clears the value of the "chat_id" field.
func (m *UserMutation) ClearChatID() {
	m.chat_id = nil
	m.clearedFields[user.FieldChatID] = struct{}{}
}

// ChatIDCleared returns if the "chat_id" field was cleared in this mutation.
func (m *UserMutation) ChatIDCleared() bool {
	_, ok := m.clearedFields[user.FieldChatID]
	return ok
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *UserMutation) ResetChatID() {
	m.chat_id = nil
	delete(m.clearedFields, user.FieldChatID)
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *UserMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[user.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *UserMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[user.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, user.FieldTimezone)
}

// SetConfirmed sets the "confirmed" field.
func (m *UserMutation) SetConfirmed(b bool) {
	m.confirmed = &b
}

// Confirmed returns the value of the "confirmed" field in the mutation.
func (m *UserMutation) Confirmed() (r bool, exists bool) {
	v := m.confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmed returns the old "confirmed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmed: %w", err)
	}
	return oldValue.Confirmed, nil
}

// ResetConfirmed resets all changes to the "confirmed" field.
func (m *UserMutation) ResetConfirmed() {
	m.confirmed = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[user.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *UserMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m.teams == nil {
		m.teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *UserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *UserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removedteams == nil {
		m.removedteams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *UserMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *UserMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *UserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddWatchedOncallRosterIDs adds the "watched_oncall_rosters" edge to the OncallRoster entity by ids.
func (m *UserMutation) AddWatchedOncallRosterIDs(ids ...uuid.UUID) {
	if m.watched_oncall_rosters == nil {
		m.watched_oncall_rosters = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.watched_oncall_rosters[ids[i]] = struct{}{}
	}
}

// ClearWatchedOncallRosters clears the "watched_oncall_rosters" edge to the OncallRoster entity.
func (m *UserMutation) ClearWatchedOncallRosters() {
	m.clearedwatched_oncall_rosters = true
}

// WatchedOncallRostersCleared reports if the "watched_oncall_rosters" edge to the OncallRoster entity was cleared.
func (m *UserMutation) WatchedOncallRostersCleared() bool {
	return m.clearedwatched_oncall_rosters
}

// RemoveWatchedOncallRosterIDs removes the "watched_oncall_rosters" edge to the OncallRoster entity by IDs.
func (m *UserMutation) RemoveWatchedOncallRosterIDs(ids ...uuid.UUID) {
	if m.removedwatched_oncall_rosters == nil {
		m.removedwatched_oncall_rosters = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.watched_oncall_rosters, ids[i])
		m.removedwatched_oncall_rosters[ids[i]] = struct{}{}
	}
}

// RemovedWatchedOncallRosters returns the removed IDs of the "watched_oncall_rosters" edge to the OncallRoster entity.
func (m *UserMutation) RemovedWatchedOncallRostersIDs() (ids []uuid.UUID) {
	for id := range m.removedwatched_oncall_rosters {
		ids = append(ids, id)
	}
	return
}

// WatchedOncallRostersIDs returns the "watched_oncall_rosters" edge IDs in the mutation.
func (m *UserMutation) WatchedOncallRostersIDs() (ids []uuid.UUID) {
	for id := range m.watched_oncall_rosters {
		ids = append(ids, id)
	}
	return
}

// ResetWatchedOncallRosters resets all changes to the "watched_oncall_rosters" edge.
func (m *UserMutation) ResetWatchedOncallRosters() {
	m.watched_oncall_rosters = nil
	m.clearedwatched_oncall_rosters = false
	m.removedwatched_oncall_rosters = nil
}

// AddOncallScheduleIDs adds the "oncall_schedules" edge to the OncallScheduleParticipant entity by ids.
func (m *UserMutation) AddOncallScheduleIDs(ids ...uuid.UUID) {
	if m.oncall_schedules == nil {
		m.oncall_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.oncall_schedules[ids[i]] = struct{}{}
	}
}

// ClearOncallSchedules clears the "oncall_schedules" edge to the OncallScheduleParticipant entity.
func (m *UserMutation) ClearOncallSchedules() {
	m.clearedoncall_schedules = true
}

// OncallSchedulesCleared reports if the "oncall_schedules" edge to the OncallScheduleParticipant entity was cleared.
func (m *UserMutation) OncallSchedulesCleared() bool {
	return m.clearedoncall_schedules
}

// RemoveOncallScheduleIDs removes the "oncall_schedules" edge to the OncallScheduleParticipant entity by IDs.
func (m *UserMutation) RemoveOncallScheduleIDs(ids ...uuid.UUID) {
	if m.removedoncall_schedules == nil {
		m.removedoncall_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.oncall_schedules, ids[i])
		m.removedoncall_schedules[ids[i]] = struct{}{}
	}
}

// RemovedOncallSchedules returns the removed IDs of the "oncall_schedules" edge to the OncallScheduleParticipant entity.
func (m *UserMutation) RemovedOncallSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedoncall_schedules {
		ids = append(ids, id)
	}
	return
}

// OncallSchedulesIDs returns the "oncall_schedules" edge IDs in the mutation.
func (m *UserMutation) OncallSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.oncall_schedules {
		ids = append(ids, id)
	}
	return
}

// ResetOncallSchedules resets all changes to the "oncall_schedules" edge.
func (m *UserMutation) ResetOncallSchedules() {
	m.oncall_schedules = nil
	m.clearedoncall_schedules = false
	m.removedoncall_schedules = nil
}

// AddOncallShiftIDs adds the "oncall_shifts" edge to the OncallShift entity by ids.
func (m *UserMutation) AddOncallShiftIDs(ids ...uuid.UUID) {
	if m.oncall_shifts == nil {
		m.oncall_shifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.oncall_shifts[ids[i]] = struct{}{}
	}
}

// ClearOncallShifts clears the "oncall_shifts" edge to the OncallShift entity.
func (m *UserMutation) ClearOncallShifts() {
	m.clearedoncall_shifts = true
}

// OncallShiftsCleared reports if the "oncall_shifts" edge to the OncallShift entity was cleared.
func (m *UserMutation) OncallShiftsCleared() bool {
	return m.clearedoncall_shifts
}

// RemoveOncallShiftIDs removes the "oncall_shifts" edge to the OncallShift entity by IDs.
func (m *UserMutation) RemoveOncallShiftIDs(ids ...uuid.UUID) {
	if m.removedoncall_shifts == nil {
		m.removedoncall_shifts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.oncall_shifts, ids[i])
		m.removedoncall_shifts[ids[i]] = struct{}{}
	}
}

// RemovedOncallShifts returns the removed IDs of the "oncall_shifts" edge to the OncallShift entity.
func (m *UserMutation) RemovedOncallShiftsIDs() (ids []uuid.UUID) {
	for id := range m.removedoncall_shifts {
		ids = append(ids, id)
	}
	return
}

// OncallShiftsIDs returns the "oncall_shifts" edge IDs in the mutation.
func (m *UserMutation) OncallShiftsIDs() (ids []uuid.UUID) {
	for id := range m.oncall_shifts {
		ids = append(ids, id)
	}
	return
}

// ResetOncallShifts resets all changes to the "oncall_shifts" edge.
func (m *UserMutation) ResetOncallShifts() {
	m.oncall_shifts = nil
	m.clearedoncall_shifts = false
	m.removedoncall_shifts = nil
}

// AddEventAnnotationIDs adds the "event_annotations" edge to the EventAnnotation entity by ids.
func (m *UserMutation) AddEventAnnotationIDs(ids ...uuid.UUID) {
	if m.event_annotations == nil {
		m.event_annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.event_annotations[ids[i]] = struct{}{}
	}
}

// ClearEventAnnotations clears the "event_annotations" edge to the EventAnnotation entity.
func (m *UserMutation) ClearEventAnnotations() {
	m.clearedevent_annotations = true
}

// EventAnnotationsCleared reports if the "event_annotations" edge to the EventAnnotation entity was cleared.
func (m *UserMutation) EventAnnotationsCleared() bool {
	return m.clearedevent_annotations
}

// RemoveEventAnnotationIDs removes the "event_annotations" edge to the EventAnnotation entity by IDs.
func (m *UserMutation) RemoveEventAnnotationIDs(ids ...uuid.UUID) {
	if m.removedevent_annotations == nil {
		m.removedevent_annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.event_annotations, ids[i])
		m.removedevent_annotations[ids[i]] = struct{}{}
	}
}

// RemovedEventAnnotations returns the removed IDs of the "event_annotations" edge to the EventAnnotation entity.
func (m *UserMutation) RemovedEventAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.removedevent_annotations {
		ids = append(ids, id)
	}
	return
}

// EventAnnotationsIDs returns the "event_annotations" edge IDs in the mutation.
func (m *UserMutation) EventAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.event_annotations {
		ids = append(ids, id)
	}
	return
}

// ResetEventAnnotations resets all changes to the "event_annotations" edge.
func (m *UserMutation) ResetEventAnnotations() {
	m.event_annotations = nil
	m.clearedevent_annotations = false
	m.removedevent_annotations = nil
}

// AddIncidentIDs adds the "incidents" edge to the Incident entity by ids.
func (m *UserMutation) AddIncidentIDs(ids ...uuid.UUID) {
	if m.incidents == nil {
		m.incidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incidents[ids[i]] = struct{}{}
	}
}

// ClearIncidents clears the "incidents" edge to the Incident entity.
func (m *UserMutation) ClearIncidents() {
	m.clearedincidents = true
}

// IncidentsCleared reports if the "incidents" edge to the Incident entity was cleared.
func (m *UserMutation) IncidentsCleared() bool {
	return m.clearedincidents
}

// RemoveIncidentIDs removes the "incidents" edge to the Incident entity by IDs.
func (m *UserMutation) RemoveIncidentIDs(ids ...uuid.UUID) {
	if m.removedincidents == nil {
		m.removedincidents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incidents, ids[i])
		m.removedincidents[ids[i]] = struct{}{}
	}
}

// RemovedIncidents returns the removed IDs of the "incidents" edge to the Incident entity.
func (m *UserMutation) RemovedIncidentsIDs() (ids []uuid.UUID) {
	for id := range m.removedincidents {
		ids = append(ids, id)
	}
	return
}

// IncidentsIDs returns the "incidents" edge IDs in the mutation.
func (m *UserMutation) IncidentsIDs() (ids []uuid.UUID) {
	for id := range m.incidents {
		ids = append(ids, id)
	}
	return
}

// ResetIncidents resets all changes to the "incidents" edge.
func (m *UserMutation) ResetIncidents() {
	m.incidents = nil
	m.clearedincidents = false
	m.removedincidents = nil
}

// AddIncidentDebriefIDs adds the "incident_debriefs" edge to the IncidentDebrief entity by ids.
func (m *UserMutation) AddIncidentDebriefIDs(ids ...uuid.UUID) {
	if m.incident_debriefs == nil {
		m.incident_debriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.incident_debriefs[ids[i]] = struct{}{}
	}
}

// ClearIncidentDebriefs clears the "incident_debriefs" edge to the IncidentDebrief entity.
func (m *UserMutation) ClearIncidentDebriefs() {
	m.clearedincident_debriefs = true
}

// IncidentDebriefsCleared reports if the "incident_debriefs" edge to the IncidentDebrief entity was cleared.
func (m *UserMutation) IncidentDebriefsCleared() bool {
	return m.clearedincident_debriefs
}

// RemoveIncidentDebriefIDs removes the "incident_debriefs" edge to the IncidentDebrief entity by IDs.
func (m *UserMutation) RemoveIncidentDebriefIDs(ids ...uuid.UUID) {
	if m.removedincident_debriefs == nil {
		m.removedincident_debriefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.incident_debriefs, ids[i])
		m.removedincident_debriefs[ids[i]] = struct{}{}
	}
}

// RemovedIncidentDebriefs returns the removed IDs of the "incident_debriefs" edge to the IncidentDebrief entity.
func (m *UserMutation) RemovedIncidentDebriefsIDs() (ids []uuid.UUID) {
	for id := range m.removedincident_debriefs {
		ids = append(ids, id)
	}
	return
}

// IncidentDebriefsIDs returns the "incident_debriefs" edge IDs in the mutation.
func (m *UserMutation) IncidentDebriefsIDs() (ids []uuid.UUID) {
	for id := range m.incident_debriefs {
		ids = append(ids, id)
	}
	return
}

// ResetIncidentDebriefs resets all changes to the "incident_debriefs" edge.
func (m *UserMutation) ResetIncidentDebriefs() {
	m.incident_debriefs = nil
	m.clearedincident_debriefs = false
	m.removedincident_debriefs = nil
}

// AddAssignedTaskIDs adds the "assigned_tasks" edge to the Task entity by ids.
func (m *UserMutation) AddAssignedTaskIDs(ids ...uuid.UUID) {
	if m.assigned_tasks == nil {
		m.assigned_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.assigned_tasks[ids[i]] = struct{}{}
	}
}

// ClearAssignedTasks clears the "assigned_tasks" edge to the Task entity.
func (m *UserMutation) ClearAssignedTasks() {
	m.clearedassigned_tasks = true
}

// AssignedTasksCleared reports if the "assigned_tasks" edge to the Task entity was cleared.
func (m *UserMutation) AssignedTasksCleared() bool {
	return m.clearedassigned_tasks
}

// RemoveAssignedTaskIDs removes the "assigned_tasks" edge to the Task entity by IDs.
func (m *UserMutation) RemoveAssignedTaskIDs(ids ...uuid.UUID) {
	if m.removedassigned_tasks == nil {
		m.removedassigned_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.assigned_tasks, ids[i])
		m.removedassigned_tasks[ids[i]] = struct{}{}
	}
}

// RemovedAssignedTasks returns the removed IDs of the "assigned_tasks" edge to the Task entity.
func (m *UserMutation) RemovedAssignedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedassigned_tasks {
		ids = append(ids, id)
	}
	return
}

// AssignedTasksIDs returns the "assigned_tasks" edge IDs in the mutation.
func (m *UserMutation) AssignedTasksIDs() (ids []uuid.UUID) {
	for id := range m.assigned_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedTasks resets all changes to the "assigned_tasks" edge.
func (m *UserMutation) ResetAssignedTasks() {
	m.assigned_tasks = nil
	m.clearedassigned_tasks = false
	m.removedassigned_tasks = nil
}

// AddCreatedTaskIDs adds the "created_tasks" edge to the Task entity by ids.
func (m *UserMutation) AddCreatedTaskIDs(ids ...uuid.UUID) {
	if m.created_tasks == nil {
		m.created_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_tasks[ids[i]] = struct{}{}
	}
}

// ClearCreatedTasks clears the "created_tasks" edge to the Task entity.
func (m *UserMutation) ClearCreatedTasks() {
	m.clearedcreated_tasks = true
}

// CreatedTasksCleared reports if the "created_tasks" edge to the Task entity was cleared.
func (m *UserMutation) CreatedTasksCleared() bool {
	return m.clearedcreated_tasks
}

// RemoveCreatedTaskIDs removes the "created_tasks" edge to the Task entity by IDs.
func (m *UserMutation) RemoveCreatedTaskIDs(ids ...uuid.UUID) {
	if m.removedcreated_tasks == nil {
		m.removedcreated_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_tasks, ids[i])
		m.removedcreated_tasks[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTasks returns the removed IDs of the "created_tasks" edge to the Task entity.
func (m *UserMutation) RemovedCreatedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_tasks {
		ids = append(ids, id)
	}
	return
}

// CreatedTasksIDs returns the "created_tasks" edge IDs in the mutation.
func (m *UserMutation) CreatedTasksIDs() (ids []uuid.UUID) {
	for id := range m.created_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTasks resets all changes to the "created_tasks" edge.
func (m *UserMutation) ResetCreatedTasks() {
	m.created_tasks = nil
	m.clearedcreated_tasks = false
	m.removedcreated_tasks = nil
}

// AddRetrospectiveReviewRequestIDs adds the "retrospective_review_requests" edge to the RetrospectiveReview entity by ids.
func (m *UserMutation) AddRetrospectiveReviewRequestIDs(ids ...uuid.UUID) {
	if m.retrospective_review_requests == nil {
		m.retrospective_review_requests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.retrospective_review_requests[ids[i]] = struct{}{}
	}
}

// ClearRetrospectiveReviewRequests clears the "retrospective_review_requests" edge to the RetrospectiveReview entity.
func (m *UserMutation) ClearRetrospectiveReviewRequests() {
	m.clearedretrospective_review_requests = true
}

// RetrospectiveReviewRequestsCleared reports if the "retrospective_review_requests" edge to the RetrospectiveReview entity was cleared.
func (m *UserMutation) RetrospectiveReviewRequestsCleared() bool {
	return m.clearedretrospective_review_requests
}

// RemoveRetrospectiveReviewRequestIDs removes the "retrospective_review_requests" edge to the RetrospectiveReview entity by IDs.
func (m *UserMutation) RemoveRetrospectiveReviewRequestIDs(ids ...uuid.UUID) {
	if m.removedretrospective_review_requests == nil {
		m.removedretrospective_review_requests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.retrospective_review_requests, ids[i])
		m.removedretrospective_review_requests[ids[i]] = struct{}{}
	}
}

// RemovedRetrospectiveReviewRequests returns the removed IDs of the "retrospective_review_requests" edge to the RetrospectiveReview entity.
func (m *UserMutation) RemovedRetrospectiveReviewRequestsIDs() (ids []uuid.UUID) {
	for id := range m.removedretrospective_review_requests {
		ids = append(ids, id)
	}
	return
}

// RetrospectiveReviewRequestsIDs returns the "retrospective_review_requests" edge IDs in the mutation.
func (m *UserMutation) RetrospectiveReviewRequestsIDs() (ids []uuid.UUID) {
	for id := range m.retrospective_review_requests {
		ids = append(ids, id)
	}
	return
}

// ResetRetrospectiveReviewRequests resets all changes to the "retrospective_review_requests" edge.
func (m *UserMutation) ResetRetrospectiveReviewRequests() {
	m.retrospective_review_requests = nil
	m.clearedretrospective_review_requests = false
	m.removedretrospective_review_requests = nil
}

// AddRetrospectiveReviewResponseIDs adds the "retrospective_review_responses" edge to the RetrospectiveReview entity by ids.
func (m *UserMutation) AddRetrospectiveReviewResponseIDs(ids ...uuid.UUID) {
	if m.retrospective_review_responses == nil {
		m.retrospective_review_responses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.retrospective_review_responses[ids[i]] = struct{}{}
	}
}

// ClearRetrospectiveReviewResponses clears the "retrospective_review_responses" edge to the RetrospectiveReview entity.
func (m *UserMutation) ClearRetrospectiveReviewResponses() {
	m.clearedretrospective_review_responses = true
}

// RetrospectiveReviewResponsesCleared reports if the "retrospective_review_responses" edge to the RetrospectiveReview entity was cleared.
func (m *UserMutation) RetrospectiveReviewResponsesCleared() bool {
	return m.clearedretrospective_review_responses
}

// RemoveRetrospectiveReviewResponseIDs removes the "retrospective_review_responses" edge to the RetrospectiveReview entity by IDs.
func (m *UserMutation) RemoveRetrospectiveReviewResponseIDs(ids ...uuid.UUID) {
	if m.removedretrospective_review_responses == nil {
		m.removedretrospective_review_responses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.retrospective_review_responses, ids[i])
		m.removedretrospective_review_responses[ids[i]] = struct{}{}
	}
}

// RemovedRetrospectiveReviewResponses returns the removed IDs of the "retrospective_review_responses" edge to the RetrospectiveReview entity.
func (m *UserMutation) RemovedRetrospectiveReviewResponsesIDs() (ids []uuid.UUID) {
	for id := range m.removedretrospective_review_responses {
		ids = append(ids, id)
	}
	return
}

// RetrospectiveReviewResponsesIDs returns the "retrospective_review_responses" edge IDs in the mutation.
func (m *UserMutation) RetrospectiveReviewResponsesIDs() (ids []uuid.UUID) {
	for id := range m.retrospective_review_responses {
		ids = append(ids, id)
	}
	return
}

// ResetRetrospectiveReviewResponses resets all changes to the "retrospective_review_responses" edge.
func (m *UserMutation) ResetRetrospectiveReviewResponses() {
	m.retrospective_review_responses = nil
	m.clearedretrospective_review_responses = false
	m.removedretrospective_review_responses = nil
}

// AddRetrospectiveCommentIDs adds the "retrospective_comments" edge to the RetrospectiveComment entity by ids.
func (m *UserMutation) AddRetrospectiveCommentIDs(ids ...uuid.UUID) {
	if m.retrospective_comments == nil {
		m.retrospective_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.retrospective_comments[ids[i]] = struct{}{}
	}
}

// ClearRetrospectiveComments clears the "retrospective_comments" edge to the RetrospectiveComment entity.
func (m *UserMutation) ClearRetrospectiveComments() {
	m.clearedretrospective_comments = true
}

// RetrospectiveCommentsCleared reports if the "retrospective_comments" edge to the RetrospectiveComment entity was cleared.
func (m *UserMutation) RetrospectiveCommentsCleared() bool {
	return m.clearedretrospective_comments
}

// RemoveRetrospectiveCommentIDs removes the "retrospective_comments" edge to the RetrospectiveComment entity by IDs.
func (m *UserMutation) RemoveRetrospectiveCommentIDs(ids ...uuid.UUID) {
	if m.removedretrospective_comments == nil {
		m.removedretrospective_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.retrospective_comments, ids[i])
		m.removedretrospective_comments[ids[i]] = struct{}{}
	}
}

// RemovedRetrospectiveComments returns the removed IDs of the "retrospective_comments" edge to the RetrospectiveComment entity.
func (m *UserMutation) RemovedRetrospectiveCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedretrospective_comments {
		ids = append(ids, id)
	}
	return
}

// RetrospectiveCommentsIDs returns the "retrospective_comments" edge IDs in the mutation.
func (m *UserMutation) RetrospectiveCommentsIDs() (ids []uuid.UUID) {
	for id := range m.retrospective_comments {
		ids = append(ids, id)
	}
	return
}

// ResetRetrospectiveComments resets all changes to the "retrospective_comments" edge.
func (m *UserMutation) ResetRetrospectiveComments() {
	m.retrospective_comments = nil
	m.clearedretrospective_comments = false
	m.removedretrospective_comments = nil
}

// AddRoleAssignmentIDs adds the "role_assignments" edge to the IncidentRoleAssignment entity by ids.
func (m *UserMutation) AddRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.role_assignments == nil {
		m.role_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_assignments[ids[i]] = struct{}{}
	}
}

// ClearRoleAssignments clears the "role_assignments" edge to the IncidentRoleAssignment entity.
func (m *UserMutation) ClearRoleAssignments() {
	m.clearedrole_assignments = true
}

// RoleAssignmentsCleared reports if the "role_assignments" edge to the IncidentRoleAssignment entity was cleared.
func (m *UserMutation) RoleAssignmentsCleared() bool {
	return m.clearedrole_assignments
}

// RemoveRoleAssignmentIDs removes the "role_assignments" edge to the IncidentRoleAssignment entity by IDs.
func (m *UserMutation) RemoveRoleAssignmentIDs(ids ...uuid.UUID) {
	if m.removedrole_assignments == nil {
		m.removedrole_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_assignments, ids[i])
		m.removedrole_assignments[ids[i]] = struct{}{}
	}
}

// RemovedRoleAssignments returns the removed IDs of the "role_assignments" edge to the IncidentRoleAssignment entity.
func (m *UserMutation) RemovedRoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_assignments {
		ids = append(ids, id)
	}
	return
}

// RoleAssignmentsIDs returns the "role_assignments" edge IDs in the mutation.
func (m *UserMutation) RoleAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.role_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetRoleAssignments resets all changes to the "role_assignments" edge.
func (m *UserMutation) ResetRoleAssignments() {
	m.role_assignments = nil
	m.clearedrole_assignments = false
	m.removedrole_assignments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m.auth_provider_id != nil {
		fields = append(fields, user.FieldAuthProviderID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.chat_id != nil {
		fields = append(fields, user.FieldChatID)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	if m.confirmed != nil {
		fields = append(fields, user.FieldConfirmed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldAuthProviderID:
		return m.AuthProviderID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldChatID:
		return m.ChatID()
	case user.FieldTimezone:
		return m.Timezone()
	case user.FieldConfirmed:
		return m.Confirmed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldAuthProviderID:
		return m.OldAuthProviderID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldChatID:
		return m.OldChatID(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	case user.FieldConfirmed:
		return m.OldConfirmed(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldAuthProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProviderID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldChatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case user.FieldConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmed(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAuthProviderID) {
		fields = append(fields, user.FieldAuthProviderID)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldChatID) {
		fields = append(fields, user.FieldChatID)
	}
	if m.FieldCleared(user.FieldTimezone) {
		fields = append(fields, user.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAuthProviderID:
		m.ClearAuthProviderID()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldChatID:
		m.ClearChatID()
		return nil
	case user.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldAuthProviderID:
		m.ResetAuthProviderID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldChatID:
		m.ResetChatID()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	case user.FieldConfirmed:
		m.ResetConfirmed()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.tenant != nil {
		edges = append(edges, user.EdgeTenant)
	}
	if m.teams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.watched_oncall_rosters != nil {
		edges = append(edges, user.EdgeWatchedOncallRosters)
	}
	if m.oncall_schedules != nil {
		edges = append(edges, user.EdgeOncallSchedules)
	}
	if m.oncall_shifts != nil {
		edges = append(edges, user.EdgeOncallShifts)
	}
	if m.event_annotations != nil {
		edges = append(edges, user.EdgeEventAnnotations)
	}
	if m.incidents != nil {
		edges = append(edges, user.EdgeIncidents)
	}
	if m.incident_debriefs != nil {
		edges = append(edges, user.EdgeIncidentDebriefs)
	}
	if m.assigned_tasks != nil {
		edges = append(edges, user.EdgeAssignedTasks)
	}
	if m.created_tasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.retrospective_review_requests != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewRequests)
	}
	if m.retrospective_review_responses != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewResponses)
	}
	if m.retrospective_comments != nil {
		edges = append(edges, user.EdgeRetrospectiveComments)
	}
	if m.role_assignments != nil {
		edges = append(edges, user.EdgeRoleAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWatchedOncallRosters:
		ids := make([]ent.Value, 0, len(m.watched_oncall_rosters))
		for id := range m.watched_oncall_rosters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallSchedules:
		ids := make([]ent.Value, 0, len(m.oncall_schedules))
		for id := range m.oncall_schedules {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallShifts:
		ids := make([]ent.Value, 0, len(m.oncall_shifts))
		for id := range m.oncall_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEventAnnotations:
		ids := make([]ent.Value, 0, len(m.event_annotations))
		for id := range m.event_annotations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.incidents))
		for id := range m.incidents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidentDebriefs:
		ids := make([]ent.Value, 0, len(m.incident_debriefs))
		for id := range m.incident_debriefs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTasks:
		ids := make([]ent.Value, 0, len(m.assigned_tasks))
		for id := range m.assigned_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.created_tasks))
		for id := range m.created_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewRequests:
		ids := make([]ent.Value, 0, len(m.retrospective_review_requests))
		for id := range m.retrospective_review_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewResponses:
		ids := make([]ent.Value, 0, len(m.retrospective_review_responses))
		for id := range m.retrospective_review_responses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveComments:
		ids := make([]ent.Value, 0, len(m.retrospective_comments))
		for id := range m.retrospective_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.role_assignments))
		for id := range m.role_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedteams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.removedwatched_oncall_rosters != nil {
		edges = append(edges, user.EdgeWatchedOncallRosters)
	}
	if m.removedoncall_schedules != nil {
		edges = append(edges, user.EdgeOncallSchedules)
	}
	if m.removedoncall_shifts != nil {
		edges = append(edges, user.EdgeOncallShifts)
	}
	if m.removedevent_annotations != nil {
		edges = append(edges, user.EdgeEventAnnotations)
	}
	if m.removedincidents != nil {
		edges = append(edges, user.EdgeIncidents)
	}
	if m.removedincident_debriefs != nil {
		edges = append(edges, user.EdgeIncidentDebriefs)
	}
	if m.removedassigned_tasks != nil {
		edges = append(edges, user.EdgeAssignedTasks)
	}
	if m.removedcreated_tasks != nil {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.removedretrospective_review_requests != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewRequests)
	}
	if m.removedretrospective_review_responses != nil {
		edges = append(edges, user.EdgeRetrospectiveReviewResponses)
	}
	if m.removedretrospective_comments != nil {
		edges = append(edges, user.EdgeRetrospectiveComments)
	}
	if m.removedrole_assignments != nil {
		edges = append(edges, user.EdgeRoleAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWatchedOncallRosters:
		ids := make([]ent.Value, 0, len(m.removedwatched_oncall_rosters))
		for id := range m.removedwatched_oncall_rosters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallSchedules:
		ids := make([]ent.Value, 0, len(m.removedoncall_schedules))
		for id := range m.removedoncall_schedules {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOncallShifts:
		ids := make([]ent.Value, 0, len(m.removedoncall_shifts))
		for id := range m.removedoncall_shifts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEventAnnotations:
		ids := make([]ent.Value, 0, len(m.removedevent_annotations))
		for id := range m.removedevent_annotations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidents:
		ids := make([]ent.Value, 0, len(m.removedincidents))
		for id := range m.removedincidents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIncidentDebriefs:
		ids := make([]ent.Value, 0, len(m.removedincident_debriefs))
		for id := range m.removedincident_debriefs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTasks:
		ids := make([]ent.Value, 0, len(m.removedassigned_tasks))
		for id := range m.removedassigned_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTasks:
		ids := make([]ent.Value, 0, len(m.removedcreated_tasks))
		for id := range m.removedcreated_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewRequests:
		ids := make([]ent.Value, 0, len(m.removedretrospective_review_requests))
		for id := range m.removedretrospective_review_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveReviewResponses:
		ids := make([]ent.Value, 0, len(m.removedretrospective_review_responses))
		for id := range m.removedretrospective_review_responses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRetrospectiveComments:
		ids := make([]ent.Value, 0, len(m.removedretrospective_comments))
		for id := range m.removedretrospective_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoleAssignments:
		ids := make([]ent.Value, 0, len(m.removedrole_assignments))
		for id := range m.removedrole_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedtenant {
		edges = append(edges, user.EdgeTenant)
	}
	if m.clearedteams {
		edges = append(edges, user.EdgeTeams)
	}
	if m.clearedwatched_oncall_rosters {
		edges = append(edges, user.EdgeWatchedOncallRosters)
	}
	if m.clearedoncall_schedules {
		edges = append(edges, user.EdgeOncallSchedules)
	}
	if m.clearedoncall_shifts {
		edges = append(edges, user.EdgeOncallShifts)
	}
	if m.clearedevent_annotations {
		edges = append(edges, user.EdgeEventAnnotations)
	}
	if m.clearedincidents {
		edges = append(edges, user.EdgeIncidents)
	}
	if m.clearedincident_debriefs {
		edges = append(edges, user.EdgeIncidentDebriefs)
	}
	if m.clearedassigned_tasks {
		edges = append(edges, user.EdgeAssignedTasks)
	}
	if m.clearedcreated_tasks {
		edges = append(edges, user.EdgeCreatedTasks)
	}
	if m.clearedretrospective_review_requests {
		edges = append(edges, user.EdgeRetrospectiveReviewRequests)
	}
	if m.clearedretrospective_review_responses {
		edges = append(edges, user.EdgeRetrospectiveReviewResponses)
	}
	if m.clearedretrospective_comments {
		edges = append(edges, user.EdgeRetrospectiveComments)
	}
	if m.clearedrole_assignments {
		edges = append(edges, user.EdgeRoleAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTenant:
		return m.clearedtenant
	case user.EdgeTeams:
		return m.clearedteams
	case user.EdgeWatchedOncallRosters:
		return m.clearedwatched_oncall_rosters
	case user.EdgeOncallSchedules:
		return m.clearedoncall_schedules
	case user.EdgeOncallShifts:
		return m.clearedoncall_shifts
	case user.EdgeEventAnnotations:
		return m.clearedevent_annotations
	case user.EdgeIncidents:
		return m.clearedincidents
	case user.EdgeIncidentDebriefs:
		return m.clearedincident_debriefs
	case user.EdgeAssignedTasks:
		return m.clearedassigned_tasks
	case user.EdgeCreatedTasks:
		return m.clearedcreated_tasks
	case user.EdgeRetrospectiveReviewRequests:
		return m.clearedretrospective_review_requests
	case user.EdgeRetrospectiveReviewResponses:
		return m.clearedretrospective_review_responses
	case user.EdgeRetrospectiveComments:
		return m.clearedretrospective_comments
	case user.EdgeRoleAssignments:
		return m.clearedrole_assignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ResetTenant()
		return nil
	case user.EdgeTeams:
		m.ResetTeams()
		return nil
	case user.EdgeWatchedOncallRosters:
		m.ResetWatchedOncallRosters()
		return nil
	case user.EdgeOncallSchedules:
		m.ResetOncallSchedules()
		return nil
	case user.EdgeOncallShifts:
		m.ResetOncallShifts()
		return nil
	case user.EdgeEventAnnotations:
		m.ResetEventAnnotations()
		return nil
	case user.EdgeIncidents:
		m.ResetIncidents()
		return nil
	case user.EdgeIncidentDebriefs:
		m.ResetIncidentDebriefs()
		return nil
	case user.EdgeAssignedTasks:
		m.ResetAssignedTasks()
		return nil
	case user.EdgeCreatedTasks:
		m.ResetCreatedTasks()
		return nil
	case user.EdgeRetrospectiveReviewRequests:
		m.ResetRetrospectiveReviewRequests()
		return nil
	case user.EdgeRetrospectiveReviewResponses:
		m.ResetRetrospectiveReviewResponses()
		return nil
	case user.EdgeRetrospectiveComments:
		m.ResetRetrospectiveComments()
		return nil
	case user.EdgeRoleAssignments:
		m.ResetRoleAssignments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
